<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>常用知识总结 | 前端技术博客</title>
    <meta name="author" content="xiaosongread">
    <meta name="keywords" content="小宋 抿圪斗前端 前端 前端博客 框架 工程 css html js node markdown npm webpack">
    <meta name="description" content="– html/css— css的布局方式1.table布局2.flex布局3.float布局4.响应式布局— 盒子模型IE盒子模型：宽高包括content + padding + bording; box-sizing: border-box标准盒模型：宽高就是元素的实际宽高 content; box-sizing: content-box— HTML5新增元素12345678910canvas/audio/videosource(定义媒体资源&amp;lt;video&amp;gt;/&amp;lt;aud...">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="前端技术博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <style type="text/css">
    @font-face {
        font-family: 'icomoon';
        src: url("/fonts/icomoon.eot?q628ml");
        src: url("/fonts/icomoon.eot?q628ml#iefix") format('embedded-opentype'),
             url("/fonts/icomoon.ttf?q628ml") format('truetype'),
             url("/fonts/icomoon.woff?q628ml") format('woff'),
             url("/fonts/icomoon.svg?q628ml#icomoon") format('svg');
        font-weight: normal;
        font-style: normal;
    }
    </style>
    <link rel="stylesheet" href="/css/style.css">

    <!--[if lt IE 9]><style type="text/css">.nav-inner {top:0;}.author-meta {position:static;top:0;}.search-form {height:36px;}</style><script type="text/javascript" src="https://unpkg.com/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
</head>
<body>

    <main class="app">
        <header id="header" class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">前端技术博客</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/categories/css-end/">
                <span class="nav-text">css</span>
            </a>
        
            <a class="nav-item" href="/categories/js-end/">
                <span class="nav-text">js</span>
            </a>
        
            <a class="nav-item" href="/categories/gc-end/">
                <span class="nav-text">工程</span>
            </a>
        
            <a class="nav-item" href="/categories/sh-end/">
                <span class="nav-text">日常</span>
            </a>
        
            <a class="nav-item" href="/categories/my-end/">
                <span class="nav-text">关于我</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#–-html-css"><span class="toc-number">1.</span> <span class="toc-text">– html/css</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#—-css的布局方式"><span class="toc-number">1.1.</span> <span class="toc-text">— css的布局方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-盒子模型"><span class="toc-number">1.2.</span> <span class="toc-text">— 盒子模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-HTML5新增元素"><span class="toc-number">1.3.</span> <span class="toc-text">— HTML5新增元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-居中的方式"><span class="toc-number">1.4.</span> <span class="toc-text">— 居中的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-rem、em、vh、px各自代表的含义？"><span class="toc-number">1.5.</span> <span class="toc-text">— rem、em、vh、px各自代表的含义？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-有哪些方式可以影藏页面元素？区别是什么？"><span class="toc-number">1.6.</span> <span class="toc-text">— 有哪些方式可以影藏页面元素？区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-css选择器有哪些？优先级"><span class="toc-number">1.7.</span> <span class="toc-text">— css选择器有哪些？优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-清除浮动的方法"><span class="toc-number">1.8.</span> <span class="toc-text">— 清除浮动的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-常见的行内元素、块级元素"><span class="toc-number">1.9.</span> <span class="toc-text">— 常见的行内元素、块级元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-position的属性"><span class="toc-number">1.10.</span> <span class="toc-text">— position的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-SEO"><span class="toc-number">1.11.</span> <span class="toc-text">— SEO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-什么是响应式布局？"><span class="toc-number">1.12.</span> <span class="toc-text">— 什么是响应式布局？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#javascript"><span class="toc-number">2.</span> <span class="toc-text">javascript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#—-js中的数据类型"><span class="toc-number">2.1.</span> <span class="toc-text">— js中的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-var-let-const-的区别？"><span class="toc-number">2.2.</span> <span class="toc-text">— var/let/const 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-数组常用的方法"><span class="toc-number">2.3.</span> <span class="toc-text">— 数组常用的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-number">2.3.1.</span> <span class="toc-text">增删改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-number">2.3.2.</span> <span class="toc-text">查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-number">2.3.3.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组转字符窜"><span class="toc-number">2.3.4.</span> <span class="toc-text">数组转字符窜</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代"><span class="toc-number">2.3.5.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#去重"><span class="toc-number">2.3.6.</span> <span class="toc-text">去重</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-bind-call-apply的区别？"><span class="toc-number">2.4.</span> <span class="toc-text">— bind/call/apply的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#箭头函数和普通函数的区别"><span class="toc-number">2.5.</span> <span class="toc-text">箭头函数和普通函数的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-typeof-与-instanceof-区别"><span class="toc-number">2.6.</span> <span class="toc-text">— typeof 与 instanceof 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-本地存储"><span class="toc-number">2.7.</span> <span class="toc-text">— 本地存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-深拷贝和浅拷贝"><span class="toc-number">2.8.</span> <span class="toc-text">— 深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-JSON是什么？"><span class="toc-number">2.9.</span> <span class="toc-text">— JSON是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-闭包，使用场景"><span class="toc-number">2.10.</span> <span class="toc-text">— 闭包，使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概念"><span class="toc-number">2.10.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决的问题"><span class="toc-number">2.10.2.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包带来的问题和如何规避"><span class="toc-number">2.10.3.</span> <span class="toc-text">闭包带来的问题和如何规避</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简单实现一个闭包"><span class="toc-number">2.10.4.</span> <span class="toc-text">简单实现一个闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包的作用"><span class="toc-number">2.10.5.</span> <span class="toc-text">闭包的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包的应用场景"><span class="toc-number">2.10.6.</span> <span class="toc-text">闭包的应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-什么是防抖和节流？"><span class="toc-number">2.11.</span> <span class="toc-text">— 什么是防抖和节流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-ajax的请求过程"><span class="toc-number">2.12.</span> <span class="toc-text">— ajax的请求过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-ajax请求的时候get-和post方式的区别"><span class="toc-number">2.13.</span> <span class="toc-text">— ajax请求的时候get 和post方式的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-ajax、axios、jsonp的理解"><span class="toc-number">2.14.</span> <span class="toc-text">— ajax、axios、jsonp的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-什么是事件委托以及优缺点"><span class="toc-number">2.15.</span> <span class="toc-text">— 什么是事件委托以及优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-如何解决数字精度丢失的问题"><span class="toc-number">2.16.</span> <span class="toc-text">— 如何解决数字精度丢失的问题?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-原型，原型链-有什么特点？"><span class="toc-number">2.17.</span> <span class="toc-text">— 原型，原型链 ? 有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-如何实现上拉加载，下拉刷新？"><span class="toc-number">2.18.</span> <span class="toc-text">— 如何实现上拉加载，下拉刷新？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-说说你对作用域链的理解"><span class="toc-number">2.19.</span> <span class="toc-text">— 说说你对作用域链的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-浏览器输入Url之后发生了什么？"><span class="toc-number">2.20.</span> <span class="toc-text">— 浏览器输入Url之后发生了什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue相关"><span class="toc-number">3.</span> <span class="toc-text">vue相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是mvvm"><span class="toc-number">3.1.</span> <span class="toc-text">什么是mvvm?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用虚拟dom"><span class="toc-number">3.2.</span> <span class="toc-text">为什么使用虚拟dom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue中key是用来做什么的？为什么不推介使用index作为key？"><span class="toc-number">3.3.</span> <span class="toc-text">Vue中key是用来做什么的？为什么不推介使用index作为key？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-show和v-if的区别"><span class="toc-number">3.4.</span> <span class="toc-text">v-show和v-if的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双向数据绑定"><span class="toc-number">3.5.</span> <span class="toc-text">双向数据绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生命周期函数有哪些"><span class="toc-number">3.6.</span> <span class="toc-text">生命周期函数有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的指令？常用的内置组件有哪些？"><span class="toc-number">3.7.</span> <span class="toc-text">常用的指令？常用的内置组件有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue自定义指令设置"><span class="toc-number">3.8.</span> <span class="toc-text">vue自定义指令设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#父子组件之间的通信"><span class="toc-number">3.9.</span> <span class="toc-text">父子组件之间的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路由跳转的方式，传参方式有哪些？"><span class="toc-number">3.10.</span> <span class="toc-text">路由跳转的方式，传参方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#router-和-route的区别"><span class="toc-number">3.11.</span> <span class="toc-text">router 和 route的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编程式导航的使用方法"><span class="toc-number">3.12.</span> <span class="toc-text">编程式导航的使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是路由守卫？路由的钩子函数有哪些？"><span class="toc-number">3.13.</span> <span class="toc-text">什么是路由守卫？路由的钩子函数有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vuex的理解"><span class="toc-number">3.14.</span> <span class="toc-text">vuex的理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小程序相关"><span class="toc-number">4.</span> <span class="toc-text">小程序相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生命周期函数有哪些？小程序的周期函数？"><span class="toc-number">4.1.</span> <span class="toc-text">生命周期函数有哪些？小程序的周期函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用与页面生命周期发生顺序"><span class="toc-number">4.2.</span> <span class="toc-text">应用与页面生命周期发生顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小程序是如何传值？"><span class="toc-number">4.3.</span> <span class="toc-text">小程序是如何传值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wxss和css的区别"><span class="toc-number">4.4.</span> <span class="toc-text">wxss和css的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小程序是如何传递数据？"><span class="toc-number">4.5.</span> <span class="toc-text">小程序是如何传递数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webview的理解"><span class="toc-number">4.6.</span> <span class="toc-text">webview的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意事项"><span class="toc-number">4.7.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小程序的双向绑定和vue的有什么区别"><span class="toc-number">4.8.</span> <span class="toc-text">小程序的双向绑定和vue的有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#下拉刷新的实现方法"><span class="toc-number">4.9.</span> <span class="toc-text">下拉刷新的实现方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跳转的方式有哪些"><span class="toc-number">4.10.</span> <span class="toc-text">跳转的方式有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#描述一下小程序的登陆流程"><span class="toc-number">4.11.</span> <span class="toc-text">描述一下小程序的登陆流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wx-if和hidden的区别，如何使用？"><span class="toc-number">4.12.</span> <span class="toc-text">wx:if和hidden的区别，如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#app-json的配置项"><span class="toc-number">4.13.</span> <span class="toc-text">app.json的配置项</span></a></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
            <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            常用知识总结
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://www.shuy.cc/2022/05/05/mianshi/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2022-05-05T05:54:03.000Z" itemprop="datePublished">2022-05-05</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/css-js-vue/">css js vue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="–-html-css"><a href="#–-html-css" class="headerlink" title="– html/css"></a>– html/css</h2><h3 id="—-css的布局方式"><a href="#—-css的布局方式" class="headerlink" title="— css的布局方式"></a>— css的布局方式</h3><p>1.table布局<br>2.flex布局<br>3.float布局<br>4.响应式布局</p>
<h3 id="—-盒子模型"><a href="#—-盒子模型" class="headerlink" title="— 盒子模型"></a>— 盒子模型</h3><p>IE盒子模型：宽高包括content + padding + bording; box-sizing: border-box<br>标准盒模型：宽高就是元素的实际宽高 content; box-sizing: content-box<br><a id="more"></a></p>
<h3 id="—-HTML5新增元素"><a href="#—-HTML5新增元素" class="headerlink" title="— HTML5新增元素"></a>— HTML5新增元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">canvas/audio/video</span><br><span class="line">source(定义媒体资源&lt;video&gt;/&lt;audio&gt;)/</span><br><span class="line">embed(定义嵌入的内容)/track(为诸如video和audio元素之类的媒介规定外部文本轨道)</span><br><span class="line">article 定义页面独立的内容区域</span><br><span class="line">aside 定义页面的侧边栏内容</span><br><span class="line">details 描述文档或文档某个部分的细节</span><br><span class="line">dialog 定义对话框</span><br><span class="line">footer header 定义文档的头尾区域</span><br><span class="line">nav 定义导航链接的部分</span><br><span class="line">等等</span><br></pre></td></tr></table></figure>
<h3 id="—-居中的方式"><a href="#—-居中的方式" class="headerlink" title="— 居中的方式"></a>— 居中的方式</h3><p>1) 父子元素的宽高已知<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">margin: 父元素的高减去子元素的高/2(垂直居中) auto(水平居中)</span><br></pre></td></tr></table></figure></p>
<p>2) 父子元素的宽高未知</p>
<h3 id="—-rem、em、vh、px各自代表的含义？"><a href="#—-rem、em、vh、px各自代表的含义？" class="headerlink" title="— rem、em、vh、px各自代表的含义？"></a>— rem、em、vh、px各自代表的含义？</h3><p>px: 绝对单位，页面按精确像素展示<br>em: 相对单位，基准为父节点字体大小，如果滋生定义了font-size按照自身来计算，整个页面内1em不是一个固定值<br>rem: 相对单位，可以理解为root em，相对根节点html的字体大小来计算<br>vh/vw: 主要用于页面视口大小布局，在页面布局上更加方便简单</p>
<h3 id="—-有哪些方式可以影藏页面元素？区别是什么？"><a href="#—-有哪些方式可以影藏页面元素？区别是什么？" class="headerlink" title="— 有哪些方式可以影藏页面元素？区别是什么？"></a>— 有哪些方式可以影藏页面元素？区别是什么？</h3><ul>
<li>display: none</li>
<li>visibility: hidden</li>
<li>opacity: 0 </li>
<li>width + height 设置为0</li>
<li>定位到可视范围之外</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>display: none</th>
<th>visibility: hidden</th>
<th>opacity: 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>页面中</td>
<td>不存在</td>
<td>存在</td>
<td>存在</td>
</tr>
<tr>
<td>重排</td>
<td>会</td>
<td>不会</td>
<td>不会</td>
</tr>
<tr>
<td>重绘</td>
<td>会</td>
<td>会</td>
<td>不一定</td>
</tr>
<tr>
<td>自身绑定事件</td>
<td>不触发</td>
<td>不触发</td>
<td>触发</td>
</tr>
<tr>
<td>transition</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>被遮挡的元素可出发事件</td>
<td>能</td>
<td>能</td>
<td>不能</td>
</tr>
</tbody>
</table>
<h3 id="—-css选择器有哪些？优先级"><a href="#—-css选择器有哪些？优先级" class="headerlink" title="— css选择器有哪些？优先级"></a>— css选择器有哪些？优先级</h3><ul>
<li>!important </li>
<li>行内样式</li>
<li>Id选择器</li>
<li>类选择器 class</li>
<li>后代选择器 .box dox</li>
<li>子选择器 .box&gt;.child 选择.box下面所有类名为child的元素</li>
<li>相邻同胞选择器 .one+.two,选择紧邻.one之后的所有.two元素</li>
<li>div,p 选择所有的div、p的所有元素 </li>
<li>伪类选择器</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:link</span> 选择未被访问的链接</span><br><span class="line"><span class="selector-pseudo">:visited</span>：选取已被访问的链接</span><br><span class="line"><span class="selector-pseudo">:active</span>：选择活动链接</span><br><span class="line"><span class="selector-pseudo">:hover</span> ：鼠标指针浮动在上面的元素</span><br><span class="line"><span class="selector-pseudo">:focus</span> ：选择具有焦点的</span><br><span class="line"><span class="selector-pseudo">:first-child</span>：父元素的首个子元</span><br></pre></td></tr></table></figure>
<ul>
<li>伪元素选择器</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:first-letter</span> ：用于选取指定选择器的首字母</span><br><span class="line"><span class="selector-pseudo">:first-line</span> ：选取指定选择器的首行</span><br><span class="line"><span class="selector-pseudo">:before</span> : 选择器在被选元素的内容前面插入内容</span><br><span class="line"><span class="selector-pseudo">:after</span> : 选择器在被选元素的内容后面插入内容</span><br></pre></td></tr></table></figure>
<ul>
<li>属性选择器</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[attribute]</span> 选择带有<span class="selector-tag">attribute</span>属性的元素</span><br><span class="line">[attribute=value] 选择所有使用attribute=value的元素</span><br><span class="line"><span class="selector-attr">[attribute~=value]</span> 选择<span class="selector-tag">attribute</span>属性包含<span class="selector-tag">value</span>的元素</span><br><span class="line"><span class="selector-attr">[attribute|=value]</span>：选择<span class="selector-tag">attribute</span>属性以<span class="selector-tag">value</span>开头的元素</span><br></pre></td></tr></table></figure>
<ul>
<li>伪类选择器（css3） </li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:first-of-type</span> 父元素的首个元素</span><br><span class="line"><span class="selector-pseudo">:last-of-type</span> 父元素的最后一个元素</span><br><span class="line"><span class="selector-pseudo">:only-of-type</span> 父元素的特定类型的唯一子元素</span><br><span class="line"><span class="selector-pseudo">:only-child</span> 父元素中唯一子元素</span><br><span class="line"><span class="selector-pseudo">:nth-child(n)</span> 选择父元素中第<span class="selector-tag">N</span>个子元素</span><br><span class="line"><span class="selector-pseudo">:nth-last-of-type(n)</span> 选择父元素中第<span class="selector-tag">N</span>个子元素，从后往前</span><br><span class="line"><span class="selector-pseudo">:last-child</span> 父元素的最后一个元素</span><br><span class="line"><span class="selector-pseudo">:root</span> 设置<span class="selector-tag">HTML</span>文档</span><br><span class="line"><span class="selector-pseudo">:empty</span> 指定空的元素</span><br><span class="line"><span class="selector-pseudo">:enabled</span> 选择被禁用元素</span><br><span class="line"><span class="selector-pseudo">:disabled</span> 选择被禁用元素</span><br><span class="line"><span class="selector-pseudo">:checked</span> 选择选中的元素</span><br><span class="line"><span class="selector-pseudo">:not(selector)</span> 选择非 &lt;<span class="selector-tag">selector</span>&gt; 元素的所有元素</span><br></pre></td></tr></table></figure>
<ul>
<li>属性选择器（css3） </li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[attribute*=value]</span>：选择<span class="selector-tag">attribute</span>属性值包含<span class="selector-tag">value</span>的所有元素</span><br><span class="line"><span class="selector-attr">[attribute^=value]</span>：选择<span class="selector-tag">attribute</span>属性开头为<span class="selector-tag">value</span>的所有元素</span><br><span class="line"><span class="selector-attr">[attribute$=value]</span>：选择<span class="selector-tag">attribute</span>属性结尾为<span class="selector-tag">value</span>的所有元素</span><br></pre></td></tr></table></figure>
<p>nth-child/nth-of-type的区别<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>1<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>2<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>3<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>4<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>6<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>7<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2n+1 // 1 3 5 7</span><br><span class="line"><span class="selector-tag">h5</span><span class="selector-pseudo">:nth-child(2n+1)</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/img-folder/2023/ms-1.png"></p>
<p>1）先找设置标签的全部同级标签<br>2）然后找对应的下标，如果选择器一致，那就匹配上，不一致就继续匹配下个下标的选择器</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h5</span><span class="selector-pseudo">:nth-of-type(2n+1)</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/img-folder/2023/ms-2.png"></p>
<p>1）找出和设置标签一样的标签<br>2）然后再找对应的下标标签</p>
<h3 id="—-清除浮动的方法"><a href="#—-清除浮动的方法" class="headerlink" title="— 清除浮动的方法"></a>— 清除浮动的方法</h3><p>1）使用带clear属性的空元素<br>在浮动元素的后面设置一个空元素，然后给这个空元素设置属性.clear{clear:both;}<br>2）使用overflow属性<br>给浮动元素的容器添加overflow:hidden;或 overflow:auto;可以清除浮动，另外在 IE6 中还 需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。 在添加 overflow 属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动 的效果。<br>3）使用css的:after伪元素<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span>  solid<span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"020"</span>; </span><br><span class="line">  <span class="attribute">display</span>: block; </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attribute">clear</span>: both; </span><br><span class="line">  <span class="comment">/* 表示元素不可见 */</span></span><br><span class="line">  <span class="attribute">visibility</span>: hidden;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.media</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background-color</span>:aquamarine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&lt;div class="container"&gt;</span><br><span class="line">  &lt;div class="media"&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;p&gt;hello&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="—-常见的行内元素、块级元素"><a href="#—-常见的行内元素、块级元素" class="headerlink" title="— 常见的行内元素、块级元素"></a>— 常见的行内元素、块级元素</h3><p>1.块级元素<br>  div/p/h1~h6/ol/ul/li/table<br>2.行内元素<br>  span/img/a/strong/input</p>
<h3 id="—-position的属性"><a href="#—-position的属性" class="headerlink" title="— position的属性"></a>— position的属性</h3><p>相对定位：relative,相对于当前元素的位置来移动<br>绝对定位：absolute,相对于父元素（具有相对定位属性）来定位<br>固定定位：fixed,相对于页面的左上角定位</p>
<h3 id="—-SEO"><a href="#—-SEO" class="headerlink" title="— SEO"></a>— SEO</h3><p>1）语义化的html的标签使用<br>2）设置合理的title,description,keywords<br>3）重要的html代码放到页面的前面<br>4）尽量少用iframe，搜索引擎抓不到里面的内容<br>5）图片上面加上alt属性</p>
<h3 id="—-什么是响应式布局？"><a href="#—-什么是响应式布局？" class="headerlink" title="— 什么是响应式布局？"></a>— 什么是响应式布局？</h3><p>响应式网站设计（Responsive Web design）是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整</p>
<p>1&gt; 响应式网站常见特点：</p>
<ul>
<li>同时适配PC + 平板 + 手机等</li>
<li>标签导航在接近手持终端设备时改变为经典的抽屉式导航</li>
<li>网站的布局会根据视口来调整模块的大小和位置</li>
</ul>
<p>2&gt; 实现响应式布局的方式有如下：</p>
<ul>
<li>媒体查询（我们可以设置不同类型的媒体条件，并根据对应的条件，给相应符合条件的媒体调用相对应的样式表）</li>
<li>百分比</li>
<li>vw/vh</li>
<li>rem</li>
</ul>
<p>3&gt; 响应式设计实现通常会从以下几方面思考：</p>
<ul>
<li>弹性盒子（包括图片、表格、视频）和媒体查询等技术</li>
<li>使用百分比布局创建流式布局的弹性UI，同时使用媒体查询限制元素的尺寸和内容变更范围</li>
<li>使用相对单位使得内容自适应调节</li>
<li>选择断点，针对不同断点实现不同布局和内容展示</li>
</ul>
<h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="—-js中的数据类型"><a href="#—-js中的数据类型" class="headerlink" title="— js中的数据类型"></a>— js中的数据类型</h3><ul>
<li>基本类型 string number null undefind boolean Symbol(ES6 引入了一种新的原始数据类型，表示独一无二的值)</li>
<li>引用类型 Object Array Function</li>
</ul>
<h3 id="—-var-let-const-的区别？"><a href="#—-var-let-const-的区别？" class="headerlink" title="— var/let/const 的区别？"></a>— var/let/const 的区别？</h3><ul>
<li>变量提升<br>var申明存在变量提升，let和const存在变量提升，不声明是不可以使用的，否则会报错</li>
<li>作用域<br>var 没有块级作用域一说，不声明也是可以使用的，let，const有块级作用域一说，只能在申明的花括号里面使用</li>
<li>使用的方法<br>const声明一个只读的变量，一旦声明，不可以修改，其余使用let，避免使用var，因为有不可控性，代码复杂的时候，不容易查找问题。</li>
</ul>
<h3 id="—-数组常用的方法"><a href="#—-数组常用的方法" class="headerlink" title="— 数组常用的方法"></a>— 数组常用的方法</h3><h4>增删改</h4>

<table>
<thead>
<tr>
<th></th>
<th>向前+</th>
<th>向前-</th>
<th>向后+</th>
<th>向后-</th>
</tr>
</thead>
<tbody>
<tr>
<td>页面中</td>
<td>unshift</td>
<td>shift</td>
<td>push</td>
<td>pop</td>
</tr>
<tr>
<td>语法</td>
<td>array.unshift(item1,item2, …, itemX)</td>
<td>array.shift()</td>
<td>array.push(item1, item2, …, itemX)</td>
<td>array.pop()</td>
</tr>
<tr>
<td>返回结果</td>
<td>数组新长度</td>
<td>数组原来的第一个元素的值（移除的元素）</td>
<td>数组新长度</td>
<td>返回删除的元素</td>
</tr>
<tr>
<td>原数组</td>
<td>改变原数组</td>
<td>改变了原数组</td>
<td>改变原数组</td>
<td>改变了原数组</td>
</tr>
</tbody>
</table>
<ul>
<li>concat 合并两个数组</li>
<li>splice （增、删、改）传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组<br>array.splice(index,howmany,item1,…..,itemX)</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>必需。规定从何处添加/删除元素。<br>该参数是开始插入和（或）删除的数组元素的下标，必须是数字。</td>
</tr>
<tr>
<td>howmany</td>
<td>可选。规定应该删除多少元素。必须是数字，但可以是 “0”。<br>如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。</td>
</tr>
<tr>
<td>item1, …, itemX</td>
<td>可选。要添加到数组的新元素</td>
</tr>
</tbody>
</table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除数组的第三个元素，并在数组第三个位置添加新元素:</span></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line">fruits.splice(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"Lemon"</span>,<span class="string">"Kiwi"</span>);</span><br><span class="line"><span class="comment">// Banana,Orange,Lemon,Kiwi,Mango</span></span><br><span class="line"><span class="comment">// 从第三个位置开始删除数组后的两个元素：</span></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line"><span class="comment">// Banana,Orange</span></span><br><span class="line">fruits.splice(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>slice() 方法可从已有的数组中返回选定的元素。<br>slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。【不会影响原始数组】<br>array.slice(start, end)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用负值从数组中读取元素</span></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Lemon"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line"><span class="keyword">var</span> myBest = fruits.slice(<span class="number">-3</span>,<span class="number">-1</span>); <span class="comment">// 截取倒数第三个（包含）到倒数第一个（不包含）的两个元素</span></span><br><span class="line"><span class="keyword">var</span> myBest = fruits.slice(<span class="number">-3</span>);  <span class="comment">// 截取最后三个元素</span></span><br><span class="line"><span class="comment">// Lemon,Apple</span></span><br><span class="line"><span class="comment">// 截取字符串</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"www.runoob.com!"</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.slice(<span class="number">4</span>)+<span class="string">"&lt;br&gt;"</span>); <span class="comment">// 从第 5 个字符开始截取到末尾</span></span><br><span class="line"><span class="built_in">document</span>.write(str.slice(<span class="number">4</span>,<span class="number">10</span>)); <span class="comment">// 从第 5 个字符开始截取到第10个字符</span></span><br></pre></td></tr></table></figure>
<p></p><h4>查</h4><br>查找元素，返回元素坐标或者元素值<p></p>
<ul>
<li>indexOf() 返回要查找的元素在数组中的位置，如果没找到则返回 -1</li>
<li>includes() 返回要查找的元素在数组中的位置，找到返回true，否则false</li>
<li>find() 返回通过测试（函数内判断）的数组的第一个元素的值<br>当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。<br>如果没有符合条件的元素返回 undefined</li>
</ul>
<blockquote>
<p>array.find(function(currentValue, index, arr),thisValue)<br>[参数]<br>callback：必须。为数组中每个元素执行的函数，该函数接受三个参数：<br>currentValue：必须。数组中正在处理的当前元素。<br>index：可选。当前元素的索引值。<br>arr：可选。当前元素所在的数组对象。<br>thisValue：可选。传递给函数的值一般用 “this” 值。<br>如果这个参数为空， “undefined” 会传递给 “this” 值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> num = arr1.find(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>findIndex() 返回传入一个测试条件（函数）符合条件的数组第一个元素位置。<br>当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。<br>如果没有符合条件的元素返回 -1</li>
</ul>
<blockquote>
<p>array.findIndex(function(currentValue, index, arr), thisValue)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 可以这么写</span></span><br><span class="line"><span class="keyword">const</span> index = arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(index) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 也可以这么写</span></span><br><span class="line"><span class="keyword">const</span> index = arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p></p><h4>排序</h4><p></p>
<ul>
<li>reverse() 将数组元素翻转</li>
<li>sort() </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">22</span>,<span class="number">11</span>,<span class="number">33</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort()) <span class="comment">// [1,11,2,22,3,33,4,5]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下sort方法是按ascii字母顺序排序的，而非我们认为是按数字大小排序 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">v1,v2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (v1&gt;v2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(v1&lt;v2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v1===v2)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a.sort(compare)</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [1, 1, 2, 3, 4, 5, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">v1, v2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v2-v1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a.sort(compare)</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [10, 9, 5, 4, 3, 2, 1, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">v1, v2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v1-v2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a.sort(compare)</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [1, 1, 2, 3, 4, 5, 9, 10]</span></span><br></pre></td></tr></table></figure>
<h4 id="数组转字符窜"><a href="#数组转字符窜" class="headerlink" title="数组转字符窜"></a>数组转字符窜</h4><p>join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串</p>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><ul>
<li>some() 对数组每一项都运行传入的函数，有一项符合就返回true</li>
<li>every() 每一项都符合才返回true</li>
<li>forEach() 循环数组每一项，没有返回值</li>
<li>filter() 返回符合的项会组成函数</li>
<li>map() 返回由每次函数调用的结果组成的函数</li>
<li>for…in 遍历对象的属性key</li>
<li>for…of 遍历对象的值value</li>
</ul>
<h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><p>1.利用ES6 Set去重</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>,&#123;&#125;,&#123;&#125;, <span class="number">1</span>, <span class="string">'a'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">// [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", &#123;&#125;, &#123;&#125;]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Array.from()方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组，也是ES6的新增方法。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'tom'</span>, </span><br><span class="line">  <span class="number">1</span>: <span class="string">'65'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'男'</span>,</span><br><span class="line">  <span class="number">3</span>: [<span class="string">'jane'</span>,<span class="string">'john'</span>,<span class="string">'Mary'</span>],</span><br><span class="line">  <span class="string">'length'</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(arrayLike)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ['tom','65','男',['jane','john','Mary']]</span></span><br></pre></td></tr></table></figure>
<p>2.利用for嵌套for，然后splice去重（ES5中最常用）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;            </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>; j&lt;arr.length; j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(arr[i]==arr[j])&#123;         <span class="comment">//第一个等同于第二个，splice方法删除第二个</span></span><br><span class="line">              arr.splice(j,<span class="number">1</span>);</span><br><span class="line">              j--;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, "true", 15, false, undefined, NaN, NaN, "NaN", "a", &#123;…&#125;, &#123;…&#125;]     //NaN和&#123;&#125;没有去重，两个null直接消失了</span></span><br></pre></td></tr></table></figure></p>
<p>3.利用indexOf去重<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'type error!'</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> array = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array .indexOf(arr[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">          array .push(arr[i])</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">// [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", &#123;…&#125;, &#123;…&#125;]  //NaN、&#123;&#125;没有去重</span></span><br></pre></td></tr></table></figure></p>
<p>4.利用includes<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'type error!'</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> array =[];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>( !array.includes( arr[i]) ) &#123;<span class="comment">//includes 检测数组是否有某个值</span></span><br><span class="line">            array.push(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", &#123;…&#125;, &#123;…&#125;]     //&#123;&#125;没有去重</span></span><br></pre></td></tr></table></figure></p>
<h3 id="—-bind-call-apply的区别？"><a href="#—-bind-call-apply的区别？" class="headerlink" title="— bind/call/apply的区别？"></a>— bind/call/apply的区别？</h3><ul>
<li>call()的第一个参数为this绑定的对象，后面传入一串字符窜<br>当第一个参数为null或者undefined的时候，默认指向window</li>
<li>apply()和call类似，不同在于第二个参数是一个数组</li>
<li>bind()和call()类似，不通电在于bind()不会立即执行，而是返回了一个改变this后的函数；不同点二在于当你调用fn1 = fn.bind(newThis,param1)方法后，执行fn2(prama2)时，参数prama2会加到param1后面。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">'obj1'</span>,</span><br><span class="line">  fn1(param) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, param);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">'obj2'</span>,</span><br><span class="line">  fn1(param) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, param);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一般调用</span></span><br><span class="line">obj1.fn1(<span class="string">'param1'</span>)  <span class="comment">//输出 obj1 param1</span></span><br><span class="line"><span class="comment">//call的第一参数为调用该函数的对象时，等价于一般调用</span></span><br><span class="line">obj1.fn1.call(obj1, <span class="string">'param1'</span>)     <span class="comment">//输出 obj1 param1</span></span><br><span class="line"><span class="comment">//改变this指针，指向obj2</span></span><br><span class="line">obj1.fn1.call(obj2, <span class="string">'param1'</span>)     <span class="comment">//输出 obj2 param1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//apply的第二个参数为参数数组</span></span><br><span class="line">obj1.fn1.apply(obj2, [<span class="string">'param1'</span>])  <span class="comment">//输出 obj2 param1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bind方法返回一个函数,但不会执行，这个函数的参数继承bind方法的参数</span></span><br><span class="line"><span class="keyword">let</span> fun = obj1.fn1.bind(obj2, <span class="string">'param'</span>)</span><br><span class="line">fun()   <span class="comment">//输出 obj2 param1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>求数组中的最大最小值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">46</span>]</span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr) <span class="comment">// 46</span></span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, arr) <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">window</span>.Math.max(...arr)</span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">window</span>.Math.min(...arr)</span><br></pre></td></tr></table></figure>
<p>这里利用apply的第二个参数是接受一个数组，而在调用函数的时候会自动展开这个数组，而max和min方法接受参数的形式是(1,2,3,4)。</p>
<blockquote>
<p>将 arguments 等类数组转换为数组</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trueArr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">0</span>,<span class="built_in">arguments</span>.length)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 log 代替 console.log</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><p>普通函数的this是调用者；箭头函数的this是根据作用域的上下文确定的是，是不可以修改的。</p>
<ul>
<li>全局声明的函数，this指向的是window</li>
<li>对象里面的函数，this指向的是当前的对象，但是可以修改</li>
<li>构造函数的this，指向的是new出来的对象</li>
<li>箭头函数的this，是当前声明箭头函数的作用域this指向的是谁，this就是指向谁</li>
</ul>
<h3 id="—-typeof-与-instanceof-区别"><a href="#—-typeof-与-instanceof-区别" class="headerlink" title="— typeof 与 instanceof 区别"></a>— typeof 与 instanceof 区别</h3><p>typeof 和 instanceof 都是 JavaScript 中用来检测数据类型的运算符，但它们的作用不同。<br>1.typeof 运算符是用来检测一个变量或表达式的数据类型的。它返回一个字符串，表示该值的数据类型。</p>
<blockquote>
<p>基本数据类型可以用typeof检测出来，但null、数组、对象、函数的实例(new+函数),返回的都是object，无法检测到真实的数据类型，需要使用instanceof</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">123</span>);<span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'hello'</span>);<span class="comment">//输出 string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);<span class="comment">//输出 boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);<span class="comment">//输出 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;);<span class="comment">//输出 function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);<span class="comment">//输出 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> [<span class="number">123</span>]);<span class="comment">//输出 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123; <span class="attr">name</span>: <span class="string">'tom'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);<span class="comment">//输出 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>());<span class="comment">//输出 object</span></span><br></pre></td></tr></table></figure>
<p>2.instanceof<br>instanceof 运算符是用来判断一个对象是否属于某个类（构造函数）的实例。<br>instanceof 检查的是对象的原型链上是否有该类实例，只要原型链上有该类实例，就会返回true，否则为false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// 返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">date <span class="keyword">instanceof</span> <span class="built_in">Date</span> <span class="comment">// 返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/hello/</span>;</span><br><span class="line">reg <span class="keyword">instanceof</span> <span class="built_in">RegExp</span> <span class="comment">// 返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line"><span class="built_in">console</span>.log(dog <span class="keyword">instanceof</span> Dog);<span class="comment">//输出 true</span></span><br><span class="line"><span class="built_in">console</span>.log(dog <span class="keyword">instanceof</span> Person);<span class="comment">//输出 true</span></span><br><span class="line"><span class="built_in">console</span>.log(dog <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//输出 true</span></span><br><span class="line"><span class="comment">//执行顺序：dog--&gt;Person的实例--&gt;Object实例--&gt;Object原型</span></span><br><span class="line"><span class="comment">//Object是所有对象的原型，所以任何和对象和Object进行instanceof运算都会返回true</span></span><br><span class="line"><span class="keyword">let</span> b = &#123; <span class="attr">name</span>: <span class="string">'Bob'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Person);<span class="comment">//输出 false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，instanceof 运算符只能用来判断对象是否为该类的实例，不能用来判断基本数据类型的值。而且，如果要判断对象是否为某个类的实例，该类必须是通过构造函数定义的，不能是字面量对象或匿名函数等其他形式。</p>
</blockquote>
<p>3.typeof与instanceof总结：<br>①typeof与instanceof用来判断变量是否为空,或者属于什么数据类型<br>②typeof返回的是一个字符串,用来判断是什么数据类型<br>③instanceof返回的是一个布尔值,用来判断一个变量是否属于对象上的实例<br>④typeof检测的是简单数据类型,instanceof检测的是引用数据类型</p>
<h3 id="—-本地存储"><a href="#—-本地存储" class="headerlink" title="— 本地存储"></a>— 本地存储</h3><ul>
<li>cookie<br>存储数据大小为4K左右，客户端请求服务器。将cookie返给服务器，以此来判断用户的状态，可以设置过期时间，不可跨域访问</li>
<li>sessionStorage<br>存储数据大小为5M左右，在当前浏览器窗口关闭后自动删除，存储位置为当前域名的浏览器本地</li>
<li>localStorage<br>存储数据大小为5M左右，可以手动添加删除，不手动删除，会一直保存在当前域名的浏览器本地</li>
</ul>
<blockquote>
<p>标记用户与跟踪用户行为的情况，推荐使用cookie<br>适合长期保存在本地的数据（令牌），推荐使用localStorage<br>敏感账号一次性登录，推荐使用sessionStorage</p>
</blockquote>
<h3 id="—-深拷贝和浅拷贝"><a href="#—-深拷贝和浅拷贝" class="headerlink" title="— 深拷贝和浅拷贝"></a>— 深拷贝和浅拷贝</h3><p>浅拷贝指的是创建一个属性、值完全一样的变量，如果是基本类型，拷贝的就是基本类型，如果是引用类型那拷贝的就是一个内存对象，只是拷贝出了一个引用值，改变拷贝值，原值也会改变。<br>深拷贝完全是开辟了一个栈，两个引用类型出了属性、值一样，完全都是独立的，修改其中的一个，不会影响另一个的值。</p>
<ul>
<li>Object.assign</li>
<li>Array.prototype.slice()</li>
<li>Array.prototype.concat()</li>
<li>… 拓展符实现的复制</li>
</ul>
<p>以上方法都存在浅拷贝的现象</p>
<p>深拷贝的方法有：</p>
<ul>
<li>_cloneDeep() Lodash库的方法</li>
<li>jQuery.extend()</li>
<li>JSON.stringify()</li>
<li>循环递归</li>
</ul>
<h3 id="—-JSON是什么？"><a href="#—-JSON是什么？" class="headerlink" title="— JSON是什么？"></a>— JSON是什么？</h3><p>JSON是轻量级的文本数据格式，是一门独立的语言，是用js语法描述的数据对象，但独立于任何的语言，编程语言都支持JSON，具有自我描述性，更容易理解。</p>
<ul>
<li>json对象转化为json字符窜</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonStr = <span class="built_in">JSON</span>.stringify(jsonObj);</span><br></pre></td></tr></table></figure>
<ul>
<li>JSON字符串转化为JSON对象</li>
</ul>
<p>1). 使用eval()函数进行转换<br>使用 eval() 转换时需要在 json 字符外包裹一对小括号。</p>
<p>ie8(兼容模式)、ie7、ie6 不要使用此方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">eval</span>(<span class="string">'('</span> + jsonStr + <span class="string">')'</span>);</span><br></pre></td></tr></table></figure>
<p>2). 使用JSON.parse()方法进行转换<br>ie8(兼容模式)、ie7、ie6 不要使用此方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.parse(jsonStr);</span><br></pre></td></tr></table></figure>
<p>3). 使用jQuery进行转换<br>如果我们项目中有使用 jQuery，那么直接使用 $.parseJSON() 方法即可，而且可以确保各个浏览器的兼容性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = $.parseJSON(jsonStr);</span><br></pre></td></tr></table></figure>
<h3 id="—-闭包，使用场景"><a href="#—-闭包，使用场景" class="headerlink" title="— 闭包，使用场景"></a>— 闭包，使用场景</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>闭包是指一个函数中有权访问另一个函数中的变量，本质就是在函数A中返回另一个函数B，这时候B函数可以访问A函数中的变量，这样就形成了一个闭包，A函数中变量不会被销毁，并且这个变量只能通过B函数来访问。</p>
<h4 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h4><p>能够让函数执行后，其中的变量不会被销毁，同时能够让函数内的局部变量被访问。</p>
<h4 id="闭包带来的问题和如何规避"><a href="#闭包带来的问题和如何规避" class="headerlink" title="闭包带来的问题和如何规避"></a>闭包带来的问题和如何规避</h4><p>由于垃圾回收机制不能销毁闭包中的局部变量，从而导致内存泄漏，一旦闭包使用的太多，就会导致内存溢出，导致程序不安全和卡顿，所以必须手动设置闭包=null,让垃圾回收机制回收闭包中的变量。</p>
<h4 id="简单实现一个闭包"><a href="#简单实现一个闭包" class="headerlink" title="简单实现一个闭包"></a>简单实现一个闭包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = getA()</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4><ul>
<li>延长变量的生命周期</li>
<li>创建私有变量</li>
<li>闭包可以在函数外部访问到函数内部作用域的变量</li>
<li>闭包可以让访问变量不会被垃圾机制回收</li>
</ul>
<h4 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h4><ul>
<li><p>使用场景一:给对象设置私有变量并且利用特权方法去访问私有属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'tom'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> Fun(); </span><br><span class="line"><span class="built_in">console</span>.log(fun.name);<span class="comment">//输出undefined,在外部无法直接访问name</span></span><br><span class="line"><span class="built_in">console</span>.log(fun.getName());<span class="comment">//可以通过特定方法去访问</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>防抖节流</p>
</li>
</ul>
<h3 id="—-什么是防抖和节流？"><a href="#—-什么是防抖和节流？" class="headerlink" title="— 什么是防抖和节流？"></a>— 什么是防抖和节流？</h3><ul>
<li>防抖 n秒后在执行该事件，若在n秒之内被重复触发，则重新计时(单位时间内，频繁触发一个事件，以最后一次触发为准。)</li>
</ul>
<blockquote>
<p>简单点理解就是：<br>防抖是频繁执行某个事件的时候，就等事件停止之后的n秒后再执行相关的操作；<br>节流是频繁执行某个事件的时候，规定n秒执行一次回调（执行相关的操作），比如规定了1S执行一次，那就是如果用户某个按钮频繁点击了3S，那就执行相关操作（执行回调方法）3次。</p>
</blockquote>
<p>使用场景：<br>最典型的防抖函数应用场景就是搜索输入框了，用户输入之后需要自动发送网络请求获取数据，但是普通函数会频繁的触发事件，而用户的输入并没有完成，请求的结果也是无意义的，毫无疑问地给服务器造成了巨大地压力。<br>现在需要优化的关键点就是，如何使网络请求触发的不那么频繁，比如在用户输入停下一段时间后，这时，可能代表用户输入已经完毕，在这时才发送请求是最合适的。防抖函数就可以很好的做到这一点。<br>防抖函数的功能：如果在某个时间内反复触发的函数，那么它只会执行最后触发的那一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖动</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>fn 需要防抖执行的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>delay 多少毫秒不调用后执行一次,延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">fn, delay = <span class="number">500</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 存储定时器的timerId</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在每一次调用函数时，都清除上一次的定时器</span></span><br><span class="line">    <span class="keyword">if</span> (timer) clearTimeout(timer)</span><br><span class="line">    <span class="comment">// 开启一个定时器</span></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>节流 n秒内只运行一次，若在n秒内重复触发，只有一次生效(单位时间内，频繁触发一个事件，只会触发一次。)</li>
</ul>
<p>应用场景：假如有一个轮播图，轮播图以固定的频率播放图片，用户可以点击切换上一张或者下一张，如果用户点击过快，轮播图就会一直切换。这时候，应该控制轮播图切换的频率，在用户的持续点击下，只按照固定的频率切换。<br>节流函数的功能：连续的触发某个函数，只会以固定的频率去执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">**<span class="doctag">@param<span class="type">&#123;fn: function&#125;</span> </span>需要节流的函数</span></span><br><span class="line"><span class="comment">**<span class="doctag">@param<span class="type">&#123;interval: number&#125;</span> </span>函数触发的频率</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, interval</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 记录上一次触发函数时的时间，初始值为0</span></span><br><span class="line">  <span class="keyword">let</span> lastTime  = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取现在的时间</span></span><br><span class="line">    <span class="keyword">const</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    <span class="comment">// 如果现在的时间减去上次触发的事件大于等于interval，则可以执行函数了</span></span><br><span class="line">    <span class="keyword">if</span>(nowTime - lastTime &gt;= interval)&#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">      <span class="comment">// 将上次触发函数的时间赋值成当前时间</span></span><br><span class="line">      lastTime = nowTimes</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>fn 方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>delay 每隔多少毫秒执行一次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, delay</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="—-ajax的请求过程"><a href="#—-ajax的请求过程" class="headerlink" title="— ajax的请求过程"></a>— ajax的请求过程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax 提交 post 请求的数据</span></span><br><span class="line"><span class="comment">// 1. 创建核心对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 2. 准备建立连接</span></span><br><span class="line">xhr.open(<span class="string">"POST"</span>, <span class="string">"register.php"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 3. 发送请求</span></span><br><span class="line"><span class="comment">// 如果要POST提交数据，则需要设置请求头</span></span><br><span class="line"><span class="comment">// 有的面试官会问为什么要设置请求头？ 知道请求正文是以什么格式</span></span><br><span class="line"><span class="comment">// Content-Type: application/x-www-form-urlencoded，请求正文是类似 get 请求 url 的请求参数</span></span><br><span class="line"><span class="comment">// Content-Type: application/json，请求正文是一个 json 格式的字符串</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">xhr.send(querystring);</span><br><span class="line"><span class="comment">// 4. 处理响应</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123; <span class="comment">// 请求处理完毕，响应就绪</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123; <span class="comment">// 请求成功</span></span><br><span class="line">      <span class="keyword">var</span> data = xhr.responseText;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="—-ajax请求的时候get-和post方式的区别"><a href="#—-ajax请求的时候get-和post方式的区别" class="headerlink" title="— ajax请求的时候get 和post方式的区别"></a>— ajax请求的时候get 和post方式的区别</h3><ul>
<li>get请求，传递的参数是链接传递，有长度限制（IE 和 Safari 浏览器 限制 2k，Opera 限制4k，Firefox 限制 8k（非常老的版本 256byte）），post请求无限制</li>
<li>get请求参数在url后面传递，不安全，容易被窃取</li>
<li>post请求需要设置请求头</li>
</ul>
<h3 id="—-ajax、axios、jsonp的理解"><a href="#—-ajax、axios、jsonp的理解" class="headerlink" title="— ajax、axios、jsonp的理解"></a>— ajax、axios、jsonp的理解</h3><p>1、jsonp是一种可以解决跨域问题的方式，就是通过动态创建script标签用src引入外部文件实现跨域，script加载实际上就是一个get请求，并不能实现post请求。(其他实现跨域的方法有：iframe,window.name,postMessage,CORS…)<br>2、ajax是一种技术，ajax技术包含了get和post请求的，但是它仅仅是一种获取数据的技术，不能直接实现跨域，只有后台服务器配置好Access-Control-Allow-Origin，才可以实现请求的跨域。<br>3、axios是通过promise实现对ajax技术的一种封装，axios是ajax，ajax不止axios。</p>
<h3 id="—-什么是事件委托以及优缺点"><a href="#—-什么是事件委托以及优缺点" class="headerlink" title="— 什么是事件委托以及优缺点"></a>— 什么是事件委托以及优缺点</h3><p>js事件委托就是利用冒泡的原理，把本应该添加到某个元素上的事件委托给他的父级，从而减少DOM交互达到网页优化。</p>
<p>【优点】</p>
<p>1.可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错。<br>2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适</p>
<p>【缺点】</p>
<p>事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。</p>
<h3 id="—-如何解决数字精度丢失的问题"><a href="#—-如何解决数字精度丢失的问题" class="headerlink" title="— 如何解决数字精度丢失的问题?"></a>— 如何解决数字精度丢失的问题?</h3><p>理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果</p>
<p>当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="number">1.4000000000000001</span>.toPrecision(<span class="number">12</span>)) === <span class="number">1.4</span>  <span class="comment">// True</span></span><br></pre></td></tr></table></figure></p>
<p>封装成方法就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strip</span>(<span class="params">num, precision = <span class="number">12</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +<span class="built_in">parseFloat</span>(num.toPrecision(precision));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后还可以使用第三方库，如Math.js、BigDecimal.js</p>
<h3 id="—-原型，原型链-有什么特点？"><a href="#—-原型，原型链-有什么特点？" class="headerlink" title="— 原型，原型链 ? 有什么特点？"></a>— 原型，原型链 ? 有什么特点？</h3><p>JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象</p>
<p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</p>
<p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p>
<h3 id="—-如何实现上拉加载，下拉刷新？"><a href="#—-如何实现上拉加载，下拉刷新？" class="headerlink" title="— 如何实现上拉加载，下拉刷新？"></a>— 如何实现上拉加载，下拉刷新？</h3><p>开源社区有很多优秀的解决方案，如iscroll、better-scroll、pulltorefresh.js库等等</p>
<h3 id="—-说说你对作用域链的理解"><a href="#—-说说你对作用域链的理解" class="headerlink" title="— 说说你对作用域链的理解"></a>— 说说你对作用域链的理解</h3><p>1、作用域就是变量与函数的可访问范围<br>2、一般情况下，变量取值到创建这个变量的函数的作用域中取值。 但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链</p>
<h3 id="—-浏览器输入Url之后发生了什么？"><a href="#—-浏览器输入Url之后发生了什么？" class="headerlink" title="— 浏览器输入Url之后发生了什么？"></a>— 浏览器输入Url之后发生了什么？</h3><p>浏览器输入URL链接 -&gt; 回车 -&gt; 浏览器查找当前URL是否有本地缓存 -&gt; dns解析URL对应的IP -&gt; 根据IP三次握手TCP -&gt; 发起http请求 -&gt; 服务器处理请求 -&gt;  关闭四次握手 -&gt; 浏览器根据发回的response响应，启用浏览器的渲染引擎和JS引擎，更具HTML/CSS/JS/IMG等等渲染页面。</p>
<p>1.浏览器解析html源码，创建dom树，在dom树中，每个html标签都有一个节点，每个文本都有一个节点，dom数的根节点是html标签<br>2.浏览器解析css，计算出最终的样式，对css中非法的代码过滤掉，根据优先级计算最终的渲染树<br>3.根据生成的dom树和cssom，调用GPU，合成图层，显示在屏幕上。</p>
<h2 id="vue相关"><a href="#vue相关" class="headerlink" title="vue相关"></a>vue相关</h2><h3 id="什么是mvvm"><a href="#什么是mvvm" class="headerlink" title="什么是mvvm?"></a>什么是mvvm?</h3><p>modal + view + viewModal的缩写，是modal驱动view的渐进式框架，不需要直接操作dom来实现页面的改变。</p>
<h3 id="为什么使用虚拟dom"><a href="#为什么使用虚拟dom" class="headerlink" title="为什么使用虚拟dom"></a>为什么使用虚拟dom</h3><ul>
<li>创建真实DOM的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。</li>
<li>触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，以减少浏览器的重绘及回流。</li>
<li>虚拟dom由于本质是一个js对象，因此天生具备跨平台的能力，可以实现在不同平台的准确显示。</li>
<li>Virtual DOM 在性能上的收益并不是最主要的，更重要的是它使得 Vue 具备了现代框架应有的高级特性。</li>
</ul>
<h3 id="Vue中key是用来做什么的？为什么不推介使用index作为key？"><a href="#Vue中key是用来做什么的？为什么不推介使用index作为key？" class="headerlink" title="Vue中key是用来做什么的？为什么不推介使用index作为key？"></a>Vue中key是用来做什么的？为什么不推介使用index作为key？</h3><p>1、key的作用主要是为了高效的更新虚拟DOM（使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素）</p>
<p>2、当以数组的下标index作为index值时，其中一个元素（如增删改查）发生了变化就有可能导致所有元素的key值发生变化</p>
<h3 id="v-show和v-if的区别"><a href="#v-show和v-if的区别" class="headerlink" title="v-show和v-if的区别"></a>v-show和v-if的区别</h3><p>v-show原理是修改元素的css属性display:none来决定是显示还是隐藏</p>
<p>v-if则是通过操作DOM来进行切换显示</p>
<h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p>实现mvvm的双向绑定，是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<h3 id="生命周期函数有哪些"><a href="#生命周期函数有哪些" class="headerlink" title="生命周期函数有哪些"></a>生命周期函数有哪些</h3><ul>
<li>beforeCreate 实例刚在内存中被创建出来，此时还没有初始化好data和methods属性</li>
<li>created 实例已经在内存中创建出来，此时的data和methods以及创建完成，但是还没有开始编译模板</li>
<li>beforeMount 此时已经完成了模板的编译，但是还没有挂载到页面上</li>
<li>mounted 已经将编译好的模板，挂载到了页面指定的容器中显示</li>
<li>beforeUpdate 状态更新之前执行此函数，此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始重新渲染DOM节点</li>
<li>updated 实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了</li>
<li>beforeDestory 实例销毁之前调用，在这一步，实例仍然完全可用</li>
<li>destoryed Vue实例销毁之后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁</li>
</ul>
<h3 id="常用的指令？常用的内置组件有哪些？"><a href="#常用的指令？常用的内置组件有哪些？" class="headerlink" title="常用的指令？常用的内置组件有哪些？"></a>常用的指令？常用的内置组件有哪些？</h3><p>常用指令：<br>v-html v-text v-modal v-if v-show v-hide v-once v-on v-for</p>
<p>常用内置组件<br>transition 动画<br>keepAlive 多个组件动态切换时缓存被移除的组件实例</p>
<h3 id="vue自定义指令设置"><a href="#vue自定义指令设置" class="headerlink" title="vue自定义指令设置"></a>vue自定义指令设置</h3><ul>
<li>全局: Vue.directive(‘指令名称，不需要写v-开头’,对象或函数)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'test'</span>,&#123;</span><br><span class="line">	bind(el,bind)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(el)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.directive(<span class="string">'red'</span>, &#123;</span><br><span class="line">    <span class="comment">// bind 第一次绑定到元素时调用</span></span><br><span class="line">    bind(el, bindings) &#123;</span><br><span class="line">        el.style.cssText = <span class="string">`color:red;font-size:30px`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>私有<br>在组件中的</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	directives: &#123;</span><br><span class="line">		test:&#123;</span><br><span class="line">			bind(el,bind)&#123;&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">// bind/update</span></span><br><span class="line">		test2(el,bind)&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义局部指令，只有当前的实例能用</span></span><br><span class="line">directives: &#123;</span><br><span class="line">    red: &#123;</span><br><span class="line">        <span class="comment">// bind它还没有绑定到父元素中,初始化</span></span><br><span class="line">        bind(el) &#123;</span><br><span class="line">            el.style.cssText = <span class="string">`color:red;font-size:30px`</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="父子组件之间的通信"><a href="#父子组件之间的通信" class="headerlink" title="父子组件之间的通信"></a>父子组件之间的通信</h3><p>父传子：通过props来传递<br>父组件(:变量名) -&gt; 子组件([props])来接收<br>子传父：$emit/$on<br>子组件($emit(‘事件名’，值)) -&gt; 父组件(@事件名=’aa’,aa(传递的值))来接收<br>兄弟组件：创建一个事件中心 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Hub = <span class="keyword">new</span> Vue()</span><br><span class="line">Hub.$emit(<span class="string">'change'</span>, 值) <span class="comment">// Hub触发事件</span></span><br><span class="line">Hub.$on(<span class="string">'change'</span>, ()=&gt;&#123;</span><br><span class="line">  <span class="comment">// Hub接收事件</span></span><br><span class="line">  <span class="keyword">this</span>.msg = 值</span><br><span class="line">&#125;)</span><br><span class="line">通过Hub.$off()方法名销毁之后无法进行传递数据</span><br></pre></td></tr></table></figure>
<p>详细介绍：<a href="http://shuy.cc/2019/04/27/jc-6/" target="_blank" rel="noopener">http://shuy.cc/2019/04/27/jc-6/</a></p>
<h3 id="路由跳转的方式，传参方式有哪些？"><a href="#路由跳转的方式，传参方式有哪些？" class="headerlink" title="路由跳转的方式，传参方式有哪些？"></a>路由跳转的方式，传参方式有哪些？</h3><p>1). 标签<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">"&#123;name: '路由名'&#125;"</span></span><br></pre></td></tr></table></figure></p>
<p>2). 动态路由<br>App.vue</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">"'/user/' + userId"</span>&gt;用户&lt;<span class="regexp">/router-link&gt;</span></span><br></pre></td></tr></table></figure>
<p>router.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">path</span>: <span class="string">'/user/:userId'</span>&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">"&#123;name: 'users', params: &#123;id: 12&#125;&#125;"</span>&gt;用户&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">this.$route.push(&#123;name: 'users', params: &#123;id: 12&#125;&#125;)</span></span><br><span class="line"><span class="regexp">this.$route.push('/u</span>ser/<span class="number">12</span><span class="string">')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 获取：$route.params.id</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">"&#123;path: '/profile', query: &#123;id: 12&#125;&#125;"</span>&gt;档案&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;router-link :to="&#123;name: '/u</span>sers<span class="string">', query: &#123;id: 12&#125;&#125;"&gt;档案&lt;/router-link&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">aa() &#123;</span></span><br><span class="line"><span class="string">  this.$router.push(&#123;</span></span><br><span class="line"><span class="string">    path: '</span>/profile<span class="string">',</span></span><br><span class="line"><span class="string">    query: &#123;</span></span><br><span class="line"><span class="string">      name: '</span>yaoyao<span class="string">',</span></span><br><span class="line"><span class="string">      id: 12</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 获取：$route.query.id</span></span><br></pre></td></tr></table></figure>
<h3 id="router-和-route的区别"><a href="#router-和-route的区别" class="headerlink" title="router 和 route的区别"></a>router 和 route的区别</h3><ul>
<li>$route对象<br>表示当前的所有的路由信息，包括路径，参数，query对象等</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'../views/layout/Layout'</span></span><br><span class="line"><span class="keyword">const</span> asyncRoutes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/product-define'</span>,</span><br><span class="line">    component: Layout,</span><br><span class="line">    redirect: <span class="string">'/product-define/'</span>,</span><br><span class="line">    name: <span class="string">'ProductDefineManagement'</span>,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: <span class="string">'产品定义定价'</span>,</span><br><span class="line">      icon: <span class="string">'icon-dingyidingjia'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'CarType'</span>,</span><br><span class="line">        name: <span class="string">'CarType'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/product_define/CarType'</span>),</span><br><span class="line">        meta: &#123; <span class="attr">title</span>: <span class="string">'车型'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>$route.path 路径<br>  $route.params 一个key: val对象<br>  $route.query 一个key: val对象<br>  $route.hash #号后面的数据<br>  $route.fullPath url，包含参数和hash完整路径<br>  $route.matched 数组，常用作面包屑<br>  $route.name 当前路由的名称<br>  $route.meta 路由元信息，一些额外标注参数</p>
</blockquote>
<ul>
<li>$router对象：是全局的路由实例。</li>
</ul>
<h3 id="编程式导航的使用方法"><a href="#编程式导航的使用方法" class="headerlink" title="编程式导航的使用方法"></a>编程式导航的使用方法</h3><p>1.路由的跳转<br>this.$router.push()<br>2.路由替换<br>this.$router.replace()<br>3.后退<br>this$router.back()<br>4.前进<br>this.$router.forward()<br>5.前进后退<br>this.$router.go() -1为后退<br>6.配置路由常用参数</p>
<ul>
<li>path 路径</li>
<li>component 路由相对于组件的路径</li>
<li>name 路由的名称</li>
<li>children 嵌套路由的子组件的配置项 </li>
<li>props 路由解耦</li>
<li>redirect 路由重定向</li>
</ul>
<h3 id="什么是路由守卫？路由的钩子函数有哪些？"><a href="#什么是路由守卫？路由的钩子函数有哪些？" class="headerlink" title="什么是路由守卫？路由的钩子函数有哪些？"></a>什么是路由守卫？路由的钩子函数有哪些？</h3><p>路由守卫：路由跳转前后的一些验证<br>路由钩子函数：</p>
<ul>
<li>beforeRouterEnter 当路由跳转之前（登录之前）</li>
<li>beforeRouterUpdate 当路由进行更新的时候，如果当前路由发生了变化，但是不需要组件进行销毁</li>
<li>beforeRouterLeave 当路由离开的时候（当用户没有支付离开的时候、当用户填写完用户信息没有保存的时候）</li>
<li>beforeEach 全局守卫，验证用户是否登录 </li>
</ul>
<h3 id="vuex的理解"><a href="#vuex的理解" class="headerlink" title="vuex的理解"></a>vuex的理解</h3><p>vuex是专门为vue开发的一款状态管理库，主要采用集中管理应用所有的组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<ul>
<li>state 保存应用的全部状态的对象 this.$store.state(key)</li>
<li>Getter 其实就是state通过计算属性，衍变出的新的状态 this.$store.getters(key)</li>
<li>Mutation 包含一个字符窜名称和回调函数，必须是同步函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  name(state) &#123;</span><br><span class="line">    state.count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>它其实就是操作state的，它不能直接调用，这更像是一个事件注册，需要 store.commit(‘name’)来调用对应的mutation</p>
</blockquote>
<ul>
<li>action 类似于mutation,但是action提交的数mutation，并且是异步的，使用commit(‘mutation名’)来调用，action使用dispatch来调用</li>
</ul>
<blockquote>
<p>在main.js引入store，注入。新建了一个store目录，然后….. export 。 场景：单页应用中，组件之间的共享状态和方法 state Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。 mutations mutations定义的方法动态修改Vuex 的 store 中的状态或数据。 getters 类似vue的计算属性，主要用来过滤一些数据。 action actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。 modules 项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。</p>
</blockquote>
<p>快速掌握vuex常用的所有api用法: <a href="http://shuy.cc/2019/07/24/vuex/" target="_blank" rel="noopener">http://shuy.cc/2019/07/24/vuex/</a></p>
<h2 id="小程序相关"><a href="#小程序相关" class="headerlink" title="小程序相关"></a>小程序相关</h2><h3 id="生命周期函数有哪些？小程序的周期函数？"><a href="#生命周期函数有哪些？小程序的周期函数？" class="headerlink" title="生命周期函数有哪些？小程序的周期函数？"></a>生命周期函数有哪些？小程序的周期函数？</h3><p>生命周期函数：<br>onLoad<br>onUnLoad<br>onShow<br>onHide<br>onReady<br>小程序周期函数：<br>onLaunch<br>onShow<br>onError</p>
<h3 id="应用与页面生命周期发生顺序"><a href="#应用与页面生命周期发生顺序" class="headerlink" title="应用与页面生命周期发生顺序"></a>应用与页面生命周期发生顺序</h3><p>应用onLaunch -&gt; 应用onShow -&gt; 页面page -&gt; onLoad -&gt; onShow -&gt; onReady</p>
<h3 id="小程序是如何传值？"><a href="#小程序是如何传值？" class="headerlink" title="小程序是如何传值？"></a>小程序是如何传值？</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindTap</span>=<span class="string">"get"</span> <span class="attr">id</span>=<span class="string">'123'</span> <span class="attr">data-name</span>=<span class="string">"按钮名"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>(e) &#123;</span><br><span class="line">  <span class="keyword">let</span> id = e.currentTarget.id</span><br><span class="line">  <span class="keyword">let</span> name = e.currentTarget.dataset.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="wxss和css的区别"><a href="#wxss和css的区别" class="headerlink" title="wxss和css的区别"></a>wxss和css的区别</h3><ul>
<li>wxss背景图只能引入外联，不能使用本地图片</li>
<li>小程序使用@important引入外链样式，地址为相对路径</li>
<li>单位为rpx，是响应式像素，可根据屏幕宽度做自适应</li>
</ul>
<h3 id="小程序是如何传递数据？"><a href="#小程序是如何传递数据？" class="headerlink" title="小程序是如何传递数据？"></a>小程序是如何传递数据？</h3><ul>
<li>在app.js中，this.globalData={}中存放数据，在组件.js中，头部引入const app = getApp(),来获取全局变量，直接使用app.globalData.key来获取变量</li>
<li>使用路由，wx.navigation/redircetTo/url+参数等方式，在页面onLoad(e),通过e来获取参数</li>
<li>本地缓存，如storage等存储数据</li>
</ul>
<h3 id="webview的理解"><a href="#webview的理解" class="headerlink" title="webview的理解"></a>webview的理解</h3><p>在小程序中嵌套H5页面，域名必须在白名单里面</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1.rpx，规定屏幕宽度为750rpx，可适配不同的屏幕宽度<br>2.本地资源wxss无法获取，bgimg可使用网络图片，base64,或者使用标签来引入<br>3.navigateTo，一个应用同时能发开5个页面或者使用redirct</p>
<h3 id="小程序的双向绑定和vue的有什么区别"><a href="#小程序的双向绑定和vue的有什么区别" class="headerlink" title="小程序的双向绑定和vue的有什么区别"></a>小程序的双向绑定和vue的有什么区别</h3><p>小程序必须使用this.setState({key:val})来更新数据，直接赋值不能更新页面变化</p>
<h3 id="下拉刷新的实现方法"><a href="#下拉刷新的实现方法" class="headerlink" title="下拉刷新的实现方法"></a>下拉刷新的实现方法</h3><p>app.json中，将’enablePullDownFresh’: true,开启全局下拉刷新，组件.json中，将’enablePullDownFresh’: true,开启单页下拉刷新，组件中的onPullDownRefresh写加载的逻辑，wx.stopPullDownRefresh()更新完数据，停止更新。</p>
<h3 id="跳转的方式有哪些"><a href="#跳转的方式有哪些" class="headerlink" title="跳转的方式有哪些"></a>跳转的方式有哪些</h3><ul>
<li>wx.navigateTo() 保留当前页，跳转到应用指定页面，不能跳转tabar页面</li>
<li>wx.redircetTo() 关闭当前页，跳转到应用指定页面，不能跳转tabar页面</li>
<li>wx.switchTo() 跳转到tabbar页面，关闭其他非tabar页面</li>
<li>wx.navigateBack() 关闭当前页，返回上一级或多级页面，可通过getCurrentPages()获取当前的页面栈，决定要返回第几层</li>
<li>wx.relaunch() 关闭所有页，打开到应用内的某个页面（应用场景：登陆跳转到其他页面）</li>
</ul>
<h3 id="描述一下小程序的登陆流程"><a href="#描述一下小程序的登陆流程" class="headerlink" title="描述一下小程序的登陆流程"></a>描述一下小程序的登陆流程</h3><p>点击登陆按钮 -&gt; 调用微信登陆程序接口wx.login,获取code(有效期5分钟) -&gt; 后台使用code、appid,appSercrent获取openid、session-key,然后生成token返回给前端 -&gt; 前端保存token，便于之后的业务请求</p>
<h3 id="wx-if和hidden的区别，如何使用？"><a href="#wx-if和hidden的区别，如何使用？" class="headerlink" title="wx:if和hidden的区别，如何使用？"></a>wx:if和hidden的区别，如何使用？</h3><p>wx:if 有更高的切换消耗<br>hidden 有更高的初始渲染消耗<br>页面数据切换使用hidden,运行条件变化使用wx:if</p>
<h3 id="app-json的配置项"><a href="#app-json的配置项" class="headerlink" title="app.json的配置项"></a>app.json的配置项</h3><p>pages 存放小程序所有pages的路径<br>window 小程序所有页面的顶部、背景颜色，文字tabbar等的设置<br>tabBar 设置底部导航，最多5个，最少2个</p>

        
    </section>
</article>





<div class="comments">
    <div id="comments"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
    new Gitalk({
        clientID: "7fbe80427f54741e289f",
        clientSecret: "f34ed5fd92e54c9000bd37ba951948cb939deff5",
        repo: "sanonz.github.io",
        owner: "sanonz",
        admin: ["sanonz"],
        id: "2022/05/05/mianshi",
        distractionFreeMode: true,
        title: "常用知识总结",
        body: "http://www.shuy.cc/2022/05/05/mianshi/",
        labels: ["css js vue"]
    }).render('comments');
    </script>
</div>


        </div>
        <footer class="footer">
    Copyright © Aaron All Rights Reserved 京ICP备17007771号-1
</footer>

    </main>

    <script type="text/javascript" src="https://unpkg.com/jquery@1.9.1/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }

            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle('normal', slideDone);
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp('normal', slideDone);
            }, 3000);
        }

        function slideDone() {
            if (nodes.navInner.css('display') !== 'none') {
                nodes.navInner.css('display', '');
            }
        }

        $(window).on('resize', function() {
            console.log($(this).width())
            if ($(this).width() > 960) {
                nodes.navInner.css('display', '');
            }
        });
    });
    </script>
    
        <script src="/js/scrollspy.min.js"></script>
        <script type="text/javascript">
        $(document.body).scrollspy({target: '#aside-inner'});

        $(window).on('resize', function() {
            var hw = $('#header').width();
            var ww = $('#wrapper').width();
            var space = ($(this).width() - hw - ww) / 2 / 2;

            var pageprev = $('#pageprev');
            var pagenext = $('#pagenext');
            var avg = (pageprev.width() + pagenext.width()) / 2

            if(space > avg) {
                var len = space - avg / 2;
                // var styles = {position: 'fixed', top: '50%', marginTop: - (pageprev.width() + pagenext.width()) / 4}
                // pageprev.css($.extend({left: hw + len}, styles));
                // pagenext.css($.extend({right: len}, styles));
            } else {
                pageprev.removeAttr('style');
                // pagenext.removeAttr('style');
            }
        }).trigger('resize');
        </script>
    

</body>
</html>
