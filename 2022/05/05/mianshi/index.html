<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>常用知识总结 | 前端技术博客</title>
    <meta name="author" content="xiaosongread">
    <meta name="keywords" content="小宋 抿圪斗前端 前端 前端博客 框架 工程 css html js node markdown npm webpack">
    <meta name="description" content="– html/css— css 的布局方式1.table 布局2.flex 布局3.float 布局4.响应式布局— 盒子模型IE 盒子模型：宽高包括 content + padding + bording; box-sizing: border-box标准盒模型：宽高就是元素的实际宽高 content; box-sizing: content-box什么是 BFC？bfc 就是 Block formatting contexts，块级格式化上下文一个独立的渲染区域，有这自己的渲染规...">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="前端技术博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <style type="text/css">
    @font-face {
        font-family: 'icomoon';
        src: url("/fonts/icomoon.eot?q628ml");
        src: url("/fonts/icomoon.eot?q628ml#iefix") format('embedded-opentype'),
             url("/fonts/icomoon.ttf?q628ml") format('truetype'),
             url("/fonts/icomoon.woff?q628ml") format('woff'),
             url("/fonts/icomoon.svg?q628ml#icomoon") format('svg');
        font-weight: normal;
        font-style: normal;
    }
    </style>
    <link rel="stylesheet" href="/css/style.css">

    <!--[if lt IE 9]><style type="text/css">.nav-inner {top:0;}.author-meta {position:static;top:0;}.search-form {height:36px;}</style><script type="text/javascript" src="https://unpkg.com/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
</head>
<body>

    <main class="app">
        <header id="header" class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">前端技术博客</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">列表</span>
            </a>
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/categories/css-end/">
                <span class="nav-text">css</span>
            </a>
        
            <a class="nav-item" href="/categories/js-end/">
                <span class="nav-text">js</span>
            </a>
        
            <a class="nav-item" href="/categories/gc-end/">
                <span class="nav-text">工程</span>
            </a>
        
            <a class="nav-item" href="/categories/sh-end/">
                <span class="nav-text">日常</span>
            </a>
        
            <a class="nav-item" href="/categories/jq-end/">
                <span class="nav-text">每日技巧</span>
            </a>
        
            <a class="nav-item" href="/categories/my-end/">
                <span class="nav-text">关于我</span>
            </a>
        
    </nav>
</div>

    
<aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#–-html-css"><span class="toc-number">1.</span> <span class="toc-text">– html/css</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#—-css-的布局方式"><span class="toc-number">1.1.</span> <span class="toc-text">— css 的布局方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-盒子模型"><span class="toc-number">1.2.</span> <span class="toc-text">— 盒子模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-BFC？"><span class="toc-number">1.3.</span> <span class="toc-text">什么是 BFC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-HTML5-新增元素"><span class="toc-number">1.4.</span> <span class="toc-text">— HTML5 新增元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-居中的方式"><span class="toc-number">1.5.</span> <span class="toc-text">— 居中的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-有哪些方式可以影藏页面元素？区别是什么？"><span class="toc-number">1.6.</span> <span class="toc-text">— 有哪些方式可以影藏页面元素？区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-css-选择器有哪些？优先级"><span class="toc-number">1.7.</span> <span class="toc-text">— css 选择器有哪些？优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-清除浮动的方法"><span class="toc-number">1.8.</span> <span class="toc-text">— 清除浮动的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-常见的行内元素、块级元素"><span class="toc-number">1.9.</span> <span class="toc-text">— 常见的行内元素、块级元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-position-的属性"><span class="toc-number">1.10.</span> <span class="toc-text">— position 的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-SEO"><span class="toc-number">1.11.</span> <span class="toc-text">— SEO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-什么是响应式布局？"><span class="toc-number">1.12.</span> <span class="toc-text">— 什么是响应式布局？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-flex"><span class="toc-number">1.13.</span> <span class="toc-text">— flex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-rem、em、vh、px-各自代表的含义？"><span class="toc-number">1.14.</span> <span class="toc-text">— rem、em、vh、px 各自代表的含义？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#H5-移动端适配原理"><span class="toc-number">1.15.</span> <span class="toc-text">- H5 移动端适配原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#javascript"><span class="toc-number">2.</span> <span class="toc-text">javascript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#—-js-中的数据类型"><span class="toc-number">2.1.</span> <span class="toc-text">— js 中的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-var-let-const-的区别？"><span class="toc-number">2.2.</span> <span class="toc-text">— var/let/const 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-ES6-标准入门"><span class="toc-number">2.3.</span> <span class="toc-text">— ES6 标准入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-数组常用的方法"><span class="toc-number">2.4.</span> <span class="toc-text">— 数组常用的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-number">2.4.1.</span> <span class="toc-text">增删改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-number">2.4.2.</span> <span class="toc-text">查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-number">2.4.3.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组转字符窜"><span class="toc-number">2.4.4.</span> <span class="toc-text">数组转字符窜</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代"><span class="toc-number">2.4.5.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#去重"><span class="toc-number">2.4.6.</span> <span class="toc-text">去重</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-call-apply-bind-的区别？"><span class="toc-number">2.5.</span> <span class="toc-text">— call/apply/bind 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#箭头函数和普通函数的区别"><span class="toc-number">2.6.</span> <span class="toc-text">箭头函数和普通函数的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#普通函数"><span class="toc-number">2.6.1.</span> <span class="toc-text">普通函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#箭头函数"><span class="toc-number">2.6.2.</span> <span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#强制改变-this-指向"><span class="toc-number">2.6.3.</span> <span class="toc-text">强制改变 this 指向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">2.6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-typeof-与-instanceof-区别"><span class="toc-number">2.7.</span> <span class="toc-text">— typeof 与 instanceof 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-本地存储"><span class="toc-number">2.8.</span> <span class="toc-text">— 本地存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-深拷贝和浅拷贝"><span class="toc-number">2.9.</span> <span class="toc-text">— 深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-JSON-是什么？"><span class="toc-number">2.10.</span> <span class="toc-text">— JSON 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-闭包，使用场景"><span class="toc-number">2.11.</span> <span class="toc-text">— 闭包，使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概念"><span class="toc-number">2.11.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决的问题"><span class="toc-number">2.11.2.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包带来的问题和如何规避"><span class="toc-number">2.11.3.</span> <span class="toc-text">闭包带来的问题和如何规避</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简单实现一个闭包"><span class="toc-number">2.11.4.</span> <span class="toc-text">简单实现一个闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包的作用"><span class="toc-number">2.11.5.</span> <span class="toc-text">闭包的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包的应用场景"><span class="toc-number">2.11.6.</span> <span class="toc-text">闭包的应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-什么是防抖和节流？"><span class="toc-number">2.12.</span> <span class="toc-text">— 什么是防抖和节流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-ajax-的请求过程"><span class="toc-number">2.13.</span> <span class="toc-text">— ajax 的请求过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-ajax-请求的时候-get-和-post-方式的区别"><span class="toc-number">2.14.</span> <span class="toc-text">— ajax 请求的时候 get 和 post 方式的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-ajax、axios、jsonp-的理解"><span class="toc-number">2.15.</span> <span class="toc-text">— ajax、axios、jsonp 的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-什么是事件委托以及优缺点"><span class="toc-number">2.16.</span> <span class="toc-text">— 什么是事件委托以及优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-如何解决数字精度丢失的问题"><span class="toc-number">2.17.</span> <span class="toc-text">— 如何解决数字精度丢失的问题?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-原型，原型链-有什么特点？"><span class="toc-number">2.18.</span> <span class="toc-text">— 原型，原型链 ? 有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-如何实现上拉加载，下拉刷新？"><span class="toc-number">2.19.</span> <span class="toc-text">— 如何实现上拉加载，下拉刷新？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-说说你对作用域链的理解"><span class="toc-number">2.20.</span> <span class="toc-text">— 说说你对作用域链的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-浏览器输入-Url-之后发生了什么？"><span class="toc-number">2.21.</span> <span class="toc-text">— 浏览器输入 Url 之后发生了什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#从输入-URL-到页面加载的主干流程如下："><span class="toc-number">2.21.1.</span> <span class="toc-text">从输入 URL 到页面加载的主干流程如下：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-首先在浏览器中输入-URL"><span class="toc-number">2.21.1.1.</span> <span class="toc-text">1.首先在浏览器中输入 URL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-DNS-域名解析"><span class="toc-number">2.21.1.2.</span> <span class="toc-text">2.DNS 域名解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-建立-TCP-连接：-解析出-IP-地址后，根据-IP-地址和默认-80-端口，和服务器建立-TCP-连接"><span class="toc-number">2.21.1.3.</span> <span class="toc-text">3.建立 TCP 连接： 解析出 IP 地址后，根据 IP 地址和默认 80 端口，和服务器建立 TCP 连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#谈谈你对-promise、axios-的理解"><span class="toc-number">2.22.</span> <span class="toc-text">谈谈你对 promise、axios 的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack-构建优化怎么搞？"><span class="toc-number">2.23.</span> <span class="toc-text">webpack 构建优化怎么搞？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-状态码"><span class="toc-number">2.24.</span> <span class="toc-text">http 状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#状态码分类"><span class="toc-number">2.24.1.</span> <span class="toc-text">状态码分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#完整状态码"><span class="toc-number">2.24.2.</span> <span class="toc-text">完整状态码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git-常用的命令行"><span class="toc-number">2.25.</span> <span class="toc-text">git 常用的命令行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-相关"><span class="toc-number">3.</span> <span class="toc-text">vue 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-mvvm"><span class="toc-number">3.1.</span> <span class="toc-text">什么是 mvvm?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么-Vue-里面的是-data-是函数？"><span class="toc-number">3.2.</span> <span class="toc-text">为什么 Vue 里面的是 data 是函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#怎样理解-Vue-的单向数据流？"><span class="toc-number">3.3.</span> <span class="toc-text">怎样理解 Vue 的单向数据流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-是如何实现数据双向绑定的？"><span class="toc-number">3.4.</span> <span class="toc-text">Vue 是如何实现数据双向绑定的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-框架怎么实现对象和数组的监听？"><span class="toc-number">3.5.</span> <span class="toc-text">Vue 框架怎么实现对象和数组的监听？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy-与-Object-defineProperty-优劣对比"><span class="toc-number">3.6.</span> <span class="toc-text">Proxy 与 Object.defineProperty 优劣对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？"><span class="toc-number">3.7.</span> <span class="toc-text">Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生命周期函数有哪些"><span class="toc-number">3.8.</span> <span class="toc-text">生命周期函数有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用虚拟-dom"><span class="toc-number">3.9.</span> <span class="toc-text">为什么使用虚拟 dom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-中-key-是用来做什么的？为什么不推介使用-index-作为-key？"><span class="toc-number">3.10.</span> <span class="toc-text">Vue 中 key 是用来做什么的？为什么不推介使用 index 作为 key？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#当我们没有设置-key-值的情况"><span class="toc-number">3.10.1.</span> <span class="toc-text">当我们没有设置 key 值的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如果设置了-key，且-key-值固定的情况"><span class="toc-number">3.10.2.</span> <span class="toc-text">如果设置了 key，且 key 值固定的情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-show-和-v-if-的区别"><span class="toc-number">3.11.</span> <span class="toc-text">v-show 和 v-if 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的指令？常用的内置组件有哪些？"><span class="toc-number">3.12.</span> <span class="toc-text">常用的指令？常用的内置组件有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-修饰符有哪些"><span class="toc-number">3.13.</span> <span class="toc-text">Vue 修饰符有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computed-和-watch-的区别"><span class="toc-number">3.14.</span> <span class="toc-text">computed 和 watch 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#computed"><span class="toc-number">3.14.1.</span> <span class="toc-text">computed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#watch"><span class="toc-number">3.14.2.</span> <span class="toc-text">watch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-if-与-v-for-为什么不建议一起使用"><span class="toc-number">3.15.</span> <span class="toc-text">v-if 与 v-for 为什么不建议一起使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-model-原理"><span class="toc-number">3.16.</span> <span class="toc-text">v-model 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-自定义指令设置"><span class="toc-number">3.17.</span> <span class="toc-text">vue 自定义指令设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-mixin-的使用场景和原理"><span class="toc-number">3.18.</span> <span class="toc-text">Vue.mixin 的使用场景和原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nextTick-使用场景和原理"><span class="toc-number">3.19.</span> <span class="toc-text">nextTick 使用场景和原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-set-方法原理"><span class="toc-number">3.20.</span> <span class="toc-text">Vue.set 方法原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#父子组件之间的通信"><span class="toc-number">3.21.</span> <span class="toc-text">父子组件之间的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路由跳转的方式，传参方式有哪些？"><span class="toc-number">3.22.</span> <span class="toc-text">路由跳转的方式，传参方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#router-和-route-的区别"><span class="toc-number">3.23.</span> <span class="toc-text">router 和 route 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编程式导航的使用方法"><span class="toc-number">3.24.</span> <span class="toc-text">编程式导航的使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是路由守卫？路由的钩子函数有哪些？"><span class="toc-number">3.25.</span> <span class="toc-text">什么是路由守卫？路由的钩子函数有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-router-路由钩子函数是什么-执行顺序是什么"><span class="toc-number">3.26.</span> <span class="toc-text">vue-router 路由钩子函数是什么 执行顺序是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#能说下-vue-router-中常用的路由模式实现原理吗"><span class="toc-number">3.27.</span> <span class="toc-text">能说下 vue-router 中常用的路由模式实现原理吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vuex-的理解"><span class="toc-number">3.28.</span> <span class="toc-text">vuex 的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex-页面刷新数据丢失怎么解决"><span class="toc-number">3.29.</span> <span class="toc-text">Vuex 页面刷新数据丢失怎么解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex-为什么要分模块并且加命名空间"><span class="toc-number">3.30.</span> <span class="toc-text">Vuex 为什么要分模块并且加命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#你有对-Vue-项目进行哪些优化？"><span class="toc-number">3.31.</span> <span class="toc-text">你有对 Vue 项目进行哪些优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用过-Vue-SSR-吗？说说-SSR"><span class="toc-number">3.32.</span> <span class="toc-text">使用过 Vue SSR 吗？说说 SSR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#登陆权限的实现"><span class="toc-number">3.33.</span> <span class="toc-text">登陆权限的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#登陆"><span class="toc-number">3.33.1.</span> <span class="toc-text">登陆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#权限"><span class="toc-number">3.33.2.</span> <span class="toc-text">权限</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue2-0-和-vue3-0-的区别"><span class="toc-number">3.34.</span> <span class="toc-text">vue2.0 和 vue3.0 的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小程序相关"><span class="toc-number">4.</span> <span class="toc-text">小程序相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#微信的小程序的主要文件"><span class="toc-number">4.1.</span> <span class="toc-text">微信的小程序的主要文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小程序中如何进行接口请求？会不会跨域，为什么"><span class="toc-number">4.2.</span> <span class="toc-text">小程序中如何进行接口请求？会不会跨域，为什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小程序的常用命令有哪些"><span class="toc-number">4.3.</span> <span class="toc-text">小程序的常用命令有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生命周期函数有哪些？小程序的周期函数？"><span class="toc-number">4.4.</span> <span class="toc-text">生命周期函数有哪些？小程序的周期函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用与页面生命周期发生顺序"><span class="toc-number">4.5.</span> <span class="toc-text">应用与页面生命周期发生顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小程序和Vue写法的区别"><span class="toc-number">4.6.</span> <span class="toc-text">小程序和Vue写法的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小程序是如何传值？"><span class="toc-number">4.7.</span> <span class="toc-text">小程序是如何传值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小程序如何进行页面的跳转传参以及接收数据"><span class="toc-number">4.8.</span> <span class="toc-text">小程序如何进行页面的跳转传参以及接收数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wxss-和-css-的区别"><span class="toc-number">4.9.</span> <span class="toc-text">wxss 和 css 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小程序是如何传递数据？"><span class="toc-number">4.10.</span> <span class="toc-text">小程序是如何传递数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小程序如何进行本地存储？"><span class="toc-number">4.11.</span> <span class="toc-text">小程序如何进行本地存储？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#谈谈你对微信小程序请求封装的理解"><span class="toc-number">4.12.</span> <span class="toc-text">谈谈你对微信小程序请求封装的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webview-的理解"><span class="toc-number">4.13.</span> <span class="toc-text">webview 的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小程序和-h5-页面的交互"><span class="toc-number">4.14.</span> <span class="toc-text">小程序和 h5 页面的交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意事项"><span class="toc-number">4.15.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小程序的双向绑定和-vue-的有什么区别"><span class="toc-number">4.16.</span> <span class="toc-text">小程序的双向绑定和 vue 的有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#下拉刷新的实现方法"><span class="toc-number">4.17.</span> <span class="toc-text">下拉刷新的实现方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跳转的方式有哪些"><span class="toc-number">4.18.</span> <span class="toc-text">跳转的方式有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#描述一下小程序的登陆流程"><span class="toc-number">4.19.</span> <span class="toc-text">描述一下小程序的登陆流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wx-if-和-hidden-的区别，如何使用？"><span class="toc-number">4.20.</span> <span class="toc-text">wx:if 和 hidden 的区别，如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#app-json-的配置项"><span class="toc-number">4.21.</span> <span class="toc-text">app.json 的配置项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#微信小程序中的数据渲染与浏览器中有什么不同"><span class="toc-number">4.22.</span> <span class="toc-text">微信小程序中的数据渲染与浏览器中有什么不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#你认为微信小程序的优点是什么，缺点是什么"><span class="toc-number">4.23.</span> <span class="toc-text">你认为微信小程序的优点是什么，缺点是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何优化首次加载小程序的速度"><span class="toc-number">4.24.</span> <span class="toc-text">如何优化首次加载小程序的速度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法题"><span class="toc-number">5.</span> <span class="toc-text">算法题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#去重-1"><span class="toc-number">5.1.</span> <span class="toc-text">去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快排算法"><span class="toc-number">5.2.</span> <span class="toc-text">快排算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序"><span class="toc-number">5.3.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#防抖、节流"><span class="toc-number">5.4.</span> <span class="toc-text">防抖、节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求和"><span class="toc-number">5.5.</span> <span class="toc-text">求和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组转对象"><span class="toc-number">5.6.</span> <span class="toc-text">数组转对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间相关"><span class="toc-number">5.7.</span> <span class="toc-text">时间相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack"><span class="toc-number">6.</span> <span class="toc-text">webpack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack-的打包原理、流程"><span class="toc-number">6.1.</span> <span class="toc-text">webpack 的打包原理、流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack-区分不同的开发环境"><span class="toc-number">6.2.</span> <span class="toc-text">webpack 区分不同的开发环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack-的基本配置，每个配置作用"><span class="toc-number">6.3.</span> <span class="toc-text">webpack 的基本配置，每个配置作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Loader-Plugin-的区别"><span class="toc-number">6.4.</span> <span class="toc-text">Loader - Plugin 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#loader"><span class="toc-number">6.4.1.</span> <span class="toc-text">loader</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#配置"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#特性"><span class="toc-number">6.4.1.2.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#常用-Loader"><span class="toc-number">6.4.1.3.</span> <span class="toc-text">常用 Loader</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Plugin"><span class="toc-number">6.4.2.</span> <span class="toc-text">Plugin</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#配置-1"><span class="toc-number">6.4.2.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#常见的-Plugin"><span class="toc-number">6.4.2.2.</span> <span class="toc-text">常见的 Plugin</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#区别"><span class="toc-number">6.4.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack-性能优化"><span class="toc-number">6.5.</span> <span class="toc-text">webpack 性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JS-代码压缩"><span class="toc-number">6.5.1.</span> <span class="toc-text">JS 代码压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-代码压缩"><span class="toc-number">6.5.2.</span> <span class="toc-text">CSS 代码压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Html-文件代码压缩"><span class="toc-number">6.5.3.</span> <span class="toc-text">Html 文件代码压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文件大小压缩"><span class="toc-number">6.5.4.</span> <span class="toc-text">文件大小压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#图片压缩"><span class="toc-number">6.5.5.</span> <span class="toc-text">图片压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tree-Shaking"><span class="toc-number">6.5.6.</span> <span class="toc-text">Tree Shaking</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码分离"><span class="toc-number">6.5.7.</span> <span class="toc-text">代码分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内联-chunk"><span class="toc-number">6.5.8.</span> <span class="toc-text">内联 chunk</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack-构建优化"><span class="toc-number">6.6.</span> <span class="toc-text">webpack 构建优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优化-loader-配置"><span class="toc-number">6.6.1.</span> <span class="toc-text">优化 loader 配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#合理-resolve-extensions"><span class="toc-number">6.6.2.</span> <span class="toc-text">合理 resolve.extensions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化-resolve-modules"><span class="toc-number">6.6.3.</span> <span class="toc-text">优化 resolve.modules</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化-resolve-alias"><span class="toc-number">6.6.4.</span> <span class="toc-text">优化 resolve.alias</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化-resolve-mainFields"><span class="toc-number">6.6.5.</span> <span class="toc-text">优化 resolve.mainFields</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#开启多线程"><span class="toc-number">6.6.6.</span> <span class="toc-text">开启多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#合理使用-sourceMap"><span class="toc-number">6.6.7.</span> <span class="toc-text">合理使用 sourceMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Webpack-Proxy-工作原理"><span class="toc-number">6.7.</span> <span class="toc-text">Webpack Proxy 工作原理</span></a></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
            <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            常用知识总结
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://www.shuy.cc/2022/05/05/mianshi/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2022-05-05T05:54:03.000Z" itemprop="datePublished">2022-05-05</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/css-js-vue/">css js vue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="–-html-css"><a href="#–-html-css" class="headerlink" title="– html/css"></a>– html/css</h2><h3 id="—-css-的布局方式"><a href="#—-css-的布局方式" class="headerlink" title="— css 的布局方式"></a>— css 的布局方式</h3><p>1.table 布局<br>2.flex 布局<br>3.float 布局<br>4.响应式布局</p>
<h3 id="—-盒子模型"><a href="#—-盒子模型" class="headerlink" title="— 盒子模型"></a>— 盒子模型</h3><p>IE 盒子模型：宽高包括 content + padding + bording; box-sizing: border-box<br>标准盒模型：宽高就是元素的实际宽高 content; box-sizing: content-box</p>
<a id="more"></a>
<h3 id="什么是-BFC？"><a href="#什么是-BFC？" class="headerlink" title="什么是 BFC？"></a>什么是 BFC？</h3><p>bfc 就是 Block formatting contexts，<strong><em>块级格式化上下文</em></strong><br>一个独立的渲染区域，有这自己的渲染规则，其内部元素不会和外部元素相互影响。<br>常见触发 <strong>BFC</strong> 方式：</p>
<ol>
<li>元素设置了 float 属性（float 不为 none）;</li>
<li>元素设置了 position 属性为 absolute 或 fixed;</li>
<li>元素设置了 display 属性为 inline-block;</li>
<li>元素 overflow 属性值除了 visible 外。</li>
</ol>
<h3 id="—-HTML5-新增元素"><a href="#—-HTML5-新增元素" class="headerlink" title="— HTML5 新增元素"></a>— HTML5 新增元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">canvas/audio/video</span><br><span class="line">source(定义媒体资源&lt;video&gt;/&lt;audio&gt;)/</span><br><span class="line">embed(定义嵌入的内容)/track(为诸如video和audio元素之类的媒介规定外部文本轨道)</span><br><span class="line">article 定义页面独立的内容区域</span><br><span class="line">aside 定义页面的侧边栏内容</span><br><span class="line">details 描述文档或文档某个部分的细节</span><br><span class="line">dialog 定义对话框</span><br><span class="line">footer header 定义文档的头尾区域</span><br><span class="line">nav 定义导航链接的部分</span><br><span class="line">等等</span><br></pre></td></tr></table></figure>
<h3 id="—-居中的方式"><a href="#—-居中的方式" class="headerlink" title="— 居中的方式"></a>— 居中的方式</h3><!-- 1) 使用Flexbox布局
在父级容器中设置 display: flex; 和 justify-content: center; align-items: center;
这将使子元素水平和垂直居中

2) 使用Grid布局
在父级容器中设置 display: grid; 和 place-items: center;
这将使子元素水平和垂直居中

3) 使用绝对定位
+ 在子元素中设置 position: absolute; 和 top: 50%; left: 50%; (transform: translate(-50%, -50%)/margin-top: -50%;margin-left: -50%;);
+ 在子元素中设置 position: absolute; 和 top:0; left: 0; bottom: 0; right: 0;
这将使子元素相对于父级容器垂直和水平居中 -->
<ul>
<li>使用绝对定位 + transform，给子元素添加如下样式<br>这种方式比较常用，<strong><em>父子元素都不确定宽高</em></strong>的情况也适用。<br>如果 <strong><em>子元素的宽高确定</em></strong>的话，translate 中的值也可以设置为子元素宽高的一半，即 transform: translate(-100px, -100px);</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.work</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用绝对定位 + margin，给子元素添加如下样式<br>这种方式适合 <strong><em>子元素宽高确定</em></strong>的情况，给 margin-top 设置百分比的大小将不生效，即 margin-top: -50%;不能达到垂直居中的效果</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.work1</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用绝对定位 + margin: auto，给子元素添加如下样式<br><strong><em>父子元素宽高都未知时也适用</em></strong>。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.work2</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>父元素使用 flex 布局，并设置相关的属性值为 center<br>这种方式要求 <strong><em>父元素的高度是确定的</em></strong> ，百分比形式的高度将不能生效。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.par-work</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 table-cell 实现<br>这种方式需要 <strong><em>父元素的宽高都是确定的</em></strong>，才能保证子元素在父元素中垂直水平都居中。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.par-work2</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son-work2</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 grid 布局<br>这种方式适用于 <strong><em>父元素高度确定</em></strong>的情况</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.par-work3</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son-work3</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: center; <span class="comment">/*设置单元格内容的垂直位置*/</span></span><br><span class="line">  <span class="attribute">justify-self</span>: center; <span class="comment">/*设置单元格内容的水平位置*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="—-有哪些方式可以影藏页面元素？区别是什么？"><a href="#—-有哪些方式可以影藏页面元素？区别是什么？" class="headerlink" title="— 有哪些方式可以影藏页面元素？区别是什么？"></a>— 有哪些方式可以影藏页面元素？区别是什么？</h3><ul>
<li>display: none</li>
<li>visibility: hidden</li>
<li>opacity: 0</li>
<li>width + height 设置为 0</li>
<li>定位到可视范围之外</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>display: none</th>
<th>visibility: hidden</th>
<th>opacity: 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>页面中</td>
<td>不存在</td>
<td>存在</td>
<td>存在</td>
</tr>
<tr>
<td>重排</td>
<td>会</td>
<td>不会</td>
<td>不会</td>
</tr>
<tr>
<td>重绘</td>
<td>会</td>
<td>会</td>
<td>不一定</td>
</tr>
<tr>
<td>自身绑定事件</td>
<td>不触发</td>
<td>不触发</td>
<td>触发</td>
</tr>
<tr>
<td>transition</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>被遮挡的元素可出发事件</td>
<td>能</td>
<td>能</td>
<td>不能</td>
</tr>
</tbody>
</table>
<h3 id="—-css-选择器有哪些？优先级"><a href="#—-css-选择器有哪些？优先级" class="headerlink" title="— css 选择器有哪些？优先级"></a>— css 选择器有哪些？优先级</h3><ul>
<li>!important</li>
<li>行内样式</li>
<li>Id 选择器</li>
<li>类选择器 class</li>
<li>后代选择器 .box dox</li>
<li>子选择器 .box&gt;.child 选择.box 下面所有类名为 child 的元素</li>
<li>相邻同胞选择器 .one+.two,选择紧邻.one 之后的所有.two 元素</li>
<li>div,p 选择所有的 div、p 的所有元素</li>
<li>伪类选择器</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:link</span> 选择未被访问的链接</span><br><span class="line"><span class="selector-pseudo">:visited</span>：选取已被访问的链接</span><br><span class="line"><span class="selector-pseudo">:active</span>：选择活动链接</span><br><span class="line"><span class="selector-pseudo">:hover</span> ：鼠标指针浮动在上面的元素</span><br><span class="line"><span class="selector-pseudo">:focus</span> ：选择具有焦点的</span><br><span class="line"><span class="selector-pseudo">:first-child</span>：父元素的首个子元</span><br></pre></td></tr></table></figure>
<ul>
<li>伪元素选择器</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:first-letter</span> ：用于选取指定选择器的首字母</span><br><span class="line"><span class="selector-pseudo">:first-line</span> ：选取指定选择器的首行</span><br><span class="line"><span class="selector-pseudo">:before</span> : 选择器在被选元素的内容前面插入内容</span><br><span class="line"><span class="selector-pseudo">:after</span> : 选择器在被选元素的内容后面插入内容</span><br></pre></td></tr></table></figure>
<ul>
<li>属性选择器</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[attribute]</span> 选择带有<span class="selector-tag">attribute</span>属性的元素</span><br><span class="line">[attribute=value] 选择所有使用attribute=value的元素</span><br><span class="line"><span class="selector-attr">[attribute~=value]</span> 选择<span class="selector-tag">attribute</span>属性包含<span class="selector-tag">value</span>的元素</span><br><span class="line"><span class="selector-attr">[attribute|=value]</span>：选择<span class="selector-tag">attribute</span>属性以<span class="selector-tag">value</span>开头的元素</span><br></pre></td></tr></table></figure>
<ul>
<li>伪类选择器（css3）</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:first-of-type</span> 父元素的首个元素</span><br><span class="line"><span class="selector-pseudo">:last-of-type</span> 父元素的最后一个元素</span><br><span class="line"><span class="selector-pseudo">:only-of-type</span> 父元素的特定类型的唯一子元素</span><br><span class="line"><span class="selector-pseudo">:only-child</span> 父元素中唯一子元素</span><br><span class="line"><span class="selector-pseudo">:nth-child(n)</span> 选择父元素中第<span class="selector-tag">N</span>个子元素</span><br><span class="line"><span class="selector-pseudo">:nth-last-of-type(n)</span> 选择父元素中第<span class="selector-tag">N</span>个子元素，从后往前</span><br><span class="line"><span class="selector-pseudo">:last-child</span> 父元素的最后一个元素</span><br><span class="line"><span class="selector-pseudo">:root</span> 设置<span class="selector-tag">HTML</span>文档</span><br><span class="line"><span class="selector-pseudo">:empty</span> 指定空的元素</span><br><span class="line"><span class="selector-pseudo">:enabled</span> 选择被禁用元素</span><br><span class="line"><span class="selector-pseudo">:disabled</span> 选择被禁用元素</span><br><span class="line"><span class="selector-pseudo">:checked</span> 选择选中的元素</span><br><span class="line"><span class="selector-pseudo">:not(selector)</span> 选择非 &lt;<span class="selector-tag">selector</span>&gt; 元素的所有元素</span><br></pre></td></tr></table></figure>
<ul>
<li>属性选择器（css3）</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[attribute*=value]</span>：选择<span class="selector-tag">attribute</span>属性值包含<span class="selector-tag">value</span>的所有元素</span><br><span class="line"><span class="selector-attr">[attribute^=value]</span>：选择<span class="selector-tag">attribute</span>属性开头为<span class="selector-tag">value</span>的所有元素</span><br><span class="line"><span class="selector-attr">[attribute$=value]</span>：选择<span class="selector-tag">attribute</span>属性结尾为<span class="selector-tag">value</span>的所有元素</span><br></pre></td></tr></table></figure>
<p>nth-child/nth-of-type 的区别</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>1<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>2<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>3<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>4<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>6<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>7<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2n+1 // 1 3 5 7</span><br><span class="line"><span class="selector-tag">h5</span><span class="selector-pseudo">:nth-child(2n+1)</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/img-folder/2023/ms-1.png"></p>
<p>1）先找设置标签的全部同级标签<br>2）然后找对应的下标，如果选择器一致，那就匹配上，不一致就继续匹配下个下标的选择器</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h5</span><span class="selector-pseudo">:nth-of-type(2n</span> + 1) &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/img-folder/2023/ms-2.png"></p>
<p>1）找出和设置标签一样的标签<br>2）然后再找对应的下标标签</p>
<h3 id="—-清除浮动的方法"><a href="#—-清除浮动的方法" class="headerlink" title="— 清除浮动的方法"></a>— 清除浮动的方法</h3><p>1）使用带 clear 属性的空元素<br>在浮动元素的后面设置一个空元素，然后给这个空元素设置属性.clear{clear:both;}<br>2）使用 overflow 属性<br>给浮动元素的容器添加 overflow:hidden;或 overflow:auto;可以清除浮动，另外在 IE6 中还 需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。 在添加 overflow 属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动 的效果。<br>3）使用 css 的:after 伪元素</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span>  solid<span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"020"</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="comment">/* 表示元素不可见 */</span></span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.media</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background-color</span>:aquamarine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class="container"&gt;</span><br><span class="line">  &lt;div class="media"&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;p&gt;hello&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<h3 id="—-常见的行内元素、块级元素"><a href="#—-常见的行内元素、块级元素" class="headerlink" title="— 常见的行内元素、块级元素"></a>— 常见的行内元素、块级元素</h3><p>1.块级元素<br>div/p/h1~h6/ol/ul/li/table 2.行内元素<br>span/img/a/strong/input</p>
<h3 id="—-position-的属性"><a href="#—-position-的属性" class="headerlink" title="— position 的属性"></a>— position 的属性</h3><p>相对定位：relative,相对于当前元素的位置来移动<br>绝对定位：absolute,相对于父元素（具有相对定位属性）来定位<br>固定定位：fixed,相对于页面的左上角定位</p>
<h3 id="—-SEO"><a href="#—-SEO" class="headerlink" title="— SEO"></a>— SEO</h3><p>1）语义化的 html 的标签使用<br>2）设置合理的 title,description,keywords<br>3）重要的 html 代码放到页面的前面<br>4）尽量少用 iframe，搜索引擎抓不到里面的内容<br>5）图片上面加上 alt 属性</p>
<h3 id="—-什么是响应式布局？"><a href="#—-什么是响应式布局？" class="headerlink" title="— 什么是响应式布局？"></a>— 什么是响应式布局？</h3><p>响应式网站设计（Responsive Web design）是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整</p>
<p>1&gt; 响应式网站常见特点：</p>
<ul>
<li>同时适配 PC + 平板 + 手机等</li>
<li>标签导航在接近手持终端设备时改变为经典的抽屉式导航</li>
<li>网站的布局会根据视口来调整模块的大小和位置</li>
</ul>
<p>2&gt; 实现响应式布局的方式有如下：</p>
<ul>
<li>媒体查询（我们可以设置不同类型的媒体条件，并根据对应的条件，给相应符合条件的媒体调用相对应的样式表）</li>
<li>百分比</li>
<li>vw/vh</li>
<li>rem</li>
</ul>
<p>3&gt; 响应式设计实现通常会从以下几方面思考：</p>
<ul>
<li>弹性盒子（包括图片、表格、视频）和媒体查询等技术</li>
<li>使用百分比布局创建流式布局的弹性 UI，同时使用媒体查询限制元素的尺寸和内容变更范围</li>
<li>使用相对单位使得内容自适应调节</li>
<li>选择断点，针对不同断点实现不同布局和内容展示</li>
</ul>
<h3 id="—-flex"><a href="#—-flex" class="headerlink" title="— flex"></a>— flex</h3><p>参考文档：<a href="/2020/11/05/flex布局教程/">flex 布局教程</a></p>
<h3 id="—-rem、em、vh、px-各自代表的含义？"><a href="#—-rem、em、vh、px-各自代表的含义？" class="headerlink" title="— rem、em、vh、px 各自代表的含义？"></a>— rem、em、vh、px 各自代表的含义？</h3><blockquote>
<p>CSS 中的尺寸单位都是 相对长度单位，只是相对的目标不同。</p>
</blockquote>
<ul>
<li>px: 绝对单位，页面按精确像素展示<br>px 全称为 pixel（像素），它是相对于 <strong>屏幕显示器分辨率</strong>（桌面设定的分辨率，不是显示器的物理分辨率） 而言的，在 相同/不同 的设备上 1px 表示多个 设备像素。<br>当 <strong>一个像素点越大</strong> 时, 呈现的图像就会 越模糊；当<strong>一个像素点越小</strong>时, 像素点就会 越密集, 呈现的图像就会 越清晰。</li>
<li><p>em: 相对单位，基准为父节点字体大小，如果自身定义了 font-size 按照自身来计算，整个页面内 1em 不是一个固定值</p>
<blockquote>
<p>若 当前元素/父元素 的 font-size 未设置，由于 font-size 属性值可被继承的原因，可逐级向上查找，最终找不到则相对于浏览器默认字体大小，即 font-size = 16px。</p>
</blockquote>
</li>
<li><p>rem: 相对单位，可以理解为 root em，相对根节点 html 的字体大小来计算<br>默认根元素的 font-size 都是 16px 的。如果想要设置 12px 的字体大小也就 是 12px/16px = 0.75rem</p>
</li>
<li><p>vh/vw: 主要用于页面视口大小布局，在页面布局上更加方便简单<br>vw 和 vh 是将 视口 宽/高 都分成 100 份，因此 <code>100vw = 视口宽</code>、<code>100vh = 视口高</code><br>与之相关的还有 vmin 和 vmax 两个单位。</p>
</li>
<li><p>vmin 和 vmax 代表的是 <code>视口宽度</code> 和 <code>视口高度</code> 中的 <code>最小值</code> 和 <code>最大值</code></p>
</li>
<li><code>vmin = 视口高度 vh 和 宽度 vw 间的最小值</code></li>
<li><code>vmax = 视口高度 vh 和 宽度 vw 间的最大值</code></li>
</ul>
<h3 id="H5-移动端适配原理"><a href="#H5-移动端适配原理" class="headerlink" title="- H5 移动端适配原理"></a>- H5 移动端适配原理</h3><p><strong>rem适配原理</strong></p>
<ul>
<li>将设备分成 n 等分，n 可以是任意正确的值（比如 <code>flexible.js</code> 中的 n = 10 ）。</li>
<li><ul>
<li>设置 <code>html</code> 元素的 <code>font-size</code> 为 <code>设备宽度 / 10</code>，即得到 设备视口 1 rem 到底表示 多少设备视口 px。</li>
</ul>
</li>
<li>将设计稿也分成 n 等分，此时设计稿中的某个元素a 的 px 对应 设备中这个元素的 rem 的计算方式为</li>
<li><ul>
<li>?rem = 设计稿 a px / (<code>设计稿的宽度 / n</code>(表示1rem为多少px像素))</li>
</ul>
</li>
</ul>
<p>举个例子：<br>比如你的设计稿是 750px，然后你分成了10，那么 1rem = 75px，此时设计稿中某个元素的大小为 30px，<br>那么在设备中这个元素的大小就是 30/75 = 0.4rem。</p>
<p>常用插件：<br><code>lib-flexible</code> 和 <code>postcss-px2rem-exclude</code></p>
<p>使用postcss-px2rem-exclude可以将项目中的px自动转换成rem<br>amfe-flexible则可以根据不同型号的手机，进行相应的HTML根节点(font-szie)的初始化。</p>
<ol>
<li><p>安装 postcss-px2rem-exclude</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-px2rem-exclude --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 amfe-flexible</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install amfe-flexible --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>在vue项目中的main.js导入amfe-flexible</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ‘amfe-flexible’; <span class="regexp">/ /</span>引入amfe-flexible做rem适配</span><br></pre></td></tr></table></figure>
</li>
<li><p>在vue项目中的vue.config.js中配置postcss-px2rem-exclude</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      postcss: &#123;</span><br><span class="line">        plugins: [</span><br><span class="line">          <span class="built_in">require</span>(<span class="string">"postcss-px2rem-exclude"</span>)(&#123;</span><br><span class="line">          	<span class="comment">// 在这里，由于我的设计稿尺寸的屏幕分辨率是1920，具体原因如下：</span></span><br><span class="line">            remUnit: <span class="number">192</span>, <span class="comment">// 设计稿尺寸/10</span></span><br><span class="line">          &#125;),</span><br><span class="line">        ],</span><br><span class="line"> &#125;,&#125;&#125;,&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有个问题：如何配置remUnit的数值：</p>
</li>
</ol>
<blockquote>
<p>通常我们是根据设计图来定这个值, 原因很简单，便于开发。假如设计图给的宽度是1920，我们通常就会把remUnit设置为192（设计图宽度的十分之一），这样我们写样式时，可以直接按照设计图标注的宽高来1:1还原开发。</p>
</blockquote>
<p>行内样式不能转化rem的问题？<br>我们可以写一个px2rem方法，放在全局，在src/main.js里写如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">px2rem</span>(<span class="params">px</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="regexp">/%/ig</span>.test(px))&#123; <span class="comment">// 有百分号%，特殊处理，表述pc是一个有百分号的数，比如：90%</span></span><br><span class="line">    <span class="keyword">return</span> px</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">parseFloat</span>(px) / <span class="number">192</span>) + <span class="string">'rem'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Vue.prototype.$px2rem = px2rem <span class="comment">// 放到全局</span></span><br></pre></td></tr></table></figure></p>
<p>对应的页面的使用方式：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>今天是2022年9月16日，天气晴<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span> <span class="attr">:style</span>=<span class="string">"&#123;fontSize:$px2rem('30px')&#125;"</span>&gt;</span>距离国庆还有14天<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>哈哈哈哈哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="—-js-中的数据类型"><a href="#—-js-中的数据类型" class="headerlink" title="— js 中的数据类型"></a>— js 中的数据类型</h3><ul>
<li>基本类型 string number null undefind boolean Symbol(ES6 引入了一种新的原始数据类型，表示独一无二的值)</li>
<li>引用类型 Object Array Function</li>
</ul>
<h3 id="—-var-let-const-的区别？"><a href="#—-var-let-const-的区别？" class="headerlink" title="— var/let/const 的区别？"></a>— var/let/const 的区别？</h3><ul>
<li>变量提升<br>var 声明存在变量提升，let 和 const 不存在变量提升，不声明是不可以使用的，否则会报错</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> a; <span class="comment">// 重复声明会被忽视</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例3</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>js 中，变量提升指的是变量声明的提升，赋值还是按照代码中的顺序逐行执行。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式声明 会变量提升</span></span><br><span class="line">fn(<span class="number">10</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 表达式声明 不会变量提升</span></span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// undefined</span></span><br><span class="line">test(<span class="number">10</span>); <span class="comment">// TypeError: test is not a function</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// f a()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// f a()</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ƒ a(v)&#123;return v&#125;</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数的提升是优先变量的提升的。<br>变量提升指的是变量声明的提升，赋值还是按照代码中的顺序逐行执行。<br>函数式声明存在变量提升，函数表达式声明不存在变量提升。</p>
</blockquote>
<ul>
<li>作用域<br>var 没有块级作用域一说，不声明也是可以使用的，let，const 有块级作用域一说，只能在声明的花括号里面使用</li>
<li>使用的方法<br>const 声明一个只读的变量，一旦声明，不可以修改，其余使用 let，避免使用 var，因为有不可控性，代码复杂的时候，不容易查找问题。</li>
</ul>
<h3 id="—-ES6-标准入门"><a href="#—-ES6-标准入门" class="headerlink" title="— ES6 标准入门"></a>— ES6 标准入门</h3><p>文档参考：<a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">ES6 入门教程</a></p>
<h3 id="—-数组常用的方法"><a href="#—-数组常用的方法" class="headerlink" title="— 数组常用的方法"></a>— 数组常用的方法</h3><h4>增删改</h4>

<table>
<thead>
<tr>
<th></th>
<th>向前+</th>
<th>向前-</th>
<th>向后+</th>
<th>向后-</th>
</tr>
</thead>
<tbody>
<tr>
<td>页面中</td>
<td>unshift</td>
<td>shift</td>
<td>push</td>
<td>pop</td>
</tr>
<tr>
<td>语法</td>
<td>array.unshift(item1,item2, …, itemX)</td>
<td>array.shift()</td>
<td>array.push(item1, item2, …, itemX)</td>
<td>array.pop()</td>
</tr>
<tr>
<td>返回结果</td>
<td>数组新长度</td>
<td>数组原来的第一个元素的值（移除的元素）</td>
<td>数组新长度</td>
<td>返回删除的元素</td>
</tr>
<tr>
<td>原数组</td>
<td>改变原数组</td>
<td>改变了原数组</td>
<td>改变原数组</td>
<td>改变了原数组</td>
</tr>
</tbody>
</table>
<ul>
<li>concat 合并两个数组</li>
<li>splice （增、删、改）传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组<br>array.splice(index,howmany,item1,…..,itemX)</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>必需。规定从何处添加/删除元素。<br>该参数是开始插入和（或）删除的数组元素的下标，必须是数字。</td>
</tr>
<tr>
<td>howmany</td>
<td>可选。规定应该删除多少元素。必须是数字，但可以是 “0”。<br>如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。</td>
</tr>
<tr>
<td>item1, …, itemX</td>
<td>可选。要添加到数组的新元素</td>
</tr>
</tbody>
</table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除数组的第三个元素，并在数组第三个位置添加新元素:</span></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line">fruits.splice(<span class="number">2</span>, <span class="number">1</span>, <span class="string">"Lemon"</span>, <span class="string">"Kiwi"</span>);</span><br><span class="line"><span class="comment">// Banana,Orange,Lemon,Kiwi,Mango</span></span><br><span class="line"><span class="comment">// 从第三个位置开始删除数组后的两个元素：</span></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line"><span class="comment">// Banana,Orange</span></span><br><span class="line">fruits.splice(<span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>slice() 方法可从已有的数组中返回选定的元素。<br>slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。【不会影响原始数组】<br>array.slice(start, end)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用负值从数组中读取元素</span></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Lemon"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line"><span class="keyword">var</span> myBest = fruits.slice(<span class="number">-3</span>, <span class="number">-1</span>); <span class="comment">// 截取倒数第三个（包含）到倒数第一个（不包含）的两个元素</span></span><br><span class="line"><span class="keyword">var</span> myBest = fruits.slice(<span class="number">-3</span>); <span class="comment">// 截取最后三个元素</span></span><br><span class="line"><span class="comment">// Lemon,Apple</span></span><br><span class="line"><span class="comment">// 截取字符串</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"www.runoob.com!"</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.slice(<span class="number">4</span>) + <span class="string">"&lt;br&gt;"</span>); <span class="comment">// 从第 5 个字符开始截取到末尾</span></span><br><span class="line"><span class="built_in">document</span>.write(str.slice(<span class="number">4</span>, <span class="number">10</span>)); <span class="comment">// 从第 5 个字符开始截取到第10个字符</span></span><br></pre></td></tr></table></figure>
<p></p><h4>查</h4><br>查找元素，返回元素坐标或者元素值<p></p>
<ul>
<li>indexOf() 返回要查找的元素在数组中的位置，如果没找到则返回 -1</li>
<li>includes() 返回要查找的元素在数组中的位置，找到返回 true，否则 false</li>
<li>find() 返回通过测试（函数内判断）的数组的第一个元素的值<br>当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。<br>如果没有符合条件的元素返回 undefined</li>
</ul>
<blockquote>
<p>array.find(function(currentValue, index, arr),thisValue)<br>[参数]<br>callback：必须。为数组中每个元素执行的函数，该函数接受三个参数：<br>currentValue：必须。数组中正在处理的当前元素。<br>index：可选。当前元素的索引值。<br>arr：可选。当前元素所在的数组对象。<br>thisValue：可选。传递给函数的值一般用 “this” 值。<br>如果这个参数为空， “undefined” 会传递给 “this” 值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> num = arr1.find(<span class="function">(<span class="params">item</span>) =&gt;</span> item &gt; <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>findIndex() 返回传入一个测试条件（函数）符合条件的数组第一个元素位置。<br>当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。<br>如果没有符合条件的元素返回 -1</li>
</ul>
<blockquote>
<p>array.findIndex(function(currentValue, index, arr), thisValue)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以这么写</span></span><br><span class="line"><span class="keyword">const</span> index = arr.findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(index); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 也可以这么写</span></span><br><span class="line"><span class="keyword">const</span> index = arr.findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p></p><h4>排序</h4><p></p>
<ul>
<li>reverse() 将数组元素翻转</li>
<li>sort()</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort()); <span class="comment">// [1,11,2,22,3,33,4,5]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下 sort 方法是按 ascii 字母顺序排序的，而非我们认为是按数字大小排序</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">v1, v2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (v1 &gt; v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v1 &lt; v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v1 === v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a.sort(compare);</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [1, 1, 2, 3, 4, 5, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">v1, v2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v2 - v1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a.sort(compare);</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [10, 9, 5, 4, 3, 2, 1, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">v1, v2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v1 - v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a.sort(compare);</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [1, 1, 2, 3, 4, 5, 9, 10]</span></span><br></pre></td></tr></table></figure>
<h4 id="数组转字符窜"><a href="#数组转字符窜" class="headerlink" title="数组转字符窜"></a>数组转字符窜</h4><p>join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串</p>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><ul>
<li>some() 对数组每一项都运行传入的函数，有一项符合就返回 true</li>
<li>every() 每一项都符合才返回 true</li>
<li>forEach() 循环数组每一项，没有返回值</li>
<li>filter() 返回符合的项会组成函数</li>
<li>map() 返回由每次函数调用的结果组成的函数</li>
<li>for…in 遍历对象的属性 key</li>
<li>for…of 遍历对象的值 value</li>
</ul>
<h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><p>1.利用 ES6 Set 去重</p>
<p>ES6 提供了新的数据结构 <code>Set</code>。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p><code>Set</code>本身是一个构造函数，用来生成 <code>Set</code> 数据结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br><span class="line">上面代码通过add()方法向 <span class="built_in">Set</span> 结构加入成员，结果表明 <span class="built_in">Set</span> 结构不会添加重复的值。</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">"true"</span>,</span><br><span class="line">  <span class="string">"true"</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">NaN</span>,</span><br><span class="line">  <span class="literal">NaN</span>,</span><br><span class="line">  <span class="string">"NaN"</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="string">"a"</span>,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">"a"</span>,</span><br><span class="line">];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", &#123;&#125;, &#123;&#125;]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Array.from()方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组，也是 ES6 的新增方法。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"tom"</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">"65"</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">"男"</span>,</span><br><span class="line">  <span class="number">3</span>: [<span class="string">"jane"</span>, <span class="string">"john"</span>, <span class="string">"Mary"</span>],</span><br><span class="line">  length: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(arrayLike);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ['tom','65','男',['jane','john','Mary']]</span></span><br></pre></td></tr></table></figure>
<p>2.利用 for 嵌套 for，然后 splice 去重（ES5 中最常用）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">        <span class="comment">//第一个等同于第二个，splice方法删除第二个</span></span><br><span class="line">        arr.splice(j, <span class="number">1</span>);</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">"true"</span>,</span><br><span class="line">  <span class="string">"true"</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">NaN</span>,</span><br><span class="line">  <span class="literal">NaN</span>,</span><br><span class="line">  <span class="string">"NaN"</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="string">"a"</span>,</span><br><span class="line">  <span class="string">"a"</span>,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">//[1, "true", 15, false, undefined, NaN, NaN, "NaN", "a", &#123;…&#125;, &#123;…&#125;]     //NaN和&#123;&#125;没有去重，两个null直接消失了</span></span><br></pre></td></tr></table></figure>
<p>3.利用 indexOf 去重</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"type error!"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> array = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.indexOf(arr[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">      array.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">"true"</span>,</span><br><span class="line">  <span class="string">"true"</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">NaN</span>,</span><br><span class="line">  <span class="literal">NaN</span>,</span><br><span class="line">  <span class="string">"NaN"</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="string">"a"</span>,</span><br><span class="line">  <span class="string">"a"</span>,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", &#123;…&#125;, &#123;…&#125;]  //NaN、&#123;&#125;没有去重</span></span><br></pre></td></tr></table></figure>
<p>4.利用 includes</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"type error!"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> array = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!array.includes(arr[i])) &#123;</span><br><span class="line">      <span class="comment">//includes 检测数组是否有某个值</span></span><br><span class="line">      array.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">"true"</span>,</span><br><span class="line">  <span class="string">"true"</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">NaN</span>,</span><br><span class="line">  <span class="literal">NaN</span>,</span><br><span class="line">  <span class="string">"NaN"</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="string">"a"</span>,</span><br><span class="line">  <span class="string">"a"</span>,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", &#123;…&#125;, &#123;…&#125;]     //&#123;&#125;没有去重</span></span><br></pre></td></tr></table></figure>
<h3 id="—-call-apply-bind-的区别？"><a href="#—-call-apply-bind-的区别？" class="headerlink" title="— call/apply/bind 的区别？"></a>— call/apply/bind 的区别？</h3><ul>
<li>call()的第一个参数为 this 绑定的对象，后面传入一串字符窜<br>当第一个参数为 null 或者 undefined 的时候，默认指向 window</li>
<li>apply()和 call 类似，不同在于第二个参数是一个数组</li>
<li>bind()和 call()类似，不同点在于 bind()不会立即执行，而是返回了一个改变 this 后的函数；不同点二在于当你调用 fn1 = fn.bind(newThis,param1)方法后，执行 fn2(prama2)时，参数 prama2 会加到 param1 后面。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">"obj1"</span>,</span><br><span class="line">  fn1(param) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, param);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">"obj2"</span>,</span><br><span class="line">  fn1(param) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, param);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 一般调用</span></span><br><span class="line">obj1.fn1(<span class="string">"param1"</span>); <span class="comment">//输出 obj1 param1</span></span><br><span class="line"><span class="comment">//call的第一参数为调用该函数的对象时，等价于一般调用</span></span><br><span class="line">obj1.fn1.call(obj1, <span class="string">"param1"</span>); <span class="comment">//输出 obj1 param1</span></span><br><span class="line"><span class="comment">//改变this指针，指向obj2</span></span><br><span class="line">obj1.fn1.call(obj2, <span class="string">"param1"</span>); <span class="comment">//输出 obj2 param1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//apply的第二个参数为参数数组</span></span><br><span class="line">obj1.fn1.apply(obj2, [<span class="string">"param1"</span>]); <span class="comment">//输出 obj2 param1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bind方法返回一个函数,但不会执行，这个函数的参数继承bind方法的参数</span></span><br><span class="line"><span class="keyword">let</span> fun = obj1.fn1.bind(obj2, <span class="string">"param"</span>);</span><br><span class="line">fun(); <span class="comment">//输出 obj2 param1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>求数组中的最大最小值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">46</span>];</span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr); <span class="comment">// 46</span></span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, arr); <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">window</span>.Math.max(...arr);</span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">window</span>.Math.min(...arr);</span><br></pre></td></tr></table></figure>
<p>这里利用 apply 的第二个参数是接受一个数组，而在调用函数的时候会自动展开这个数组，而 max 和 min 方法接受参数的形式是(1,2,3,4)。</p>
<blockquote>
<p>将 arguments 等类数组转换为数组</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trueArr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>, <span class="built_in">arguments</span>.length);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 log 代替 console.log</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><p>普通函数的 this 是调用者；箭头函数的 this 是根据作用域的上下文确定的，是不可以修改的。</p>
<ul>
<li>全局声明的函数，this 指向的是 window</li>
<li>对象里面的函数，this 指向的是当前的对象，但是可以修改</li>
<li>构造函数的 this，指向的是 new 出来的对象</li>
<li>箭头函数的 this，是当前声明箭头函数的作用域 this 指向的是谁，this 就是指向谁</li>
</ul>
<h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><p>一句话：谁调用就指向谁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  getAge() &#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">person.getAge(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个的 getAge 方法是 person 调用的，所以 this 指向 person，person.age 输出为 20；</p>
</blockquote>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>一句话：调用者指向谁，则指向谁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  getAge: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">person.getAge(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个的 getAge 方法是 person 调用的，则 getAge 和 person 的指向一致，person 是 window 调用的（参照上述普通函数），所以 person 指向 window，因此 getAge 也指向 window，输出 10。</p>
</blockquote>
<h4 id="强制改变-this-指向"><a href="#强制改变-this-指向" class="headerlink" title="强制改变 this 指向"></a>强制改变 this 指向</h4><p>一句话：你说指向谁就指向谁。<br>改变 this 指向，有 call，apply，bind 这几种方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">person.getAge.call(person);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里 call 方法将 person 作为 this 指向，所以输出 20。<br>这里在执行 getAge 方法的时候，传入了 person，那么 getAge 的 this 指向 person，所以输出 20。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>箭头函数没有 this，箭头函数的 this 指向的是外层第一个普通函数的 this，如果外层没有普通函数，则指向 window。</li>
<li>普通函数的 this 指向调用者，如果调用者是 window，则指向 window。</li>
<li>箭头函数的 this 指向是固定的，不会指向调用者，而是指向外层第一个普通函数的 this。</li>
</ol>
<h3 id="—-typeof-与-instanceof-区别"><a href="#—-typeof-与-instanceof-区别" class="headerlink" title="— typeof 与 instanceof 区别"></a>— typeof 与 instanceof 区别</h3><p>typeof 和 instanceof 都是 JavaScript 中用来检测数据类型的运算符，但它们的作用不同。<br>1.typeof 运算符是用来检测一个变量或表达式的数据类型的。它返回一个字符串，表示该值的数据类型。</p>
<blockquote>
<p>基本数据类型可以用 typeof 检测出来，但 null、数组、对象、函数的实例(new+函数),返回的都是 object，无法检测到真实的数据类型，需要使用 instanceof</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">123</span>); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">"hello"</span>); <span class="comment">//输出 string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">//输出 boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">//输出 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;); <span class="comment">//输出 function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">//输出 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> [<span class="number">123</span>]); <span class="comment">//输出 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123; <span class="attr">name</span>: <span class="string">"tom"</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;); <span class="comment">//输出 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">//输出 object</span></span><br></pre></td></tr></table></figure>
<p>2.instanceof<br>instanceof 运算符是用来判断一个对象是否属于某个类（构造函数）的实例。<br>instanceof 检查的是对象的原型链上是否有该类实例，只要原型链上有该类实例，就会返回 true，否则为 false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// 返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">date <span class="keyword">instanceof</span> <span class="built_in">Date</span>; <span class="comment">// 返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/hello/</span>;</span><br><span class="line">reg <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>; <span class="comment">// 返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="built_in">console</span>.log(dog <span class="keyword">instanceof</span> Dog); <span class="comment">//输出 true</span></span><br><span class="line"><span class="built_in">console</span>.log(dog <span class="keyword">instanceof</span> Person); <span class="comment">//输出 true</span></span><br><span class="line"><span class="built_in">console</span>.log(dog <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//输出 true</span></span><br><span class="line"><span class="comment">//执行顺序：dog--&gt;Person的实例--&gt;Object实例--&gt;Object原型</span></span><br><span class="line"><span class="comment">//Object是所有对象的原型，所以任何和对象和Object进行instanceof运算都会返回true</span></span><br><span class="line"><span class="keyword">let</span> b = &#123; <span class="attr">name</span>: <span class="string">"Bob"</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Person); <span class="comment">//输出 false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，instanceof 运算符只能用来判断对象是否为该类的实例，不能用来判断基本数据类型的值。而且，如果要判断对象是否为某个类的实例，该类必须是通过构造函数定义的，不能是字面量对象或匿名函数等其他形式。</p>
</blockquote>
<p>3.typeof 与 instanceof 总结：<br>①typeof 与 instanceof 用来判断变量是否为空,或者属于什么数据类型<br>②typeof 返回的是一个字符串,用来判断是什么数据类型<br>③instanceof 返回的是一个布尔值,用来判断一个变量是否属于对象上的实例<br>④typeof 检测的是简单数据类型,instanceof 检测的是引用数据类型</p>
<h3 id="—-本地存储"><a href="#—-本地存储" class="headerlink" title="— 本地存储"></a>— 本地存储</h3><ul>
<li>cookie<br>存储数据大小为 4K 左右，客户端请求服务器。将 cookie 返给服务器，以此来判断用户的状态，可以设置过期时间，不可跨域访问</li>
<li>sessionStorage<br>存储数据大小为 5M 左右，在当前浏览器窗口关闭后自动删除，存储位置为当前域名的浏览器本地</li>
<li>localStorage<br>存储数据大小为 5M 左右，可以手动添加删除，不手动删除，会一直保存在当前域名的浏览器本地</li>
</ul>
<blockquote>
<p>标记用户与跟踪用户行为的情况，推荐使用 cookie<br>适合长期保存在本地的数据（令牌），推荐使用 localStorage<br>敏感账号一次性登录，推荐使用 sessionStorage</p>
</blockquote>
<h3 id="—-深拷贝和浅拷贝"><a href="#—-深拷贝和浅拷贝" class="headerlink" title="— 深拷贝和浅拷贝"></a>— 深拷贝和浅拷贝</h3><p>浅拷贝指的是创建一个属性、值完全一样的变量，如果是基本类型，拷贝的就是基本类型，如果是引用类型那拷贝的就是一个内存对象，只是拷贝出了一个引用值，改变拷贝值，原值也会改变。<br>深拷贝完全是开辟了一个栈，两个引用类型出了属性、值一样，完全都是独立的，修改其中的一个，不会影响另一个的值。</p>
<ul>
<li>Object.assign</li>
<li>Array.prototype.slice()</li>
<li>Array.prototype.concat()</li>
<li>… 拓展符实现的复制</li>
</ul>
<p>以上方法都存在浅拷贝的现象</p>
<p>深拷贝的方法有：</p>
<ul>
<li>_cloneDeep() Lodash 库的方法</li>
<li>jQuery.extend()</li>
<li>JSON.stringify()</li>
<li>循环递归</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">"object"</span> || obj === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      result[key] = deepClone(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="—-JSON-是什么？"><a href="#—-JSON-是什么？" class="headerlink" title="— JSON 是什么？"></a>— JSON 是什么？</h3><p>JSON 是轻量级的文本数据格式，是一门独立的语言，是用 js 语法描述的数据对象，但独立于任何的语言，编程语言都支持 JSON，具有自我描述性，更容易理解。</p>
<ul>
<li>json 对象转化为 json 字符窜</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonStr = <span class="built_in">JSON</span>.stringify(jsonObj);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>JSON 字符串转化为 JSON 对象</p>
<p>1). 使用 eval()函数进行转换<br>使用 eval() 转换时需要在 json 字符外包裹一对小括号。</p>
</li>
</ul>
<p>ie8(兼容模式)、ie7、ie6 不要使用此方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">eval</span>(<span class="string">"("</span> + jsonStr + <span class="string">")"</span>);</span><br></pre></td></tr></table></figure>
<p>2). 使用 JSON.parse()方法进行转换<br>ie8(兼容模式)、ie7、ie6 不要使用此方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.parse(jsonStr);</span><br></pre></td></tr></table></figure>
<p>3). 使用 jQuery 进行转换<br>如果我们项目中有使用 jQuery，那么直接使用 $.parseJSON() 方法即可，而且可以确保各个浏览器的兼容性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = $.parseJSON(jsonStr);</span><br></pre></td></tr></table></figure>
<h3 id="—-闭包，使用场景"><a href="#—-闭包，使用场景" class="headerlink" title="— 闭包，使用场景"></a>— 闭包，使用场景</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>闭包是指一个函数中有权访问另一个函数中的变量，本质就是在函数 A 中返回另一个函数 B，这时候 B 函数可以访问 A 函数中的变量，这样就形成了一个闭包，A 函数中变量不会被销毁，并且这个变量只能通过 B 函数来访问。</p>
<h4 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h4><p>能够让函数执行后，其中的变量不会被销毁，同时能够让函数内的局部变量被访问。</p>
<h4 id="闭包带来的问题和如何规避"><a href="#闭包带来的问题和如何规避" class="headerlink" title="闭包带来的问题和如何规避"></a>闭包带来的问题和如何规避</h4><p>由于垃圾回收机制不能销毁闭包中的局部变量，从而导致内存泄漏，一旦闭包使用的太多，就会导致内存溢出，导致程序不安全和卡顿，所以必须手动设置闭包=null,让垃圾回收机制回收闭包中的变量。</p>
<h4 id="简单实现一个闭包"><a href="#简单实现一个闭包" class="headerlink" title="简单实现一个闭包"></a>简单实现一个闭包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getA = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = getA();</span><br><span class="line"><span class="built_in">console</span>.log(a()); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4><ul>
<li>延长变量的生命周期</li>
<li>创建私有变量</li>
<li>闭包可以在函数外部访问到函数内部作用域的变量</li>
<li>闭包可以让访问变量不会被垃圾机制回收</li>
</ul>
<h4 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h4><ul>
<li>使用场景一:给对象设置私有变量并且利用特权方法去访问私有属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"tom"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> Fun();</span><br><span class="line"><span class="built_in">console</span>.log(fun.name); <span class="comment">//输出undefined,在外部无法直接访问name</span></span><br><span class="line"><span class="built_in">console</span>.log(fun.getName()); <span class="comment">//可以通过特定方法去访问</span></span><br></pre></td></tr></table></figure>
<ul>
<li>防抖节流</li>
</ul>
<h3 id="—-什么是防抖和节流？"><a href="#—-什么是防抖和节流？" class="headerlink" title="— 什么是防抖和节流？"></a>— 什么是防抖和节流？</h3><ul>
<li>防抖 n 秒后在执行该事件，若在 n 秒之内被重复触发，则重新计时(单位时间内，频繁触发一个事件，以最后一次触发为准。)</li>
</ul>
<blockquote>
<p>简单点理解就是：<br>防抖是频繁执行某个事件的时候，就等事件停止之后的 n 秒后再执行相关的操作；<br>节流是频繁执行某个事件的时候，规定 n 秒执行一次回调（执行相关的操作），比如规定了 1S 执行一次，那就是如果用户某个按钮频繁点击了 3S，那就执行相关操作（执行回调方法）3 次。</p>
</blockquote>
<p>使用场景：<br>最典型的防抖函数应用场景就是搜索输入框了，用户输入之后需要自动发送网络请求获取数据，但是普通函数会频繁的触发事件，而用户的输入并没有完成，请求的结果也是无意义的，毫无疑问地给服务器造成了巨大地压力。<br>现在需要优化的关键点就是，如何使网络请求触发的不那么频繁，比如在用户输入停下一段时间后，这时，可能代表用户输入已经完毕，在这时才发送请求是最合适的。防抖函数就可以很好的做到这一点。<br>防抖函数的功能：如果在某个时间内反复触发的函数，那么它只会执行最后触发的那一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖动</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>func 需要防抖执行的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>delay 多少毫秒不调用后执行一次,延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>节流 n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效(单位时间内，频繁触发一个事件，只会触发一次。)</li>
</ul>
<p>应用场景：假如有一个轮播图，轮播图以固定的频率播放图片，用户可以点击切换上一张或者下一张，如果用户点击过快，轮播图就会一直切换。这时候，应该控制轮播图切换的频率，在用户的持续点击下，只按照固定的频率切换。<br>节流函数的功能：连续的触发某个函数，只会以固定的频率去执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, delay = <span class="number">500</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> **<span class="doctag">@param<span class="type">&#123;fn: function&#125;</span> </span>需要节流的函数</span></span><br><span class="line"><span class="comment"> **<span class="doctag">@param<span class="type">&#123;interval: number&#125;</span> </span>函数触发的频率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, interval</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 记录上一次触发函数时的时间，初始值为0</span></span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取现在的时间</span></span><br><span class="line">    <span class="keyword">const</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="comment">// 如果现在的时间减去上次触发的事件大于等于interval，则可以执行函数了</span></span><br><span class="line">    <span class="keyword">if</span> (nowTime - lastTime &gt;= interval) &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      <span class="comment">// 将上次触发函数的时间赋值成当前时间</span></span><br><span class="line">      lastTime = nowTimes;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>fn 方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>delay 每隔多少毫秒执行一次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, delay</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="—-ajax-的请求过程"><a href="#—-ajax-的请求过程" class="headerlink" title="— ajax 的请求过程"></a>— ajax 的请求过程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax 提交 post 请求的数据</span></span><br><span class="line"><span class="comment">// 1. 创建核心对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 2. 准备建立连接</span></span><br><span class="line">xhr.open(<span class="string">"POST"</span>, <span class="string">"register.php"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 3. 发送请求</span></span><br><span class="line"><span class="comment">// 如果要POST提交数据，则需要设置请求头</span></span><br><span class="line"><span class="comment">// 有的面试官会问为什么要设置请求头？ 知道请求正文是以什么格式</span></span><br><span class="line"><span class="comment">// Content-Type: application/x-www-form-urlencoded，请求正文是类似 get 请求 url 的请求参数</span></span><br><span class="line"><span class="comment">// Content-Type: application/json，请求正文是一个 json 格式的字符串</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">xhr.send(querystring);</span><br><span class="line"><span class="comment">// 4. 处理响应</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// 请求处理完毕，响应就绪</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="comment">// 请求成功</span></span><br><span class="line">      <span class="keyword">var</span> data = xhr.responseText;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="—-ajax-请求的时候-get-和-post-方式的区别"><a href="#—-ajax-请求的时候-get-和-post-方式的区别" class="headerlink" title="— ajax 请求的时候 get 和 post 方式的区别"></a>— ajax 请求的时候 get 和 post 方式的区别</h3><ul>
<li>get 请求，传递的参数是链接传递，有长度限制（IE 和 Safari 浏览器 限制 2k，Opera 限制 4k，Firefox 限制 8k（非常老的版本 256byte）），post 请求无限制</li>
<li>get 请求参数在 url 后面传递，不安全，容易被窃取</li>
<li>post 请求需要设置请求头</li>
</ul>
<h3 id="—-ajax、axios、jsonp-的理解"><a href="#—-ajax、axios、jsonp-的理解" class="headerlink" title="— ajax、axios、jsonp 的理解"></a>— ajax、axios、jsonp 的理解</h3><p>1、jsonp 是一种可以解决跨域问题的方式，就是通过动态创建 script 标签用 src 引入外部文件实现跨域，script 加载实际上就是一个 get 请求，并不能实现 post 请求。(其他实现跨域的方法有：iframe,window.name,postMessage,CORS…)<br>2、ajax 是一种技术，ajax 技术包含了 get 和 post 请求的，但是它仅仅是一种获取数据的技术，不能直接实现跨域，只有后台服务器配置好 Access-Control-Allow-Origin，才可以实现跨域的请求。<br>3、axios 是通过 promise 实现对 ajax 技术的一种封装，axios 是 ajax，ajax 不止 axios。</p>
<h3 id="—-什么是事件委托以及优缺点"><a href="#—-什么是事件委托以及优缺点" class="headerlink" title="— 什么是事件委托以及优缺点"></a>— 什么是事件委托以及优缺点</h3><p>js 事件委托就是利用冒泡的原理，把本应该添加到某个元素上的事件委托给他的父级，从而减少 DOM 交互达到网页优化。</p>
<p>【优点】</p>
<p>1.可以大量节省内存占用，减少事件注册。比如 ul 上代理所有 li 的 click 事件就很不错。 2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适</p>
<p>【缺点】</p>
<p>事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。</p>
<h3 id="—-如何解决数字精度丢失的问题"><a href="#—-如何解决数字精度丢失的问题" class="headerlink" title="— 如何解决数字精度丢失的问题?"></a>— 如何解决数字精度丢失的问题?</h3><p>理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果</p>
<p>当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">1.4000000000000001</span>).toPrecision(<span class="number">12</span>)) === <span class="number">1.4</span>; <span class="comment">// True</span></span><br></pre></td></tr></table></figure>
<p>封装成方法就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strip</span>(<span class="params">num, precision = <span class="number">12</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +<span class="built_in">parseFloat</span>(num.toPrecision(precision));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后还可以使用第三方库，如 Math.js、BigDecimal.js</p>
<h3 id="—-原型，原型链-有什么特点？"><a href="#—-原型，原型链-有什么特点？" class="headerlink" title="— 原型，原型链 ? 有什么特点？"></a>— 原型，原型链 ? 有什么特点？</h3><p>JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象</p>
<p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</p>
<p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p>
<h3 id="—-如何实现上拉加载，下拉刷新？"><a href="#—-如何实现上拉加载，下拉刷新？" class="headerlink" title="— 如何实现上拉加载，下拉刷新？"></a>— 如何实现上拉加载，下拉刷新？</h3><p>开源社区有很多优秀的解决方案，如 iscroll、better-scroll、pulltorefresh.js 库等等</p>
<h3 id="—-说说你对作用域链的理解"><a href="#—-说说你对作用域链的理解" class="headerlink" title="— 说说你对作用域链的理解"></a>— 说说你对作用域链的理解</h3><p>1、作用域就是变量与函数的可访问范围<br>2、一般情况下，变量取值到创建这个变量的函数的作用域中取值。 但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链</p>
<!-- ### — 浏览器内核 -->
<h3 id="—-浏览器输入-Url-之后发生了什么？"><a href="#—-浏览器输入-Url-之后发生了什么？" class="headerlink" title="— 浏览器输入 Url 之后发生了什么？"></a>— 浏览器输入 Url 之后发生了什么？</h3><p>浏览器输入 URL 链接 -&gt; 回车 -&gt; 浏览器查找当前 URL 是否有本地缓存 -&gt; dns 解析 URL 对应的 IP -&gt; 根据 IP 建立 TCP 连接(三次握手) -&gt; 发起 http 请求 -&gt; 服务器处理请求 -&gt; 关闭 TCP 连接(四次握手) -&gt; 浏览器根据发回的 response 响应，启用浏览器的渲染引擎和 JS 引擎，更具 HTML/CSS/JS/IMG 等等渲染页面。</p>
<h4 id="从输入-URL-到页面加载的主干流程如下："><a href="#从输入-URL-到页面加载的主干流程如下：" class="headerlink" title="从输入 URL 到页面加载的主干流程如下："></a>从输入 URL 到页面加载的主干流程如下：</h4><p>1、浏览器的地址栏输入 URL 并按下回车。</p>
<p>2、浏览器查找当前 URL 的 DNS 缓存记录。</p>
<p>3、DNS 解析 URL 对应的 IP。</p>
<p>4、根据 IP 建立 TCP 连接（三次握手）。</p>
<p>5、HTTP 发起请求。</p>
<p>6、服务器处理请求，浏览器接收 HTTP 响应。</p>
<p>7、渲染页面，构建 DOM 树。</p>
<p>8、关闭 TCP 连接（四次挥手）。</p>
<h5 id="1-首先在浏览器中输入-URL"><a href="#1-首先在浏览器中输入-URL" class="headerlink" title="1.首先在浏览器中输入 URL"></a>1.首先在浏览器中输入 URL</h5><p>我们常见的 RUL 是这样的:<br><a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a><br>这个域名由三部分组成：协议名、域名、端口号，这里端口是默认所以隐藏。除此之外 URL 还会包含一些路径、查询和其他片段<br>例如：<a href="http://www.tuicool.com/search?kw=%E4%。" target="_blank" rel="noopener">http://www.tuicool.com/search?kw=%E4%。</a><br>我们最常见的的协议是 HTTP 协议，除此之外还有加密的 HTTPS 协议、FTP 协议、FILe 协议等等。URL 的中间部分为域名或者是 IP，之后就是端口号了。通常端口号不常见是因为大部分的都是使用默认端口，如 HTTP 默认端口 80，HTTPS 默认端口 443。</p>
<ul>
<li><p>查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。</p>
</li>
<li><p>浏览器缓存：浏览器会记录 DNS 一段时间，因此，只是第一个地方解析 DNS 请求；</p>
</li>
<li><p>操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的 DNS 查询缓存)；</p>
</li>
<li><p>路由器缓存：如果上述两个步骤均不能成功获取 DNS 记录，继续搜索路由器缓存；</p>
</li>
<li><p>ISP 缓存：若上述均失败，继续向 ISP 搜索。</p>
</li>
</ul>
<h5 id="2-DNS-域名解析"><a href="#2-DNS-域名解析" class="headerlink" title="2.DNS 域名解析"></a>2.DNS 域名解析</h5><p>我们知道在地址栏输入的域名并不是最后资源所在的真实位置，域名只是与 IP 地址的一个映射。网络服务器的 IP 地址那么多，我们不可能去记一串串的数字，因此域名就产生了，域名解析的过程实际是将域名还原为 IP 地址的过程。</p>
<p>首先浏览器先检查本地 hosts 文件是否有这个网址映射关系，如果有就调用这个 IP 地址映射，完成域名解析。</p>
<p>如果没找到则会查找本地 DNS 解析器缓存，如果查找到则返回。</p>
<p>如果还是没有找到则会查找本地 DNS 服务器，如果查找到则返回。</p>
<p>最后迭代查询，按根域服务器 -&gt;顶级域,.cn-&gt;第二层域，hb.cn -&gt;子域，<a href="http://www.hb.cn的顺序找到IP地址。" target="_blank" rel="noopener">www.hb.cn的顺序找到IP地址。</a></p>
<p>DNS 域名解析：浏览器向 DNS 服务器发起请求，解析该 URL 中的域名对应的 IP 地址。DNS 服务器是基于 UDP 的，因此会用到 UDP 协议。</p>
<h5 id="3-建立-TCP-连接：-解析出-IP-地址后，根据-IP-地址和默认-80-端口，和服务器建立-TCP-连接"><a href="#3-建立-TCP-连接：-解析出-IP-地址后，根据-IP-地址和默认-80-端口，和服务器建立-TCP-连接" class="headerlink" title="3.建立 TCP 连接： 解析出 IP 地址后，根据 IP 地址和默认 80 端口，和服务器建立 TCP 连接"></a>3.建立 TCP 连接： 解析出 IP 地址后，根据 IP 地址和默认 80 端口，和服务器建立 TCP 连接</h5><p>发起 HTTP 请求： 浏览器发起读取文件的 HTTP 请求，，该请求报文作为 TCP 三次握手的第三次数据发送给服务器</p>
<p>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的 html 文件发送给浏览器</p>
<p>关闭 TCP 连接 ： 通过四次挥手释放 TCP 连接</p>
<p>浏览器渲染：客户端（浏览器）解析 HTML 内容并渲染出来，浏览器接收到数据包后的解析</p>
<p><strong>构建 DOM 树：</strong>词法分析然后解析成 DOM 树（dom tree），是由 dom 元素及属性节点组成，树的根是 document 对象</p>
<p>构建 CSS 规则树：生成 CSS 规则树（CSS Rule Tree）<br>构建 render 树：Web 浏览器将 DOM 和 CSSOM 结合，并构建出渲染树（render tree）<br>布局（Layout）：计算出每个节点在屏幕中的位置<br>绘制（Painting）：即遍历 render 树，并使用 UI 后端层绘制每个节点。<br>JS 引擎解析过程：<br>调用 JS 引擎执行 JS 代码（JS 的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</p>
<p>创建 window 对象：window 对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于 window 的属性和方法，而 DOM Tree 也会映射在 window 的 doucment 对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。<br>加载文件：完成 js 引擎分析它的语法与词法是否合法，如果合法进入预编译<br>预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为 window 的属性加入到 window 对象中，并给变量赋值为’undefined’；寻找全局函数声明，把它作为 window 的方法加入到 window 对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在 ES6 中已经解决了，函数提升还存在。<br>解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在 ES5 非严格模式下这个变量会成为 window 的一个属性，也就是成为全局变量。string、int 这样的值就是直接把值放在变量的存储空间里，object 对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS 作用域其实就是这样的执行流机制实现的。<br>浏览器重绘与重排的区别？<br>重排/回流（Reflow）：当 DOM 的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。<br>重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变<br>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分<br>重排和重绘代价是高昂的，它们会破坏用户体验，并且让 UI 展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。<br>『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。<br>如何触发重排和重绘？<br>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p>
<p>添加、删除、更新 DOM 节点<br>通过 display: none 隐藏一个 DOM 节点-触发重排和重绘<br>通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化<br>移动或者给页面中的 DOM 节点添加动画<br>添加一个样式表，调整样式属性<br>用户行为，例如调整窗口大小，改变字号，或者滚动。<br>如何避免重绘或者重排？<br>集中改变样式，不要一条一条地修改 DOM 的样式。</p>
<p>不要把 DOM 结点的属性值放在循环里当成循环里的变量。</p>
<p>为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。</p>
<p>不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</p>
<p>尽量只修改 position：absolute 或 fixed 元素，对其他元素影响不大</p>
<p>动画开始 GPU 加速，translate 使用 3D 变化</p>
<p>提升为合成层</p>
<blockquote>
<p>将元素提升为合成层有以下优点：<br>合成层的位图，会交由 GPU 合成，比 CPU 处理要快<br>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层<br>对于 transform 和 opacity 效果，不会触发 layout 和 paint<br>提升合成层的最好方式是使用 CSS 的 will-change 属性：#target {will-change: transform;}</p>
</blockquote>
<h3 id="谈谈你对-promise、axios-的理解"><a href="#谈谈你对-promise、axios-的理解" class="headerlink" title="谈谈你对 promise、axios 的理解"></a>谈谈你对 promise、axios 的理解</h3><p><strong><em>promise</em></strong> 是 js 用来处理所有异步操作的<br>传统的方式处理异步操作，就是 ajax 嵌套 ajax,就是常说的回调地狱，是非常难维护，而 promise 有 resolive 和 reject 这两个方法，将成功和失败返回的数据，传递给使用者，promise 开始的状态是 pending ，当成功或者失败的时候，状态会切换到 fulfilled(成功)或者 rejected（失败）状态，把结果通过 then()或者 catch()交出去。<br>promise 不仅仅一次处理一个异步请求，它还有两个方法，all() 和 race() ,all() 只有在里面所有的异步操作都成功才算是成功，race() 只有在一个异步请求成功就会往后面继续执行代码。</p>
<h3 id="webpack-构建优化怎么搞？"><a href="#webpack-构建优化怎么搞？" class="headerlink" title="webpack 构建优化怎么搞？"></a>webpack 构建优化怎么搞？</h3><p>webpack 构建的时候，需要找出所有模块文件进行编译处理，那么我们可以在以下几个点上做优化处理：</p>
<ol>
<li>缩小文件的搜索范围，用 alias extensions 等配置缩小范围</li>
<li>减少需要解析的文件，使用 noParse 配置告诉 webpack 排除指定的文件，不对它们进行解析</li>
<li>避免重复编译第三方库，可以吧第三方文件库单独打包到一个文件夹中，他不会跟着业务代码一起重新打包</li>
</ol>
<p>构建的时候，如果对多个 js 文件需要被压缩，他会一个一个的进行压缩，可以使用 parallelUglifyPlugin 插件来开启多个子进程，采用并行方式对多个 js 文件进行压缩</p>
<h3 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h3><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p>
<p>HTTP状态码的英文为HTTP Status Code。</p>
<p>下面是常见的HTTP状态码：</p>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<h4 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h4><p>1×× 信息，服务器收到消息，需求请求者继续执行操作<br>2×× 成功，操作被成功接收并处理<br>3×× 重定向，需要进一步的操作以完成请求<br>4×× 客户端的错误，请求包含语法错误或无法完成请求<br>5×× 服务器错误，服务器在处理请求的过程中发生了错误</p>
<h4 id="完整状态码"><a href="#完整状态码" class="headerlink" title="完整状态码"></a>完整状态码</h4><ul>
<li>100 Continue 继续。客户端应继续其请求</li>
<li>101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</li>
<li>200 OK 请求成功。一般用于GET与POST请求</li>
<li>201 Created 已创建。成功请求并创建了新的资源</li>
<li>202 Accepted 已接受。已经接受请求，但未处理完成</li>
<li>203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</li>
<li>204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li>
<li>205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</li>
<li>206 Partial Content 部分内容。服务器成功处理了部分GET请求</li>
<li>300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</li>
<li>301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li>
<li>302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li>
<li>303 See Other 查看其它地址。与301类似。使用GET和POST请求查看</li>
<li>304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li>
<li>305 Use Proxy 使用代理。所请求的资源必须通过代理访问</li>
<li>306 Unused 已经被废弃的HTTP状态码</li>
<li>307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向</li>
<li>400 Bad Request 客户端请求的语法错误，服务器无法理解</li>
<li>401 Unauthorized 请求要求用户的身份认证</li>
<li>402 Payment Required 保留，将来使用</li>
<li>403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求</li>
<li>404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通常可以自定义404错误页面。</li>
<li>405 Method Not Allowed 客户端请求中的方法被禁止</li>
<li>406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求</li>
<li>407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</li>
<li>408 Request Time-out 服务器等待客户端发送的请求时间过长，超时</li>
<li>409 Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</li>
<li>410 Gone客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</li>
<li>411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息</li>
<li>412 Precondition Failed 客户端请求信息的先决条件错误</li>
<li>413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</li>
<li>414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理</li>
<li>415 Unsupported Media Type 服务器无法处理请求附带的媒体格式</li>
<li>416 Requested range not satisfiable 客户端请求的范围无效</li>
<li>417 Expectation Failed 服务器无法满足Expect的请求头信息</li>
<li>500 Internal Server Error 服务器内部错误，无法完成请求</li>
<li>501 Not Implemented 服务器不支持请求的功能，无法完成请求</li>
<li>502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</li>
<li>503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</li>
<li>504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求</li>
<li>505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理</li>
</ul>
<h3 id="git-常用的命令行"><a href="#git-常用的命令行" class="headerlink" title="git 常用的命令行"></a>git 常用的命令行</h3><h2 id="vue-相关"><a href="#vue-相关" class="headerlink" title="vue 相关"></a>vue 相关</h2><h3 id="什么是-mvvm"><a href="#什么是-mvvm" class="headerlink" title="什么是 mvvm?"></a>什么是 mvvm?</h3><p>modal + view + viewModal 的缩写，是 modal 驱动 view 的渐进式框架，不需要直接操作 dom 来实现页面的改变。<br>1）View 层<br>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。<br>（2）Model 层<br>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。<br>（3）ViewModel 层<br>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。</p>
<p>（1）View 层</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;button v-on:click="showMessage()"&gt;Click me&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>（2）ViewModel 层</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    <span class="comment">// 用于描述视图状态</span></span><br><span class="line">    message: <span class="string">"Hello Vue!"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 用于描述视图行为</span></span><br><span class="line">    showMessage() &#123;</span><br><span class="line">      <span class="keyword">let</span> vm = <span class="keyword">this</span>;</span><br><span class="line">      alert(vm.message);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="keyword">let</span> vm = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Ajax 获取 Model 层的数据</span></span><br><span class="line">    ajax(&#123;</span><br><span class="line">      url: <span class="string">"/your/server/data/api"</span>,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        vm.message = res;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>（3） Model 层</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"/your/server/data/api"</span>,</span><br><span class="line">    <span class="string">"res"</span>: &#123;</span><br><span class="line">        <span class="string">"success"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"IoveC"</span>,</span><br><span class="line">        <span class="string">"domain"</span>: <span class="string">"www.cnblogs.com"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么-Vue-里面的是-data-是函数？"><a href="#为什么-Vue-里面的是-data-是函数？" class="headerlink" title="为什么 Vue 里面的是 data 是函数？"></a>为什么 Vue 里面的是 data 是函数？</h3><p>Vue实例中的 data 是通过一个函数的返回值来返回的，这样创建每一个实例的时候，就会返回一个新的对象，相当于给每一个实例的 data 属性对象创建了一个新的内存空间，相当于每次调用组件的时候，都生成了一个意思对象属性，这样就不会造成数据污染，避免发生一个组件里面修改了里面的对象，调用这个组件的所有数据都发生变化。</p>
<h3 id="怎样理解-Vue-的单向数据流？"><a href="#怎样理解-Vue-的单向数据流？" class="headerlink" title="怎样理解 Vue 的单向数据流？"></a>怎样理解 Vue 的单向数据流？</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中<br>但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。<br>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。</p>
<blockquote>
<p>子组件修改父组件的props值，只能事件通知父组件来修改，而不能直接去修改父组件的值。</p>
</blockquote>
<h3 id="Vue-是如何实现数据双向绑定的？"><a href="#Vue-是如何实现数据双向绑定的？" class="headerlink" title="Vue 是如何实现数据双向绑定的？"></a>Vue 是如何实现数据双向绑定的？</h3><p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据.<br>即：</p>
<ul>
<li><p>输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。</p>
</li>
<li><p>Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。</p>
</li>
</ul>
<p>其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。<br>回答1：<br>通过数据劫持和订阅者、发布者模式来实现，同时使用Object.defineProperty()方法来给劫持的属性添加getter和setter，当数据改变时，setter触发，setter中发布消息，订阅者收到消息后进行更新,也就是说数据发生变化视图更新，视图改变，数据也改变。<br>第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter属性。<br>第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。<br>第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:<br>1、在自身实例化时往属性订阅器(dep)里面添加自己<br>2、自身必须有一个update()方法<br>3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则更新视图。<br>第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt;视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。<br>回答2：<br><strong>Vue 的双向数据绑定实现原理主要基于以下几个核心概念：</strong></p>
<ol>
<li><strong>数据劫持</strong>：Vue 使用 Object.defineProperty 方法来劫持数据的 setter 和 getter，以此实现数据与视图的双向绑定。当数据对象被修改时，视图也会随之更新。</li>
<li><strong>依赖追踪</strong>：当一个 Vue 实例劫持数据对象的属性时，Vue 会缓存这些属性，并使用一个叫做“依赖追踪”的对象来记录这些属性的依赖关系。当依赖对象被修改时，Vue 会触发更新相关的视图。</li>
<li><strong>异步更新</strong>：Vue 为了性能优化，采用了异步更新的策略。当数据变化时，Vue 不会立即更新视图，而是将更新操作放入一个队列中，等待浏览器的 repaint，然后再统一进行更新。这样可以在一次 repaint 中尽可能多地更新视图，提高性能。</li>
<li><strong>响应式系统</strong>：Vue 还设计了一套响应式系统，用于管理这些依赖关系和更新队列。当依赖关系发生变化时，Vue 会自动更新相关的视图，并处理可能出现的冲突和错误。</li>
</ol>
<p><strong>在实现细节上，Vue 的双向数据绑定机制包括以下几个步骤：</strong></p>
<ol>
<li>在 Vue 实例创建时，对 data 中的属性进行劫持，添加对应的 getter 和 setter，用于拦截属性的读取和修改操作。</li>
<li>当组件中通过 v-model 指令或其他方式对 data 中的属性进行修改时，getter 和 setter 会拦截这些操作，并更新 Vue 实例中的数据状态。</li>
<li>当 Vue 实例中的数据状态发生变化时，会触发依赖追踪对象的更新操作，将相关的视图加入到更新队列中。</li>
<li>在浏览器 repaint 阶段，Vue 会统一执行更新队列中的更新操作，将数据状态与视图状态同步。<br>总的来说，Vue 的双向数据绑定机制通过数据劫持、依赖追踪和异步更新等技术实现了高效的数据与视图之间的同步，为开发者提供了简洁易用的开发体验。</li>
</ol>
<h3 id="Vue-框架怎么实现对象和数组的监听？"><a href="#Vue-框架怎么实现对象和数组的监听？" class="headerlink" title="Vue 框架怎么实现对象和数组的监听？"></a>Vue 框架怎么实现对象和数组的监听？</h3><p>通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持。<br>同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observe a list of Array items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observe(items[i])  <span class="comment">// observe 功能为监测数据的变化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对属性进行递归遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val) <span class="comment">// observe 功能为监测数据的变化</span></span><br></pre></td></tr></table></figure>
<p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p>
<h3 id="Proxy-与-Object-defineProperty-优劣对比"><a href="#Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="Proxy 与 Object.defineProperty 优劣对比"></a>Proxy 与 Object.defineProperty 优劣对比</h3><p><strong><em>Proxy 的优势如下:</em></strong></p>
<ul>
<li>Proxy 可以直接监听对象而非属性；</li>
<li>Proxy 可以直接监听数组的变化；</li>
<li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li>
<li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li>
<li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li>
</ul>
<p><strong><em>Object.defineProperty 的优势如下:</em></strong></p>
<p>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</p>
<h3 id="Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？"><a href="#Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？" class="headerlink" title="Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？"></a>Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</h3><p>受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。<br>由于 Vue 会在初始化实例时对属性执行 <code>getter/setter</code> 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。<br>但是 Vue 提供了 <code>Vue.set (object, propertyName, value)</code> / <code>vm.$set (object, propertyName, value)</code>来实现为对象添加响应式属性，那框架本身是如何实现的呢？<br>我们查看对应的 Vue 源码：<code>vue/src/core/instance/index.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target: Array&lt;any&gt; | Object, key: any, val: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// target 为数组</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    <span class="comment">// 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span></span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key);</span><br><span class="line">    <span class="comment">// 利用数组的splice变异方法触发响应式</span></span><br><span class="line">    target.splice(key, <span class="number">1</span>, val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// key 已经存在，直接修改属性值</span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__;</span><br><span class="line">  <span class="comment">// target 本身就不是响应式数据, 直接赋值</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对属性进行响应式处理</span></span><br><span class="line">  defineReactive(ob.value, key, val);</span><br><span class="line">  ob.dep.notify();</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们阅读以上源码可知，<code>vm.$set</code> 的实现原理是：</p>
<ul>
<li>如果目标是数组，直接使用数组的 <code>splice</code> 方法触发相应式；</li>
<li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 <code>defineReactive</code> 方法进行响应式处理（ <code>defineReactive</code> 方法就是 Vue 在初始化对象时，给对象属性采用 <code>Object.defineProperty</code> 动态添加 <code>getter</code> 和 <code>setter</code> 的功能所调用的方法）</li>
</ul>
<h3 id="生命周期函数有哪些"><a href="#生命周期函数有哪些" class="headerlink" title="生命周期函数有哪些"></a>生命周期函数有哪些</h3><ul>
<li>beforeCreate 实例刚在内存中被创建出来，此时 dom data methods 都是取不到的</li>
<li>created 实例已经在内存中创建出来，此时 dom 是取不到的 data methods 可以取到</li>
<li>beforeMount 此时已经完成了模板的编译，但是还没有挂载到页面上，相关的 render 函数首次被调用，此时 dom 是取不到的 data methods 可以取到</li>
<li>mounted 已经将编译好的模板，挂载到了页面指定的容器中显示,dom data methods 都可以取到</li>
<li>beforeUpdate 状态更新之前执行此函数，此时 data 中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始重新渲染 DOM 节点</li>
<li>updated 实例更新完毕之后调用此函数，此时 data 中的状态值和界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了</li>
<li>beforeDestory 实例销毁之前调用，在这一步，实例仍然完全可用</li>
<li>destoryed Vue 实例销毁之后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁</li>
</ul>
<blockquote>
<p><strong>调用解耦一般在那个生命周期函数中执行？</strong><br>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。<br>但是推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：<br><u>1.能更快获取到服务端数据，减少页面 loading 时间；</u><br><u>2.ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</u></p>
</blockquote>
<p>但是 <strong><em>具体的需求</em></strong> 需要具体的分析：</p>
<p>比如：如果一个页面里面用到了三个子组件，<br>页面初始化进来的生命周期执行的顺序是：<br>父 beforeCreate -&gt; created -&gt; beforeMount<br>子 1 beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted<br>子 2 beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted<br>子 3 beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted<br>父 mounted</p>
<blockquote>
<p>那么就应该父组件的调用接口逻辑放到 mounted ,子组件的调用接口放到 created , 这样就避免了父组件里面接口调用阻塞子组件的接口返回，使得子组件的数据先显示到页面中去。</p>
</blockquote>
<h3 id="为什么使用虚拟-dom"><a href="#为什么使用虚拟-dom" class="headerlink" title="为什么使用虚拟 dom"></a>为什么使用虚拟 dom</h3><ul>
<li>创建真实 DOM 的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。</li>
<li>触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，以减少浏览器的重绘及回流。<br>1). 重绘：元素样式的改变（但宽高、大小、位置等不变）<br>如：outline、visibility、color、background-color 等<br>只改变自身样式，不会影响到其他元素<br>2). 回流：元素的大小或者位置发生改变（当页面布局和几何信息发生改变的时候），触发了重新布局导致渲染树重新计算布局和渲染<br>​ 如添加或删除可见的 DOM 元素；元素的位置发生变化；元素的尺寸发生变化、内容发生变化（如文本变化或图片被另一个不同尺寸的图片所代替）；页面一开始渲染的时候（无法避免）；<br>​ 因为回流是根据视口大小来计算元素的位置和大小的，所以浏览器窗口尺寸变化也会引起回流</li>
</ul>
<blockquote>
<p>注意：回流一定会触发重绘，而重绘不一定会回流</p>
</blockquote>
<ul>
<li>虚拟 dom 由于本质是一个 js 对象，因此天生具备跨平台的能力，可以实现在不同平台的准确显示。</li>
<li>Virtual DOM 在性能上的收益并不是最主要的，更重要的是它使得 Vue 具备了现代框架应有的高级特性。</li>
</ul>
<h3 id="Vue-中-key-是用来做什么的？为什么不推介使用-index-作为-key？"><a href="#Vue-中-key-是用来做什么的？为什么不推介使用-index-作为-key？" class="headerlink" title="Vue 中 key 是用来做什么的？为什么不推介使用 index 作为 key？"></a>Vue 中 key 是用来做什么的？为什么不推介使用 index 作为 key？</h3><blockquote>
<p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p>
</blockquote>
<p>为什么会更快速，更准确呢，下面来看 vnode 中关于节点更新复用的详情情况<br>在 diff 中比较两个节点是否可以复用，主要通过下面 sameVnode 函数来判断</p>
<p><img src="/images/img-folder/2023/vnode.png"></p>
<ul>
<li>key：列表上每一项设置的 key 值</li>
<li>data：render 函数中设置的一些属性</li>
<li>sel：标签和 id 或者 class，例如 div#app.item，表示 div 标签有一个 id：app，class：item</li>
</ul>
<h4 id="当我们没有设置-key-值的情况"><a href="#当我们没有设置-key-值的情况" class="headerlink" title="当我们没有设置 key 值的情况"></a>当我们没有设置 key 值的情况</h4><p>默认是 <code>undefined，undefined===undefined = true</code></p>
<p>因为是列表，所以标签，class，属性基本上是一样，只是里面内容不一样，通过调用上诉函数，可以判断出：可以复用的 dom<br>我们来设想一下，如果我们有一个列表，然后我们在列表的头部新增一条数据<br>1、首先会比较新增的 vnode 和老元素第一个元素比较，因为 sameVnode 返回 true，标签可以复用，修改里面的内容<br>2、比较第二个元素，是不是 sameVnode 返回的还是 true，标签复用，修改列面的内容，以此类推，是不每一个节点都要替换内容<br>3、如果我们列表每一项有一个 chekbox 元素，勾选的第一项，再插入新元素的时候，是不是你插入的节点被勾选了，这样是不是就不对了，有问题<br>4、而且每一个元素都替换，是不是特别慢，并且列表需要全部重新渲染，大大的影响的性能</p>
<blockquote>
<p>把 key 值设置成 index，有什么问题吧，为什么说最好不要设置成 index</p>
</blockquote>
<p>1、列表每一项设置了一个 index 值，从 0、1、2、3、4、5</p>
<p>2、当我们在头部插入一个节点，是不是插入的节点就变成 0，原来的 0、1、2、3、4 都加一位，我们来 diff 比较的时候，是不是每一项又都不一样了，sameVnode 返回的都是 false，标签不能复用，都要重新创建一个，插入到节点中，这样是不是也全部需要重新渲染，影响性能</p>
<h4 id="如果设置了-key，且-key-值固定的情况"><a href="#如果设置了-key，且-key-值固定的情况" class="headerlink" title="如果设置了 key，且 key 值固定的情况"></a>如果设置了 key，且 key 值固定的情况</h4><p>下面我们来把 key 设置成唯一的值，且是固定的值，当我们在头部插入一个节点，这个节点的 key 没有一样的，我们就创建一个，插入到头部</p>
<p>后面的节点，是不是 sel 没有变，标签没有变，key 值也没有变，是不是节点全部都可以复用，只是把位置挪动下，实际上就只创建了一个元素，这样就可以大大加快渲染速度</p>
<p>这就是我们所说的 diff 操作更加准确，更快速的原因</p>
<h3 id="v-show-和-v-if-的区别"><a href="#v-show-和-v-if-的区别" class="headerlink" title="v-show 和 v-if 的区别"></a>v-show 和 v-if 的区别</h3><p>v-show 原理是修改元素的 css 属性 display:none 来决定是显示还是隐藏</p>
<p>v-if 则是通过操作 DOM 来进行切换显示</p>
<h3 id="常用的指令？常用的内置组件有哪些？"><a href="#常用的指令？常用的内置组件有哪些？" class="headerlink" title="常用的指令？常用的内置组件有哪些？"></a>常用的指令？常用的内置组件有哪些？</h3><p>常用指令：<br>v-html v-text v-modal v-if v-show v-hide v-once v-on v-for v-slot v-pre</p>
<p>常用内置组件<br>transition 动画<br>keepAlive 多个组件动态切换时缓存被移除的组件实例</p>
<h3 id="Vue-修饰符有哪些"><a href="#Vue-修饰符有哪些" class="headerlink" title="Vue 修饰符有哪些"></a>Vue 修饰符有哪些</h3><p><strong>事件修饰符</strong></p>
<p>.stop 阻止事件继续传播<br>.prevent 阻止标签默认行为<br>.capture 使用事件捕获模式, 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理<br>.self 只当在 event.target 是当前元素自身时触发处理函数<br>.once 事件将只会触发一次<br>.passive 告诉浏览器你不想阻止事件的默认行为<br><strong>v-model 的修饰符</strong></p>
<p>.lazy 通过这个修饰符，转变为在 change 事件再同步<br>.number 自动将用户的输入值转化为数值类型<br>.trim 自动过滤用户输入的首尾空格<br><strong>键盘事件的修饰符</strong></p>
<p>.enter<br>.tab<br>.delete (捕获 “删除” 和“退格”键)<br>.esc<br>.space<br>.up<br>.down<br>.left<br>.right<br><strong>系统修饰键</strong></p>
<p>.ctrl<br>.alt<br>.shift<br>.meta<br><strong>鼠标按钮修饰符</strong></p>
<p>.left<br>.right<br>.middle</p>
<h3 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a>computed 和 watch 的区别</h3><h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><p>computed 有缓存，关联的 data 里面的响应式数据不变则不会重新计算，遇到双向绑定的属性值即 v-model 的属性值需要使用 get()和 set(),才能监听</p>
<ul>
<li><p>计算属性是基于它们的响应式依赖进行缓存的，只在相关响应式依赖发生改变时它们才会重新求值，也就是说只要 message 值不变，多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数</p>
</li>
<li><p>如果 message 值改变了，不依赖 message 的值，计算属性不会重新计算</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;num &#123;&#123;num&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;double1 &#123;&#123;double1&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;input v-model=<span class="string">"double2"</span>/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            num: <span class="number">20</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        double1() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.num * <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        double2: &#123;<span class="comment">//双向绑定的值需要使用get()和set()</span></span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.num * <span class="number">2</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>(val) &#123;</span><br><span class="line">                <span class="keyword">this</span>.num = val/<span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>计算属性的特点</strong></p>
</blockquote>
<ul>
<li>支持缓存，只有依赖数据发生改变，才会重新进行计算,否则只会执行一次</li>
<li>不支持异步，当 computed 内有异步操作时无效</li>
<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed</li>
<li>如果 computed 属性属性值是函数，那么默认会走 get() ；函数的返回值就是属性的属性值；在 computed 中的，属性都有一个 get() 和一个 set()，当数据变化时，调用 set()。</li>
</ul>
<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>监听引用类型需要深度监测，而且是拿不到 oldVal，值类型不需要深度监听<br>其可以监听的数据来源：data，props，computed 内的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input v-model=<span class="string">"name"</span>/&gt;</span><br><span class="line">        &lt;input v-model=<span class="string">"info.city"</span>/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: <span class="string">'小宋'</span>,</span><br><span class="line">            info: &#123;</span><br><span class="line">                city: <span class="string">'北京'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        name(oldVal, val) &#123;</span><br><span class="line">            <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'watch name'</span>, oldVal, val) <span class="comment">// 值类型，可正常拿到 oldVal 和 val</span></span><br><span class="line">        &#125;,</span><br><span class="line">        info: &#123;</span><br><span class="line">            handler(oldVal, val) &#123;</span><br><span class="line">                <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'watch info'</span>, oldVal, val) <span class="comment">// 引用类型，拿不到 oldVal 。因为指针相同，此时已经指向了新的 val</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 强制立即执行回调</span></span><br><span class="line">            immediate: <span class="literal">true</span>,</span><br><span class="line">            deep: <span class="literal">true</span> <span class="comment">// 深度监听</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>监听的特点</strong></p>
</blockquote>
<ul>
<li>主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，可以看作是 computed 和 methods 的结合体；</li>
<li>可以监听的数据来源：data，props，computed 内的数据；</li>
<li>watch 支持异步；</li>
<li>不支持缓存，监听的数据改变，直接会触发相应的操作；</li>
<li>监听函数有两个参数，第一个参数是最新的值，第二个参数是输入之前的值，顺序一定是新值，旧值。</li>
</ul>
<blockquote>
<p>计算属性一般用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。</p>
</blockquote>
<h3 id="v-if-与-v-for-为什么不建议一起使用"><a href="#v-if-与-v-for-为什么不建议一起使用" class="headerlink" title="v-if 与 v-for 为什么不建议一起使用"></a>v-if 与 v-for 为什么不建议一起使用</h3><p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级。这意味着 <code>v-if</code> 将分别重复运行于 每个 <code>v-for</code> 循环中，即先运行 <code>v-for</code> 的循环，然后在每一个 <code>v-for</code> 的循环中，再进行 <code>v-if</code> 的条件对比，会造成性能问题，影响速度。</p>
<p>解决这个问题的方法是:</p>
<ul>
<li>可以使用<code>计算属性</code>将数据提前过滤</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  activeUsers() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.users.filter(<span class="function">(<span class="params">user</span>) =&gt;</span> user.isActive)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以使用 <code>&lt;template&gt;</code> 元素，在 <code>&lt;template&gt;</code> 元素上使用 <code>v-if</code>，然后将 <code>v-for</code> 放在 <code>&lt;template&gt;</code> 元素上</li>
</ul>
<h3 id="v-model-原理"><a href="#v-model-原理" class="headerlink" title="v-model 原理"></a>v-model 原理</h3><p>v-model 只是语法糖而已</p>
<p>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>
<p>text 和 textarea 元素使用 value property 和 input 事件；<br>checkbox 和 radio 使用 checked property 和 change 事件；<br>select 字段将 value 作为 prop 并将 change 作为事件。<br>注意: 对于需要使用输入法（如中文、日文、韩文等）的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。</p>
<h3 id="vue-自定义指令设置"><a href="#vue-自定义指令设置" class="headerlink" title="vue 自定义指令设置"></a>vue 自定义指令设置</h3><ul>
<li>全局: Vue.directive(‘指令名称，不需要写 v-开头’,对象或函数)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">"test"</span>, &#123;</span><br><span class="line">  bind(el, bind) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(el);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Vue.directive(<span class="string">"red"</span>, &#123;</span><br><span class="line">  <span class="comment">// bind 第一次绑定到元素时调用</span></span><br><span class="line">  bind(el, bindings) &#123;</span><br><span class="line">    el.style.cssText = <span class="string">`color:red;font-size:30px`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>私有<br>在组件中的</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	directives: &#123;</span><br><span class="line">		test:&#123;</span><br><span class="line">			bind(el,bind)&#123;&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">// bind/update</span></span><br><span class="line">		test2(el,bind)&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义局部指令，只有当前的实例能用</span></span><br><span class="line">directives: &#123;</span><br><span class="line">    red: &#123;</span><br><span class="line">        <span class="comment">// bind它还没有绑定到父元素中,初始化</span></span><br><span class="line">        bind(el) &#123;</span><br><span class="line">            el.style.cssText = <span class="string">`color:red;font-size:30px`</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Vue-mixin-的使用场景和原理"><a href="#Vue-mixin-的使用场景和原理" class="headerlink" title="Vue.mixin 的使用场景和原理"></a>Vue.mixin 的使用场景和原理</h3><p>在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立，可以通过 Vue 的 mixin 功能抽离公共的业务逻辑，原理类似 “对象的继承”，当组件初始化时会调用 mergeOptions 方法进行合并，采用策略模式针对不同的属性进行合并。当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行 “合并”。</p>
<h3 id="nextTick-使用场景和原理"><a href="#nextTick-使用场景和原理" class="headerlink" title="nextTick 使用场景和原理"></a>nextTick 使用场景和原理</h3><p>nextTick 中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法。</p>
<p><strong>nexttick使用场景</strong><br>1.获取数据更新之后的DOM<br>2.created()中进行DOM操作<br>3.获取元素宽度</p>
<p>看例子，比如当 <code>DOM</code> 内容改变后，我们需要获取最新的高度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; name &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.clientHeight) <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"沐华"</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.clientHeight) <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.clientHeight) <span class="comment">// 18</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Vue-set-方法原理"><a href="#Vue-set-方法原理" class="headerlink" title="Vue.set 方法原理"></a>Vue.set 方法原理</h3><p>了解 Vue 响应式原理的同学都知道在两种情况下修改数据 Vue 是不会触发视图更新的</p>
<ol>
<li><p>在实例创建之后添加新的属性到实例上（给响应式对象新增属性）</p>
</li>
<li><p>直接更改数组下标来修改数组的值</p>
</li>
</ol>
<p>Vue.set 或者说是 $set 原理如下</p>
<p>因为响应式数据 我们给对象和数组本身都增加了<strong>ob</strong>属性，代表的是 Observer 实例。当给对象新增不存在的属性 首先会把新的属性进行响应式跟踪 然后会触发对象<strong>ob</strong>的 dep 收集到的 watcher 去更新，当修改数组索引时我们调用数组本身的 splice 方法去更新数组</p>
<h3 id="父子组件之间的通信"><a href="#父子组件之间的通信" class="headerlink" title="父子组件之间的通信"></a>父子组件之间的通信</h3><p><strong>父传子</strong>：通过 props 来传递<br>父组件(:变量名) -&gt; 子组件([props])来接收</p>
<ul>
<li>父组件访问子组件的数据和方法：<br>通过 <code>$refs</code> 或者 <code>$children</code> 访问子组件的属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;cpn ref=<span class="string">"twoChildrenRef"</span>&gt;&lt;<span class="regexp">/cpn&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ this.$refs.twoChildrenRef.子组件数据</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ this.$refs.twoChildrenRef.子组件方法</span></span><br></pre></td></tr></table></figure>
<p><strong>子传父</strong>：$emit/$on<br>子组件($emit(‘事件名’，值)) -&gt; 父组件(@事件名=’aa’,aa(传递的值))来接收</p>
<ul>
<li>子组件访问父组件的数据和方法:</li>
</ul>
<p>在子组件直接使用 <code>this.$parent</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$parent.name; </span><br><span class="line"><span class="keyword">this</span>.$parent.方法名();</span><br></pre></td></tr></table></figure>
<p><strong>兄弟组件</strong>：创建一个事件中心</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Hub = <span class="keyword">new</span> Vue()</span><br><span class="line">Hub.$emit(<span class="string">'change'</span>, 值) <span class="comment">// Hub触发事件</span></span><br><span class="line">Hub.$on(<span class="string">'change'</span>, ()=&gt;&#123;</span><br><span class="line">  <span class="comment">// Hub接收事件</span></span><br><span class="line">  <span class="keyword">this</span>.msg = 值</span><br><span class="line">&#125;)</span><br><span class="line">通过Hub.$off()方法名销毁之后无法进行传递数据</span><br></pre></td></tr></table></figure>
<p>详细介绍：<a href="http://shuy.cc/2019/04/27/jc-6/" target="_blank" rel="noopener">http://shuy.cc/2019/04/27/jc-6/</a></p>
<p><strong>Vuex</strong>：专门为Vue开发的用于管理应用状态的库，使Vue的状态能按照可预期的方式来进行管理。</p>
<h3 id="路由跳转的方式，传参方式有哪些？"><a href="#路由跳转的方式，传参方式有哪些？" class="headerlink" title="路由跳转的方式，传参方式有哪些？"></a>路由跳转的方式，传参方式有哪些？</h3><p>1). 标签</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">"&#123;name: '路由名'&#125;"</span></span><br></pre></td></tr></table></figure>
<p>2). 动态路由<br>App.vue</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">"'/user/' + userId"</span>&gt;用户&lt;<span class="regexp">/router-link&gt;</span></span><br></pre></td></tr></table></figure>
<p>router.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">"/user/:userId"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">"&#123;name: 'users', params: &#123;id: 12&#125;&#125;"</span>&gt;用户&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">this.$route.push(&#123;name: 'users', params: &#123;id: 12&#125;&#125;)</span></span><br><span class="line"><span class="regexp">this.$route.push('/u</span>ser/<span class="number">12</span><span class="string">')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 获取：$route.params.id</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">"&#123;path: '/profile', query: &#123;id: 12&#125;&#125;"</span>&gt;档案&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;router-link :to="&#123;name: '/u</span>sers<span class="string">', query: &#123;id: 12&#125;&#125;"&gt;档案&lt;/router-link&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">aa() &#123;</span></span><br><span class="line"><span class="string">  this.$router.push(&#123;</span></span><br><span class="line"><span class="string">    path: '</span>/profile<span class="string">',</span></span><br><span class="line"><span class="string">    query: &#123;</span></span><br><span class="line"><span class="string">      name: '</span>yaoyao<span class="string">',</span></span><br><span class="line"><span class="string">      id: 12</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 获取：$route.query.id</span></span><br></pre></td></tr></table></figure>
<h3 id="router-和-route-的区别"><a href="#router-和-route-的区别" class="headerlink" title="router 和 route 的区别"></a>router 和 route 的区别</h3><ul>
<li>$route 对象<br>表示当前的所有的路由信息，包括路径，参数，query 对象等</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">"../views/layout/Layout"</span>;</span><br><span class="line"><span class="keyword">const</span> asyncRoutes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">"/product-define"</span>,</span><br><span class="line">    component: Layout,</span><br><span class="line">    redirect: <span class="string">"/product-define/"</span>,</span><br><span class="line">    name: <span class="string">"ProductDefineManagement"</span>,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: <span class="string">"产品定义定价"</span>,</span><br><span class="line">      icon: <span class="string">"icon-dingyidingjia"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">"CarType"</span>,</span><br><span class="line">        name: <span class="string">"CarType"</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"@/views/product_define/CarType"</span>),</span><br><span class="line">        meta: &#123; <span class="attr">title</span>: <span class="string">"车型"</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>$route.path 路径<br>$route.params 一个 key: val 对象<br>$route.query 一个 key: val 对象<br>$route.hash #号后面的数据<br>$route.fullPath url，包含参数和 hash 完整路径<br>$route.matched 数组，常用作面包屑<br>$route.name 当前路由的名称<br>$route.meta 路由元信息，一些额外标注参数</p>
</blockquote>
<ul>
<li>$router 对象：是全局的路由实例。</li>
</ul>
<h3 id="编程式导航的使用方法"><a href="#编程式导航的使用方法" class="headerlink" title="编程式导航的使用方法"></a>编程式导航的使用方法</h3><p>1.<strong>路由的跳转</strong><br>this.$router.push()</p>
<ul>
<li><p>path 跳转方式，只可以用query传参</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push( &#123;<span class="attr">path</span>:<span class="string">'login'</span>, <span class="attr">query</span>: &#123; <span class="attr">userName</span>: <span class="string">'01testuser2'</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>name 跳转方式，可以用query和params传参</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push( &#123;<span class="attr">name</span>:<span class="string">'login'</span>, <span class="attr">query</span>: &#123; <span class="attr">userName</span>: <span class="string">'01testuser2'</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$router.push( &#123;<span class="attr">name</span>:<span class="string">'login'</span>, <span class="attr">params</span>: &#123; <span class="attr">userName</span>: <span class="string">'01testuser2'</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>query传参与params传参区别：query传参相当于get请求，在浏览器的url地址中会显示参数；params相当于post请求，在浏览器的地址栏中不显示。</p>
</blockquote>
<p>2.<strong>路由替换</strong><br>this.$router.replace()<br><strong><em>使用方法和 <code>this.$router.push()</code> 一样</em></strong><br>3.<strong>后退</strong><br>this$router.back()<br>4.<strong>前进</strong><br>this.$router.forward()<br>5.<strong>前进后退</strong><br>this.$router.go() -1 为后退<br>6.<strong>配置路由常用参数</strong></p>
<ul>
<li>path 路径</li>
<li>component 路由相对于组件的路径</li>
<li>name 路由的名称</li>
<li>children 嵌套路由的子组件的配置项</li>
<li>props 路由解耦</li>
<li>redirect 路由重定向</li>
</ul>
<h3 id="什么是路由守卫？路由的钩子函数有哪些？"><a href="#什么是路由守卫？路由的钩子函数有哪些？" class="headerlink" title="什么是路由守卫？路由的钩子函数有哪些？"></a>什么是路由守卫？路由的钩子函数有哪些？</h3><p>路由守卫：路由跳转前后的一些验证<br>路由钩子函数：</p>
<ul>
<li>beforeRouterEnter 当路由跳转之前（登录之前）</li>
<li>beforeRouterUpdate 当路由进行更新的时候，如果当前路由发生了变化，但是不需要组件进行销毁</li>
<li>beforeRouterLeave 当路由离开的时候（当用户没有支付离开的时候、当用户填写完用户信息没有保存的时候）</li>
<li>beforeEach 全局守卫，验证用户是否登录</li>
</ul>
<h3 id="vue-router-路由钩子函数是什么-执行顺序是什么"><a href="#vue-router-路由钩子函数是什么-执行顺序是什么" class="headerlink" title="vue-router 路由钩子函数是什么 执行顺序是什么"></a>vue-router 路由钩子函数是什么 执行顺序是什么</h3><p>路由钩子的执行流程, 钩子函数种类有: 全局守卫、路由守卫、组件守卫</p>
<p>完整的导航解析流程:</p>
<p>导航被触发。<br>在失活的组件里调用 beforeRouteLeave 守卫。<br>调用全局的 beforeEach 守卫。<br>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。<br>在路由配置里调用 beforeEnter。<br>解析异步路由组件。<br>在被激活的组件里调用 beforeRouteEnter。<br>调用全局的 beforeResolve 守卫 (2.5+)。<br>导航被确认。<br>调用全局的 afterEach 钩子。<br>触发 DOM 更新。<br>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</p>
<h3 id="能说下-vue-router-中常用的路由模式实现原理吗"><a href="#能说下-vue-router-中常用的路由模式实现原理吗" class="headerlink" title="能说下 vue-router 中常用的路由模式实现原理吗?"></a>能说下 vue-router 中常用的路由模式实现原理吗?</h3><p><strong>hash 模式</strong></p>
<p>location.hash 的值实际就是 URL 中 #后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。<br>可以为 hash 的改变添加监听事件<br>window.addEventListener(“hashchange”, funcRef, false);<br>每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录利用 hash 的以上特点，就可以来实现前端路由 “更新视图但不重新请求页面” 的功能了</p>
<blockquote>
<p>特点：兼容性好但是不美观</p>
</blockquote>
<p><strong>history 模式</strong></p>
<p>利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。</p>
<p>这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由 “更新视图但不重新请求页面” 提供了基础。</p>
<blockquote>
<p>特点：虽然美观，但是刷新会出现 404 需要后端进行配置</p>
</blockquote>
<h3 id="vuex-的理解"><a href="#vuex-的理解" class="headerlink" title="vuex 的理解"></a>vuex 的理解</h3><p>vuex 是专门为 vue 开发的一款状态管理库，主要采用集中管理应用所有的组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<ul>
<li>state 保存应用的<strong>全部状态</strong>的对象 this.$store.state(key)</li>
<li>Getter 其实就是 state 通过<strong>计算属性</strong>，衍变出的新的状态 this.$store.getters(key)</li>
<li>Mutation 包含一个字符窜名称和回调函数，必须是 <strong><em>同步函数</em></strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  name(state) &#123;</span><br><span class="line">    state.count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>它其实就是操作 <code>state</code> 的，它不能直接调用，这更像是一个事件注册，需要 <code>store.commit(&#39;name&#39;)</code>来调用对应的 <code>mutation</code></p>
</blockquote>
<ul>
<li>action 类似于 <code>mutation</code>,但是 <code>action</code> 提交的是 <code>mutation</code>，并且是 <strong><em>异步</em></strong> 的，使用 <code>commit(&#39;mutation 名&#39;)</code>来调用，action 使用 <code>dispatch</code> 来调用</li>
</ul>
<blockquote>
<p>在 main.js 引入 store，注入。新建了一个 store 目录，然后….. export 。<br>场景：单页应用中，组件之间的共享状态和方法 state Vuex 使用单一状态树,即每个应用将仅仅包含一个 store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。 </p>
<ul>
<li><strong>mutations</strong> 定义的方法动态修改 Vuex 的 store 中的状态或数据。 </li>
<li><strong>getters</strong> 类似 vue 的计算属性，主要用来过滤一些数据。 </li>
<li><strong>action</strong> 可以理解为通过将 mutations 里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。<br>view 层通过 store.dispath 来分发 action。 </li>
<li><strong>modules</strong> 项目特别复杂的时候，可以让每一个模块拥有自己的 state、mutation、action、getters,使得结构非常清晰，方便管理。</li>
</ul>
</blockquote>
<p>快速掌握 vuex 常用的所有 api 用法: <a href="http://shuy.cc/2019/07/24/vuex/" target="_blank" rel="noopener">http://shuy.cc/2019/07/24/vuex/</a></p>
<h3 id="Vuex-页面刷新数据丢失怎么解决"><a href="#Vuex-页面刷新数据丢失怎么解决" class="headerlink" title="Vuex 页面刷新数据丢失怎么解决"></a>Vuex 页面刷新数据丢失怎么解决</h3><p>需要做 vuex 数据持久化 一般使用本地存储的方案来保存数据 可以自己设计存储方案 也可以使用第三方插件</p>
<p>推荐使用 vuex-persist 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中</p>
<h3 id="Vuex-为什么要分模块并且加命名空间"><a href="#Vuex-为什么要分模块并且加命名空间" class="headerlink" title="Vuex 为什么要分模块并且加命名空间"></a>Vuex 为什么要分模块并且加命名空间</h3><p>模块: 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。</p>
<p>命名空间：默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名</p>
<h3 id="你有对-Vue-项目进行哪些优化？"><a href="#你有对-Vue-项目进行哪些优化？" class="headerlink" title="你有对 Vue 项目进行哪些优化？"></a>你有对 Vue 项目进行哪些优化？</h3><p>从 <strong><code>3个大方面</code></strong>，<strong><code>22个小方面</code></strong>详细讲解如何进行 Vue 项目的优化。<br><strong>（1）代码层面的优化</strong></p>
<ul>
<li>对象层级不要过深，否则性能就会差</li>
<li>不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）</li>
<li>v-if 和 v-show 区分使用场景</li>
<li>computed 和 watch 区分使用场景</li>
<li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li>
<li>长列表性能优化</li>
<li>事件的销毁</li>
<li>图片资源懒加载</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入</li>
<li>优化无限列表性能</li>
<li>服务端渲染 SSR or 预渲染</li>
<li>防止内部泄漏，组件销毁后把全局变量和事件销毁</li>
<li>防抖、节流运用</li>
</ul>
<p><strong>（2）Webpack 层面的优化</strong></p>
<ul>
<li>Webpack 对图片进行压缩</li>
<li>减少 ES6 转为 ES5 的冗余代码</li>
<li>提取公共代码</li>
<li>模板预编译</li>
<li>提取组件的 CSS</li>
<li>优化 SourceMap</li>
<li>构建结果输出分析</li>
<li>Vue 项目的编译优化</li>
</ul>
<p><strong>（3）基础的 Web 技术的优化</strong></p>
<ul>
<li>开启 gzip 压缩</li>
<li>浏览器缓存</li>
<li>CDN 的使用</li>
<li>使用 Chrome Performance 查找性能瓶颈</li>
</ul>
<h3 id="使用过-Vue-SSR-吗？说说-SSR"><a href="#使用过-Vue-SSR-吗？说说-SSR" class="headerlink" title="使用过 Vue SSR 吗？说说 SSR"></a>使用过 Vue SSR 吗？说说 SSR</h3><p>SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。</p>
<p>优点：</p>
<p>SSR 有着更好的 SEO、并且首屏加载速度更快</p>
<p>缺点： 开发条件会受到限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境。</p>
<p>服务器会有更大的负载需求</p>
<h3 id="登陆权限的实现"><a href="#登陆权限的实现" class="headerlink" title="登陆权限的实现"></a>登陆权限的实现</h3><h4 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h4><p>在登陆页面，前端需要进行表单校验，通过前端校验，过滤拦截一些不符合规则的参数请求，然后调用后端的提供登陆接口，将符合规则的参数传递给后端，后端接受到请求后，会获取这个请求携带的参数，这些参数通常会有用户名、密码一级验证码、然后来验证这些参数，如果验证不通过，前端将后端提供的错误提示提示给用户即可，如果验证通过，那么就会生成一个 token，并且返回给前端，前端接受到这个 token 之后，需要将这个 token 保存在本地，在我们下次去调用需要携带 token 的接口时，通常会将这个 token 塞入到请求头中，一并发送给后端，那么将 token 添加到请求头中，我们通常会去封装一个请求方法，在这个请求方法中完成给请求头添加 token 的操作，我们在本地保存 token，是因为有的页面是需要登录才可以进入的，那么我们就可以通过路由守卫来判断当前本地有没有 token，如果没有 token 就跳转到登录页面，如果你的项目做了 token 过期之后会自动刷新这个 token，然后继续完成请求这么一个功能，那么就更好了，</p>
<h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>路由控制的核心包含用户、角色、菜单，用户和角色具备某种关联关系，而角色和菜单具备某种关联关系，所以用户和菜单会通过角色产生关联关系，那对应到后台页面上，首先我们会创建好菜单，然后在创建角色，在创建角色的时候，可以给角色分配菜单，最好当创建用户账号时，就可以给这个用户分配角色，那么当登陆该账号的时候，前端会请求一次后端提供的返回了用户所具备菜单列表的数据接口，然后在前端代码定义路由时，我们会维护两份路由，一份是静态路由，他是所有用户都可以访问的路由，直接挂载在路由实例上即可，还有一份是动态路由，这份路由会根据当前用户所具备的菜单进行筛选 asyncRoutes.forEach((item)=&gt;{<br>If(menus.find(menu))<br>})<br>最后筛选出的路由，通过 addRoute 这个方法，动态添加上去，这一步通常会在路由守卫中完成（router.beforeEach）,遍历这份动态路由（asyncRoutes.forEach），判断当前遍历项是否存在于后端返回的菜单列表中，那返回一个筛选完成的路由数组，最后我们就可以用这份路由数组去渲染菜单栏了。</p>
<h3 id="vue2-0-和-vue3-0-的区别"><a href="#vue2-0-和-vue3-0-的区别" class="headerlink" title="vue2.0 和 vue3.0 的区别"></a>vue2.0 和 vue3.0 的区别</h3><ul>
<li>响应式原理</li>
<li>模板编译</li>
<li>生命周期</li>
<li>组件</li>
<li>性能优化</li>
</ul>
<h2 id="小程序相关"><a href="#小程序相关" class="headerlink" title="小程序相关"></a>小程序相关</h2><h3 id="微信的小程序的主要文件"><a href="#微信的小程序的主要文件" class="headerlink" title="微信的小程序的主要文件"></a>微信的小程序的主要文件</h3><ul>
<li>WXML——模板文件</li>
<li>WXSS——样式文件，样式可直接用import导入</li>
<li>JS——脚本逻辑文件，逻辑处理，网络请求</li>
<li>app.json——配置文件入口，整个小程序的全局配置，网络超时时间、底部tab、页面路径，window字段是小程序所有页面的顶部背景颜色、文字颜色</li>
<li>app.js——可以没有内容，可以在里边监听生命周期函数、声明全局变量</li>
<li>app.wxss——全局配置样式文件</li>
</ul>
<h3 id="小程序中如何进行接口请求？会不会跨域，为什么"><a href="#小程序中如何进行接口请求？会不会跨域，为什么" class="headerlink" title="小程序中如何进行接口请求？会不会跨域，为什么"></a>小程序中如何进行接口请求？会不会跨域，为什么</h3><p>微信小程序有自带的api接口，wx.request();<br>不会跨域，因为微信小程序不是浏览器，没有同源策略的约束；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">  url: <span class="string">'https://xxxxxxx.com/api'</span>,</span><br><span class="line">  method: <span class="string">"POST"</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    pageNum: <span class="number">1</span>,</span><br><span class="line">    pageSize: <span class="number">10</span></span><br><span class="line">  &#125;,</span><br><span class="line">  header: &#123;</span><br><span class="line">    <span class="string">"content-type"</span>: <span class="string">"application/x-www-form-urlencoded"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="小程序的常用命令有哪些"><a href="#小程序的常用命令有哪些" class="headerlink" title="小程序的常用命令有哪些"></a>小程序的常用命令有哪些</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">引用数据 <span class="string">`&#123;&#123;&#125;&#125;`</span></span><br><span class="line">逻辑渲染 <span class="string">`wx:if wx:elif wx:else hidden`</span></span><br><span class="line">列表渲染 <span class="string">`wx:for wx:for-item wx:for-index wx:key`</span>，使用 <span class="string">`wx:for-item`</span> 指定数组当前元素的变量名，使用 <span class="string">`wx:for-index`</span> 指定数组当前下标的变量名。</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;array&#125;&#125;"</span> <span class="attr">wx:for-index</span>=<span class="string">"idx"</span> <span class="attr">wx:for-item</span>=<span class="string">"itemName"</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">驱动视图 <span class="string">`this.setData(&#123;&#125;)`</span></span><br><span class="line">事件绑定 <span class="string">`bind`</span></span><br></pre></td></tr></table></figure>
<h3 id="生命周期函数有哪些？小程序的周期函数？"><a href="#生命周期函数有哪些？小程序的周期函数？" class="headerlink" title="生命周期函数有哪些？小程序的周期函数？"></a>生命周期函数有哪些？小程序的周期函数？</h3><p>生命周期函数：<br>onLoad 监听页面加载，一个页面只调用 1 次<br>onReady 监听页面初次渲染完成，一个页面只调用 1 次<br>onShow 监听页面显示<br>onHide 监听页面隐藏<br>onUnLoad 监听页面卸载<br>小程序周期函数：<br>onLaunch 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）。可以做一些初始化的工作<br>onShow 当小程序启动，或从后台进入前台显示，会触发 onShow<br>onHide 当小程序从前台进入后台，会触发 onHide</p>
<h3 id="应用与页面生命周期发生顺序"><a href="#应用与页面生命周期发生顺序" class="headerlink" title="应用与页面生命周期发生顺序"></a>应用与页面生命周期发生顺序</h3><p>小程序中的生命周期函数，分为 应用生命周期函数 和 页面生命周期函数 ；</p>
<p>应用 onLaunch -&gt; 应用 onShow -&gt; 页面 page -&gt; onLoad -&gt; onShow -&gt; onReady -&gt; onUnload</p>
<p>App.js是小程序入口文件，所以在App.js中调用<strong>应用生命周期函数</strong>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">    <span class="comment">// 小程序初始化完成时，执行此函数，可以做一些初始化的工作</span></span><br><span class="line">    onLaunch: <span class="function"><span class="keyword">function</span>(<span class="params"> options </span>)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 小程序显示到屏幕上的时候，执行此函数</span></span><br><span class="line">    onShow: <span class="function"><span class="keyword">function</span>(<span class="params"> options </span>)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 小程序被最小化的时候，执行此函数</span></span><br><span class="line">    onHide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>页面生命周期函数</strong></p>
<ul>
<li>onLoad: 监听页面加载</li>
<li>onShow: 监听页面显示</li>
<li>onReady: 监听页面初次渲染完成</li>
<li>onHide: 监听页面影藏</li>
<li>onUnload: 监听页面卸载</li>
</ul>
<h3 id="小程序和Vue写法的区别"><a href="#小程序和Vue写法的区别" class="headerlink" title="小程序和Vue写法的区别"></a>小程序和Vue写法的区别</h3><ul>
<li>数据绑定：小程序是wx:bind，vue是v-bind</li>
<li>事件绑定：小程序是bind，vue是@</li>
<li>样式绑定：小程序是wx:class，vue是:class</li>
<li>循环遍历：小程序是wx:for，vue是v-for</li>
<li>调用data模型：小程序是this.data.unifo，vue是this.unifo</li>
<li>给模型赋值：小程序是this.setData({unifo:1}</li>
</ul>
<h3 id="小程序是如何传值？"><a href="#小程序是如何传值？" class="headerlink" title="小程序是如何传值？"></a>小程序是如何传值？</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindTap</span>=<span class="string">"get"</span> <span class="attr">id</span>=<span class="string">"123"</span> <span class="attr">data-name</span>=<span class="string">"按钮名"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>(e) &#123;</span><br><span class="line">  <span class="keyword">let</span> id = e.currentTarget.id</span><br><span class="line">  <span class="keyword">let</span> name = e.currentTarget.dataset.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小程序如何进行页面的跳转传参以及接收数据"><a href="#小程序如何进行页面的跳转传参以及接收数据" class="headerlink" title="小程序如何进行页面的跳转传参以及接收数据"></a>小程序如何进行页面的跳转传参以及接收数据</h3><p>最常用的两个页面的跳转和传参方式：<br>①wx.navigateTo<br>②navigator标签</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wx.navigateTo(&#123;</span><br><span class="line">     url: <span class="string">`/pages/details?id=<span class="subst">$&#123;xxx&#125;</span>`</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&lt;navigator url=<span class="string">"/page/navigate/navigate?title=navigate"</span> hover-<span class="class"><span class="keyword">class</span></span>=<span class="string">"navigator-hover"</span>&gt;跳转到新页面&lt;<span class="regexp">/navigator&gt;</span></span><br></pre></td></tr></table></figure>
<p>跳转页接收参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onLoad (options) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(options)</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      goodsId:options.id,</span><br><span class="line">      goodsName:options.name</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他方式：</p>
<ul>
<li><p>wx.switchTab() 用来 跳转至tabBar页面，并关闭其他所有非 tabBar 页面</p>
</li>
<li><p>wx.redirectTo() 和 wx.navigateTo() 一样，都 跳转至非tabBar页面，但会关闭当前页面</p>
</li>
<li><p>wx.reLaunch() 也是 跳转至非tabBar页面，并且会关闭其他所有页面</p>
</li>
<li><p>wx.navigateBack() 用来返回上一页面或多级页面，并关闭当前页面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.navigateBack(&#123;</span><br><span class="line">  delta: <span class="number">2</span> <span class="comment">//返回的页面数，1为返回上一页，如果delta大于现有页面数，则返回到首页。</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="wxss-和-css-的区别"><a href="#wxss-和-css-的区别" class="headerlink" title="wxss 和 css 的区别"></a>wxss 和 css 的区别</h3><p>1px = 2rpx</p>
<ul>
<li>wxss 背景图只能引入外联，不能使用本地图片</li>
<li>小程序使用@important 引入外链样式，地址为相对路径</li>
<li>单位为 rpx，是响应式像素，可根据屏幕宽度做自适应</li>
</ul>
<h3 id="小程序是如何传递数据？"><a href="#小程序是如何传递数据？" class="headerlink" title="小程序是如何传递数据？"></a>小程序是如何传递数据？</h3><ul>
<li>在 app.js 中，this.globalData={}中存放数据，在组件.js 中，头部引入 const app = getApp(),来获取全局变量，直接使用 app.globalData.key 来获取变量</li>
<li>使用路由，wx.navigation/redircetTo/url+参数等方式，在页面 onLoad(e),通过 e.key 来获取参数</li>
<li>本地缓存，如 storage 等存储数据</li>
</ul>
<h3 id="小程序如何进行本地存储？"><a href="#小程序如何进行本地存储？" class="headerlink" title="小程序如何进行本地存储？"></a>小程序如何进行本地存储？</h3><p>小程序提供了读写本地数据缓存的接口，通过 wx.getStorage/wx.getStorageSync读取本地缓存，通过 wx.setStorage/wx.setStorageSync写数据到缓存，其中带Sync后缀的接口表示是同步接口<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步存储</span></span><br><span class="line">wx.setStorageSync(<span class="string">'key'</span>, <span class="string">'value'</span>)</span><br><span class="line"><span class="comment">// 异步存储，并且开启加密存储</span></span><br><span class="line">wx.setStorage(&#123;</span><br><span class="line">  key: <span class="string">"key"</span>,</span><br><span class="line">  data: <span class="string">"value"</span>,</span><br><span class="line">  encrypt: <span class="literal">true</span>, <span class="comment">// 若开启加密存储，setStorage 和 getStorage 需要同时声明 encrypt 的值为 true</span></span><br><span class="line">  success() &#123;</span><br><span class="line">    wx.getStorage(&#123;</span><br><span class="line">      key: <span class="string">"key"</span>,</span><br><span class="line">      encrypt: <span class="literal">true</span>, <span class="comment">// 若开启加密存储，setStorage 和 getStorage 需要同时声明 encrypt 的值为 true</span></span><br><span class="line">      success(res) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res.data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 同步读取缓存</span></span><br><span class="line"><span class="keyword">var</span> value = wx.getStorageSync(<span class="string">'key'</span>)</span><br><span class="line"><span class="comment">// 异步读取缓存</span></span><br><span class="line">wx.getStorage(&#123;</span><br><span class="line">  key: <span class="string">'key'</span>,</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="谈谈你对微信小程序请求封装的理解"><a href="#谈谈你对微信小程序请求封装的理解" class="headerlink" title="谈谈你对微信小程序请求封装的理解"></a>谈谈你对微信小程序请求封装的理解</h3><p>在小程序开发过程中,我们可能会进行许多的网络请求,如果每次请求都去写一遍 <code>request</code> 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">  url: <span class="string">'xxx'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="string">''</span>,</span><br><span class="line">    b: <span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line">  header: &#123;</span><br><span class="line">    <span class="string">'content-type'</span>: <span class="string">'application/json'</span> <span class="comment">// 默认值</span></span><br><span class="line">  &#125;,</span><br><span class="line">  success(res) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.data)</span><br><span class="line">  &#125;,</span><br><span class="line">  fail(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>效率低下且不便于维护，所以封装一下 wx.request 接口还是有必要的。</p>
<p>通常以返回 promise 对象的形式进行请求的封装：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baseUrl = <span class="string">"123456.com"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">method, url, dataObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> header = &#123;</span><br><span class="line">            <span class="string">'content-type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        wx.request(&#123;</span><br><span class="line">            url: baseURL + url,</span><br><span class="line">            method: method,</span><br><span class="line">            data: dataObj.data,</span><br><span class="line">            header: dataObj.header||header,</span><br><span class="line">            success(res) &#123;</span><br><span class="line">                <span class="comment">//请求成功</span></span><br><span class="line">                <span class="keyword">if</span> (res.code == <span class="number">0</span>) &#123;</span><br><span class="line">                    resolve(res);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//其他异常</span></span><br><span class="line">                    reject(<span class="string">'运行时错误,请稍后再试'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            fail(err) &#123;</span><br><span class="line">                <span class="comment">//请求失败</span></span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="webview-的理解"><a href="#webview-的理解" class="headerlink" title="webview 的理解"></a>webview 的理解</h3><p>在小程序中嵌套 H5 页面，域名必须在白名单里面</p>
<h3 id="小程序和-h5-页面的交互"><a href="#小程序和-h5-页面的交互" class="headerlink" title="小程序和 h5 页面的交互"></a>小程序和 h5 页面的交互</h3><p><a href="http://shuy.cc/2020/06/09/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%92%8Ch5%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BA%A4%E4%BA%92" target="_blank" rel="noopener">http://shuy.cc/2020/06/09/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%92%8Ch5%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BA%A4%E4%BA%92</a></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1.rpx，规定屏幕宽度为 750rpx，可适配不同的屏幕宽度<br>2.本地资源 wxss 无法获取，bgimg 可使用网络图片，base64,或者使用标签来引入<br>3.navigateTo，一个应用同时能发开 5 个页面或者使用 redirct</p>
<h3 id="小程序的双向绑定和-vue-的有什么区别"><a href="#小程序的双向绑定和-vue-的有什么区别" class="headerlink" title="小程序的双向绑定和 vue 的有什么区别"></a>小程序的双向绑定和 vue 的有什么区别</h3><p>小程序必须使用 this.setState({key:val})来更新数据，直接赋值不能更新页面变化</p>
<h3 id="下拉刷新的实现方法"><a href="#下拉刷新的实现方法" class="headerlink" title="下拉刷新的实现方法"></a>下拉刷新的实现方法</h3><p>app.json 中，将’enablePullDownFresh’: true,开启全局下拉刷新，组件.json 中，将’enablePullDownFresh’: true,开启单页下拉刷新，组件中的 onPullDownRefresh 写加载的逻辑，wx.stopPullDownRefresh()更新完数据，停止更新。</p>
<h3 id="跳转的方式有哪些"><a href="#跳转的方式有哪些" class="headerlink" title="跳转的方式有哪些"></a>跳转的方式有哪些</h3><ul>
<li>wx.navigateTo() 保留当前页，跳转到应用指定页面，不能跳转 tabar 页面</li>
<li>wx.redircetTo() 关闭当前页，跳转到应用指定页面，不能跳转 tabar 页面</li>
<li>wx.relaunch() 关闭所有页，打开到应用内的某个页面（应用场景：登陆跳转到其他页面）</li>
<li>wx.switchTo() 跳转到 tabbar 页面，关闭其他非 tabar 页面</li>
<li>wx.navigateBack() 关闭当前页，返回上一级或多级页面，可通过 getCurrentPages()获取当前的页面栈，决定要返回第几层</li>
</ul>
<h3 id="描述一下小程序的登陆流程"><a href="#描述一下小程序的登陆流程" class="headerlink" title="描述一下小程序的登陆流程"></a>描述一下小程序的登陆流程</h3><p>点击登陆按钮 -&gt; 调用微信登陆程序接口 wx.login,获取 code(有效期 5 分钟) -&gt; 后台使用 code、appid,appSercrent 获取 openid、session-key,然后生成 token 返回给前端 -&gt; 前端保存 token，便于之后的业务请求</p>
<h3 id="wx-if-和-hidden-的区别，如何使用？"><a href="#wx-if-和-hidden-的区别，如何使用？" class="headerlink" title="wx:if 和 hidden 的区别，如何使用？"></a>wx:if 和 hidden 的区别，如何使用？</h3><p>wx:if 有更高的切换消耗<br>hidden 有更高的初始渲染消耗<br>页面数据切换使用 hidden,运行条件变化使用 wx:if</p>
<h3 id="app-json-的配置项"><a href="#app-json-的配置项" class="headerlink" title="app.json 的配置项"></a>app.json 的配置项</h3><p>pages 存放小程序所有 pages 的路径<br>window 小程序所有页面的顶部、背景颜色，文字 tabbar 等的设置<br>tabBar 设置底部导航，最多 5 个，最少 2 个</p>
<h3 id="微信小程序中的数据渲染与浏览器中有什么不同"><a href="#微信小程序中的数据渲染与浏览器中有什么不同" class="headerlink" title="微信小程序中的数据渲染与浏览器中有什么不同"></a>微信小程序中的数据渲染与浏览器中有什么不同</h3><p>浏览器中渲染是单线程的;</p>
<p>而在小程序中的运行环境分成渲染层和逻辑层， WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。</p>
<h3 id="你认为微信小程序的优点是什么，缺点是什么"><a href="#你认为微信小程序的优点是什么，缺点是什么" class="headerlink" title="你认为微信小程序的优点是什么，缺点是什么"></a>你认为微信小程序的优点是什么，缺点是什么</h3><p>优点：<br>①容易推广。在微信中，小程序拥有众多入口，且微信用户基数大，这些都有助于推广小程序；<br>②使用便捷。微信下拉即可打开小程序列表，点击即可使用小程序，不需要额外的安装操作等；<br>③体验良好。小程序不会像H5页面一样经常出现卡顿、延时、加载慢、权限不足等问题；<br>④成本更低，从开发成本到运营推广成本，小程序的花费仅为APP的十分之一。</p>
<p>缺点：<br>①单个包大小限制为2M，这导致无法开发大型的应用，采用分包最大是20M；<br>②需要像app一样审核上架，这点相对于H5的发布要麻烦一些；<br>③处处受微信限制。例如不能直接分享到朋友圈，涉及到积分，或者虚拟交易的时候，小程序也是不允许的。</p>
<h3 id="如何优化首次加载小程序的速度"><a href="#如何优化首次加载小程序的速度" class="headerlink" title="如何优化首次加载小程序的速度"></a>如何优化首次加载小程序的速度</h3><p><strong>包体积优化</strong></p>
<ul>
<li><p>分包加载（优先采用，大幅降低主包体积）。</p>
</li>
<li><p>图片优化（1.使用tinypng压缩图片素材； 2.服务器端支持，可采用webp格式）。</p>
</li>
<li><p>组件化开发（易维护）。</p>
</li>
<li><p>减少文件个数及冗余数据。</p>
</li>
</ul>
<p><strong>请求优化</strong></p>
<ul>
<li>关键数据尽早请求(onLoad()阶段请求,次要数据可以通过事件触发再请求)；整合请求数据，降低请求次数。</li>
<li>采用cdn缓存静态的接口数据（如判断用户登录状态，未登录则请求缓存接口数据），cdn稳定且就近访问速度快（针对加载总时长波动大）。</li>
<li>缓存请求的接口数据。</li>
</ul>
<p><strong>首次渲染优化</strong></p>
<ul>
<li>图片懒加载（节省带宽）。</li>
<li>setData优化（不要一次性设置过多的数据等）。</li>
<li>DOM渲染优化（减少DOM节点）</li>
</ul>
<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><h3 id="去重-1"><a href="#去重-1" class="headerlink" title="去重"></a>去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">22</span>, <span class="number">4</span>, <span class="number">444</span>, <span class="number">444</span>];</span><br><span class="line"><span class="comment">// 循环 + includes</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equal</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newArr = [arr[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newArr.includes(arr[i])) &#123;</span><br><span class="line">      newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(equal(arr));</span><br><span class="line"><span class="comment">// 双循环 判断是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equal</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newArr = [arr[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; newArr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newArr[j] === arr[i]) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(equal(arr));</span><br><span class="line"><span class="comment">// filter 过滤判断下标是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equal</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = arr.filter(<span class="function">(<span class="params">item, index, self</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> self.indexOf(item) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(equal(arr));</span><br><span class="line"><span class="comment">// es6的 set + from 转化类数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equal</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> setArr = <span class="keyword">new</span> <span class="built_in">Set</span>(arr);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">Array</span>.from(setArr);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(equal(arr));</span><br></pre></td></tr></table></figure>
<h3 id="快排算法"><a href="#快排算法" class="headerlink" title="快排算法"></a>快排算法</h3><p><strong>快速排序</strong>（Quick Sort）是一种常用的排序算法，其基本思想是分治法。它的主要步骤是:</p>
<ul>
<li>选择一个基准元素，将数组分为两个子数组，左边的元素都小于基准元素，右边的元素都大于基准元素。</li>
<li>然后对这两个子数组递归地应用快速排序。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left = <span class="number">0</span>, right = arr.length - <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">let</span> pivotIndex = partition(arr, left, right);</span><br><span class="line">    quickSort(arr, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pivot = arr[right];</span><br><span class="line">  <span class="keyword">let</span> i = left;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = left; j &lt; right; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">      [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  [arr[i], arr[right]] = [arr[right], arr[i]];</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(quickSort(arr)); <span class="comment">// 输出：[0, 1, 2, 3, 5, 6, 9]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr; <span class="comment">// 如果数组长度为1或者空数组，则直接返回</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>); <span class="comment">// 选择基准数的索引</span></span><br><span class="line">  <span class="keyword">let</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>]; <span class="comment">// 取出基准数</span></span><br><span class="line">  <span class="keyword">let</span> left = [];</span><br><span class="line">  <span class="keyword">let</span> right = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">      left.push(arr[i]); <span class="comment">// 小于基准数的放在左边数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.push(arr[i]); <span class="comment">// 大于等于基准数的放在右边数组</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归地对左右子数组进行排序，并将结果合并</span></span><br><span class="line">  <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> sortedArr = quickSort(arr);</span><br><span class="line"><span class="built_in">console</span>.log(sortedArr); <span class="comment">// 输出 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>];</span><br><span class="line"><span class="comment">// sort 排序</span></span><br><span class="line"><span class="keyword">let</span> result = arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// for 循环</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt;= arr.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">var</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">        arr[i + <span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="防抖、节流"><a href="#防抖、节流" class="headerlink" title="防抖、节流"></a>防抖、节流</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖动</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>fn 需要防抖执行的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>delay 多少毫秒不调用后执行一次,延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">fn, delay = <span class="number">500</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 存储定时器的timerId</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在每一次调用函数时，都清除上一次的定时器</span></span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    <span class="comment">// 开启一个定时器</span></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> **<span class="doctag">@param<span class="type">&#123;fn: function&#125;</span> </span>需要节流的函数</span></span><br><span class="line"><span class="comment"> **<span class="doctag">@param<span class="type">&#123;interval: number&#125;</span> </span>函数触发的频率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, interval</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 记录上一次触发函数时的时间，初始值为0</span></span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取现在的时间</span></span><br><span class="line">    <span class="keyword">const</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="comment">// 如果现在的时间减去上次触发的事件大于等于interval，则可以执行函数了</span></span><br><span class="line">    <span class="keyword">if</span> (nowTime - lastTime &gt;= interval) &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      <span class="comment">// 将上次触发函数的时间赋值成当前时间</span></span><br><span class="line">      lastTime = nowTimes;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>fn 方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>delay 每隔多少毫秒执行一次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, delay</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求数组的和</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// for 循环</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; array.length; index++) &#123;</span><br><span class="line">    result += array[index];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(arr));</span><br><span class="line"><span class="comment">// reduce 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = arr.reduce(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prev, cur, array);</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(arr));</span><br></pre></td></tr></table></figure>
<h3 id="数组转对象"><a href="#数组转对象" class="headerlink" title="数组转对象"></a>数组转对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">let data = [&#123;</span></span><br><span class="line"><span class="comment">  key: 'name',</span></span><br><span class="line"><span class="comment">  value : 'xiaosong'</span></span><br><span class="line"><span class="comment">&#125;, &#123;</span></span><br><span class="line"><span class="comment">  key: 'age',</span></span><br><span class="line"><span class="comment">  value : 12</span></span><br><span class="line"><span class="comment">&#125;]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">转||化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">let obj = &#123;</span></span><br><span class="line"><span class="comment">  name: 'xiaosong',</span></span><br><span class="line"><span class="comment">  age: 12</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  &#123;</span><br><span class="line">    key: <span class="string">"name"</span>,</span><br><span class="line">    value: <span class="string">"xiaosong"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    key: <span class="string">"age"</span>,</span><br><span class="line">    value: <span class="number">12</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setArr</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 写法1：</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; data.length; index++) &#123;</span><br><span class="line">    obj[data[index].key] = data[index].value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写法2：</span></span><br><span class="line">  data.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; key, value &#125; = item;</span><br><span class="line">    obj[key] = value;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(setArr());</span><br></pre></td></tr></table></figure>
<h3 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h3><p><strong><em>写一个类似于抢购的倒计时</em></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  开抢时间：&#123;&#123; date &#125;&#125;</span><br><span class="line">  &lt;Time1 :date=<span class="string">"date"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">data() &#123;</span></span><br><span class="line"><span class="regexp">  return &#123;</span></span><br><span class="line"><span class="regexp">    date: '2023/</span><span class="number">8</span>/<span class="number">29</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">00</span><span class="string">'</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;&#123; str &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">created() &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 将传入的时间字符串转化为时间戳</span></span><br><span class="line"><span class="regexp">  this.format(this.date)</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">methods: &#123;</span></span><br><span class="line"><span class="regexp">  format(date) &#123;</span></span><br><span class="line"><span class="regexp">    const that = this</span></span><br><span class="line"><span class="regexp">    setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 根据时间戳获取时分秒</span></span><br><span class="line"><span class="regexp">      const endTime = new Date(date).getTime()</span></span><br><span class="line"><span class="regexp">      const newTime = new Date().getTime()</span></span><br><span class="line"><span class="regexp">      const diffTime = (endTime - newTime) /</span> <span class="number">1000</span></span><br><span class="line">      <span class="keyword">var</span> day = <span class="built_in">parseInt</span>(diffTime / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>)</span><br><span class="line">      <span class="keyword">var</span> honur = <span class="built_in">parseInt</span>((diffTime / <span class="number">60</span> / <span class="number">60</span>) % <span class="number">24</span>)</span><br><span class="line">      <span class="keyword">var</span> min = <span class="built_in">parseInt</span>((diffTime / <span class="number">60</span>) % <span class="number">60</span>)</span><br><span class="line">      <span class="keyword">var</span> sen = <span class="built_in">parseInt</span>(diffTime % <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (diffTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        that.str = <span class="string">'开抢了！'</span></span><br><span class="line">        clearInterval(that.timer)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        that.str = day + <span class="string">'天 '</span> + honur + <span class="string">'小时 '</span> + min + <span class="string">'分 '</span> + sen + <span class="string">'秒'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>写一个显示当前时间的方法</em></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; time &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  this.timeFn()</span></span><br><span class="line"><span class="regexp">&#125;, 1000)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">timeFn() &#123;</span></span><br><span class="line"><span class="regexp">  let timeStr = new Date()</span></span><br><span class="line"><span class="regexp">  let year = timeStr.getFullYear()</span></span><br><span class="line"><span class="regexp">  let mounth = timeStr.getMonth() + 1</span></span><br><span class="line"><span class="regexp">  let day = timeStr.getDate()</span></span><br><span class="line"><span class="regexp">  let hour = timeStr.getHours()</span></span><br><span class="line"><span class="regexp">  let minu = timeStr.getMinutes()</span></span><br><span class="line"><span class="regexp">  let secon = timeStr.getSeconds()</span></span><br><span class="line"><span class="regexp">  if (mounth &lt; 10) &#123;</span></span><br><span class="line"><span class="regexp">    mounth = '0' + mounth</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  if (day &lt; 10) &#123;</span></span><br><span class="line"><span class="regexp">    day = '0' + day</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  if (hour &lt; 10) &#123;</span></span><br><span class="line"><span class="regexp">    hour = '0' + hour</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  if (minu &lt; 10) &#123;</span></span><br><span class="line"><span class="regexp">    minu = '0' + minu</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  if (secon &lt; 10) &#123;</span></span><br><span class="line"><span class="regexp">    secon = '0' + secon</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  this.time = `$&#123;year&#125;/</span>$&#123;mounth&#125;/$&#123;day&#125; $&#123;hour&#125;:$&#123;minu&#125;:$&#123;secon&#125;<span class="string">`</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h3 id="webpack-的打包原理、流程"><a href="#webpack-的打包原理、流程" class="headerlink" title="webpack 的打包原理、流程"></a>webpack 的打包原理、流程</h3><p>Webpack 是一个静态模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件；它可以很好地管理、打包开发中所用到的 HTML,CSS,JavaScript 和静态文件（图片，字体）等，让开发更高效；对于不同类型的依赖，Webpack 有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源。</p>
<p><img src="https://pic4.zhimg.com/80/v2-fc53c2795e3acee053090d439bfd196f_1440w.webp"></p>
<ol>
<li>读取命令行传入的参数<br>从 <code>package.json</code> 配置文件和 <code>shell</code> 命令中读取与合并参数</li>
<li>解析 webpack.config.js 配置文件<br>根据上一步得到的参数初始化 <code>Compiler</code> 对象，加载所有配置的 <code>Plugin</code> ，执行对象的 <code>run</code> 方法开始执行编译。</li>
<li>读取入口文件<br>根据配置中的 <code>entry</code> 找出所有的入口文件</li>
<li>调用 loader 进行编译<br>从入口文件触发，调用所有配置的 <code>Loader</code> 对模块进行翻译，再找出该模块依赖的模块，然后递归本步骤直到所有入口依赖的文件都进行翻译。使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</li>
<li>输出打包结果<br>根据依赖关系图，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转化成一个单独的文件加入到输出列表，根据配置确定输出的路径和文件名，输出。</li>
</ol>
<h3 id="webpack-区分不同的开发环境"><a href="#webpack-区分不同的开发环境" class="headerlink" title="webpack 区分不同的开发环境"></a>webpack 区分不同的开发环境</h3><h3 id="webpack-的基本配置，每个配置作用"><a href="#webpack-的基本配置，每个配置作用" class="headerlink" title="webpack 的基本配置，每个配置作用"></a>webpack 的基本配置，每个配置作用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> node_modules = path.resolve(__dirname, <span class="string">'node_modules'</span>);</span><br><span class="line"><span class="keyword">var</span> pathToReact = path.resolve(node_modules, <span class="string">'react/dist/react.min.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。</span></span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span>，</span><br><span class="line">  <span class="comment">// 文件路径指向(可加快打包过程)。</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'@'</span>: resolve(<span class="string">'src'</span>),</span><br><span class="line">      <span class="string">'react'</span>: pathToReact</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生成文件，是模块构建的终点，包括输出文件与输出路径。</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'build'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span>,</span><br><span class="line">        include: [</span><br><span class="line">          resolve(<span class="string">'src'</span>),</span><br><span class="line">          resolve(<span class="string">'test'</span>),</span><br><span class="line">          resolve(<span class="string">'mock'</span>),</span><br><span class="line">          resolve(<span class="string">'node_modules/webpack-dev-server/client'</span>)</span><br><span class="line">        ],</span><br><span class="line">        query: &#123;</span><br><span class="line">          presets: [<span class="string">'es2015'</span>, <span class="string">'react'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">        use: <span class="string">'url-loader'</span>,</span><br><span class="line">        exclude: [resolve(<span class="string">'src/icons'</span>)],</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: <span class="number">10000</span>,</span><br><span class="line">          name: utils.assetsPath(<span class="string">'img/[name].[hash:7].[ext]'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    noParse: [pathToReact]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// webpack 各插件对象，在 webpack 的事件流中执行对应的方法。</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Loader-Plugin-的区别"><a href="#Loader-Plugin-的区别" class="headerlink" title="Loader - Plugin 的区别"></a>Loader - Plugin 的区别</h3><h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p><code>Loader</code> 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。因为 <code>Webpack</code> 只认识 <code>JavaScript</code>，所以 <code>Loader</code> 就成了翻译官，对其他类型的资源进行转译的预处理工作。<br>默认情况下，在遇到 <code>import</code> 或者 <code>load</code> 加载模块的时候，<code>webpack</code> 只支持对 <code>js</code> 文件打包。像<code>css</code>、<code>sass</code>、<code>png</code>等这些类型的文件的时候，<code>webpack</code>则无能为力，这时候就需要配置对应的 <code>loader</code> 进行文件内容的解析。</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">"style-loader"</span> &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">"css-loader"</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              modules: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">"sass-loader"</span> &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a><strong>特性</strong></h5><p>从上述代码可以看到，在处理 css 模块的时候，use 属性中配置了三个 loader 分别处理 css 文件。因为 loader 支持链式调用，链中的每个 loader 会处理之前已处理过的资源，最终变为 js 代码。顺序为相反的顺序执行，即上述执行方式为 sass-loader、css-loader、style-loader。</p>
<p>除此之外，loader 的特性还有如下： - Loader 可以是同步的，也可以是异步的 - Loader 运行在 Node.js 中，并且能够执行任何操作 - 除了常见的通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块 - 插件(plugin)可以为 loader 带来更多特性 - Loader 能够产生额外的任意文件</p>
<p>可以通过 loader 的预处理函数，为 JavaScript 生态系统提供更多能力。用户现在可以更加灵活地引入细粒度逻辑，例如：压缩、打包、语言翻译和更多其他特性。</p>
<h5 id="常用-Loader"><a href="#常用-Loader" class="headerlink" title="常用 Loader"></a><strong>常用 Loader</strong></h5><p>在页面开发过程中，除了需要导入一些场景 js 文件外，还需要配置响应的 loader 进行加载。WebPack 常见的 Loader 如下：</p>
<ul>
<li><code>style-loader</code>：将 css 添加到 DOM 的内联样式标签 style 里，然后通过 dom 操作去加载 css。</li>
<li><code>css-loader</code>:允许将 css 文件通过 require 的方式引入，并返回 css 代码。</li>
<li><code>less-loader</code>: 处理 less，将 less 代码转换成 css。</li>
<li><code>sass-loader</code>: 处理 sass，将 scss/sass 代码转换成 css。</li>
<li><code>postcss-loader</code>：用 postcss 来处理 css。</li>
<li><code>autoprefixer-loader</code>: 处理 css3 属性前缀，已被弃用，建议直接使用 postcss。</li>
<li><code>file-loader</code>: 分发文件到 output 目录并返回相对路径。</li>
<li><code>url-loader</code>: 和 file-loader 类似，但是当文件小于设定的 limit 时可以返回一个 Data Url。</li>
<li><code>html-minify-loader</code>: 压缩 HTML</li>
<li><code>babel-loader</code> :用 babel 来转换 ES6 文件到 ES。</li>
<li><code>awesome-typescript-loader</code>：将 TypeScript 转换成 JavaScript，性能优于 ts-loader。</li>
<li><code>eslint-loader</code>：通过 ESLint 检查 JavaScript 代码。</li>
<li><code>tslint-loader</code>：通过 TSLint 检查 TypeScript 代码。</li>
<li><code>cache-loader</code>: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里</li>
</ul>
<p>下面以<code>css-loader</code>为例子，来说明 Loader 的使用过程。首先，我们在项目中安装<code>css-loader</code>插件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev css-loader</span><br></pre></td></tr></table></figure>
<p>然后将规则配置到<code>module.rules</code>中，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  ...,</span><br><span class="line"> &#123;</span><br><span class="line">  test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">      loader: <span class="string">"css-loader"</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">     <span class="comment">// 启用/禁用 url() 处理</span></span><br><span class="line">     url: <span class="literal">true</span>,</span><br><span class="line">     <span class="comment">// 启用/禁用 @import 处理</span></span><br><span class="line">     <span class="keyword">import</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 启用/禁用 Sourcemap</span></span><br><span class="line">        sourceMap: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h4><p><code>Plugin</code>就是插件，基于事件流框架<code>Tapable</code>，插件可以扩展 <code>Webpack</code> 的功能，在 <code>Webpack</code> 运行的生命周期中会广播出许多事件，<code>Plugin</code> 可以监听这些事件，在合适的时机通过 <code>Webpack</code> 提供的 <code>API</code> 改变输出结果。</p>
<p><code>Webpack</code>中的<code>Plugin</code>也是如此，<code>Plugin</code>赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 <code>Webpack</code> 的不同阶段（钩子 / 生命周期），贯穿了<code>Webpack</code>整个编译周期。</p>
<p><img src="https://pic1.zhimg.com/80/v2-259ab753c744667e125e59d7050ac104_1440w.webp"></p>
<h5 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>); <span class="comment">// 访问内置的插件</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.ProgressPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'./src/index.html'</span> &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="常见的-Plugin"><a href="#常见的-Plugin" class="headerlink" title="常见的 Plugin"></a>常见的 Plugin</h5><p>Weebpack 中，常见的 plugin 有如下一些：</p>
<ul>
<li><code>define-plugin</code>：定义环境变量 (Webpack4 之后指定 mode 会自动配置)</li>
<li><code>ignore-plugin</code>：忽略部分文件</li>
<li><code>html-webpack-plugin</code>：简化 HTML 文件创建 (依赖于 html-loader)</li>
<li><code>web-webpack-plugin</code>：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用</li>
<li><code>uglifyjs-webpack-plugin</code>：不支持 ES6 压缩 (Webpack4 以前)</li>
<li><code>terser-webpack-plugin</code>: 支持压缩 ES6 (Webpack4)</li>
<li><code>webpack-parallel-uglify-plugin</code>: 多进程执行代码压缩，提升构建速度</li>
<li><code>mini-css-extract-plugin</code>: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代 extract-text-webpack-plugin)</li>
<li><code>serviceworker-webpack-plugin</code>：为网页应用增加离线缓存功能</li>
<li><code>clean-webpack-plugin</code>: 目录清理 - ModuleConcatenationPlugin: 开启 Scope Hoisting</li>
<li><code>speed-measure-webpack-plugin</code>: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)</li>
<li><code>webpack-bundle-analyzer</code>: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)</li>
</ul>
<p>下面通过 clean-webpack-plugin 来看一下插件的使用方法。首先，需要安装 clean-webpack-plugin 插件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>然后，引入插件即可使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> ...</span><br><span class="line">  plugins: [</span><br><span class="line">    ...,</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。</p>
<p>Plugin 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>
<ul>
<li>Loader 运行在打包文件之前，Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。</li>
<li>Plugins 在整个编译周期都起作用，Plugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。</li>
</ul>
<h3 id="webpack-性能优化"><a href="#webpack-性能优化" class="headerlink" title="webpack 性能优化"></a>webpack 性能优化</h3><p>作为一个项目的打包构建工具，在完成项目开发后经常需要利用 Webpack 对前端项目进行性能优化，常见的优化手段有如下几个方面：</p>
<ul>
<li>JS 代码压缩</li>
<li>CSS 代码压缩</li>
<li>Html 文件代码压缩</li>
<li>文件大小压缩</li>
<li>图片压缩</li>
<li>Tree Shaking</li>
<li>代码分离</li>
<li>内联 chunk</li>
</ul>
<h4 id="JS-代码压缩"><a href="#JS-代码压缩" class="headerlink" title="JS 代码压缩"></a>JS 代码压缩</h4><p><code>terser</code> 是一个 <code>JavaScript</code> 的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让 <code>bundle</code> <code>更小。在production</code> 模式下，webpack 默认就是使用 <code>TerserPlugin</code> 来处理我们的代码的。如果想要自定义配置它，配置方法如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        minimize: <span class="literal">true</span>,</span><br><span class="line">        minimizer: [</span><br><span class="line">            <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">                parallel: <span class="literal">true</span>              <span class="comment">// 电脑cpu核数-1</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TerserPlugin 常用的属性如下：</p>
<ul>
<li>extractComments：默认值为 true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释</li>
<li>parallel：使用多进程并发运行提高构建的速度，默认值是 true，并发运行的默认数量： os.cpus().length - 1</li>
<li>terserOptions：设置我们的 terser 相关的配置：<br>compress：设置压缩相关的选项，<br>mangle：设置丑化相关的选项，可以直接设置为 true<br>mangle：设置丑化相关的选项，可以直接设置为 true<br>toplevel：底层变量是否进行转换<br>keep_classnames：保留类的名称<br>keep_fnames：保留函数的名称</li>
</ul>
<h4 id="CSS-代码压缩"><a href="#CSS-代码压缩" class="headerlink" title="CSS 代码压缩"></a>CSS 代码压缩</h4><p>CSS 压缩通常用于去除无用的空格等，不过因为很难去修改选择器、属性的名称、值等，所以我们可以使用另外一个插件：<code>css-minimizer-webpack-plugin</code>。配置如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CssMinimizerPlugin = <span class="built_in">require</span>(<span class="string">"css-minimizer-webpack-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="keyword">new</span> CssMinimizerPlugin(&#123;</span><br><span class="line">        parallel: <span class="literal">true</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Html-文件代码压缩"><a href="#Html-文件代码压缩" class="headerlink" title="Html 文件代码压缩"></a>Html 文件代码压缩</h4><p>使用<code>HtmlWebpackPlugin</code>插件来生成 HTML 的模板时候，可以通过配置属性<code>minify</code>进行<code>html</code>优化，配置如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    plugin:[</span><br><span class="line">        <span class="keyword">new</span> HtmlwebpackPlugin(&#123;</span><br><span class="line">            ...</span><br><span class="line">            minify:&#123;</span><br><span class="line">                minifyCSS:<span class="literal">false</span>, <span class="comment">// 是否压缩css</span></span><br><span class="line">                collapseWhitespace:<span class="literal">false</span>, <span class="comment">// 是否折叠空格</span></span><br><span class="line">                removeComments:<span class="literal">true</span> <span class="comment">// 是否移除注释</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文件大小压缩"><a href="#文件大小压缩" class="headerlink" title="文件大小压缩"></a>文件大小压缩</h4><p>对文件的大小进行压缩，可以有效减少 http 传输过程中宽带的损耗，文件压缩需要用到 <code>compression-webpack-plugin</code>插件，配置如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ComepressionPlugin(&#123;</span><br><span class="line">  test: <span class="regexp">/\.(css|js)$/</span>, <span class="comment">// 哪些文件需要压缩</span></span><br><span class="line">  threshold: <span class="number">500</span>, <span class="comment">// 设置文件多大开始压缩</span></span><br><span class="line">  minRatio: <span class="number">0.7</span>, <span class="comment">// 至少压缩的比例</span></span><br><span class="line">  algorithm: <span class="string">"gzip"</span>, <span class="comment">// 采用的压缩算法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h4><p>如果我们对 bundle 包进行分析，会发现图片等多媒体文件的大小是远远要比 <code>js</code>、<code>css</code> 文件要大的，所以图片压缩在打包方面也是很重要的。配置可以参考如下的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">"file-loader"</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">"[name]_[hash].[ext]"</span>,</span><br><span class="line">            outputPath: <span class="string">"images/"</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">"image-webpack-loader"</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            <span class="comment">// 压缩 jpeg 的配置</span></span><br><span class="line">            mozjpeg: &#123;</span><br><span class="line">              progressive: <span class="literal">true</span>,</span><br><span class="line">              quality: <span class="number">65</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 使用 imagemin**-optipng 压缩 png，enable: false 为关闭</span></span><br><span class="line">            optipng: &#123;</span><br><span class="line">              enabled: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 使用 imagemin-pngquant 压缩 png</span></span><br><span class="line">            pngquant: &#123;</span><br><span class="line">              quality: <span class="string">"65-90"</span>,</span><br><span class="line">              speed: <span class="number">4</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 压缩 gif 的配置</span></span><br><span class="line">            gifsicle: &#123;</span><br><span class="line">              interlaced: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式</span></span><br><span class="line">            webp: &#123;</span><br><span class="line">              quality: <span class="number">75</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h4><p>Tree Shaking<br>Tree Shaking 是一个术语，在计算机中表示消除死代码，依赖于 ES Module 的静态语法分析。在 webpack 实现 Trss shaking 有两种不同的方案： - usedExports：通过标记某些函数是否被使用，之后通过 Terser 来进行优化的 - sideEffects：跳过整个模块/文件，直接查看该文件是否有副作用</p>
<p>usedExports 的配置方法很简单，只需要将 usedExports 设为 true 即可，如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        usedExports</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 sideEffects 则用于告知 webpack compiler 在编译时哪些模块有副作用，配置方法是在 package.json 中设置 sideEffects 属性。如果 sideEffects 设置为 false，就是告知 webpack 可以安全的删除未用到的 exports，如果有些文件需要保留，可以设置为数组的形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"sideEffecis"</span>:[    <span class="string">"./src/util/format.js"</span>,    <span class="string">"*.css"</span> <span class="comment">// 所有的css文件]</span></span><br></pre></td></tr></table></figure>
<h4 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h4><p>默认情况下，所有的 JavaScript 代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度。如果可以分出出更小的 bundle，以及控制资源加载优先级，从而优化加载性能。</p>
<p>代码分离可以通过 splitChunksPlugin 来实现，该插件 webpack 已经默认安装和集成，只需要配置即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> ...</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        splitChunks:&#123;</span><br><span class="line">             chunks:<span class="string">"all"</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>splitChunks 有如下几个属性：</p>
<ul>
<li>Chunks：对同步代码还是异步代码进行处理</li>
<li>minSize： 拆分包的大小, 至少为 minSize，如何包的大小不超过 minSize，这个包不会拆分</li>
<li>maxSize： 将大于 maxSize 的包，拆分为不小于 minSize 的包 - minChunks：被引入的次数，默认是 1</li>
</ul>
<h4 id="内联-chunk"><a href="#内联-chunk" class="headerlink" title="内联 chunk"></a>内联 chunk</h4><p>可以通过 InlineChunkHtmlPlugin 插件将一些 chunk 的模块内联到 html，如 runtime 的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大但是必须加载的，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> InlineChunkHtmlPlugin = <span class="built_in">require</span>(<span class="string">'react-dev-utils/InlineChunkHtmlPlugin'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line">     <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">           ...    plugin:[</span><br><span class="line">              <span class="keyword">new</span> InlineChunkHtmlPlugin(HtmlWebpackPlugin,[<span class="regexp">/runtime.+\.js/</span>]&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结一下，Webpack 对前端性能的优化，主要是通过文件体积大小入手，主要的措施有分包、减少 Http 请求次数等。</p>
</blockquote>
<h3 id="webpack-构建优化"><a href="#webpack-构建优化" class="headerlink" title="webpack 构建优化"></a>webpack 构建优化</h3><p>随着功能和业务代码越来越多，相应的 Webpack 的构建时间也会越来越久，构建的效率也会越来越低，那如何提升 Webpack 构建速度，是前端工程化的重要一环。常用的手段有如下一些：</p>
<ul>
<li>优化 loader 配置</li>
<li>合理使用 resolve.extensions</li>
<li>优化 resolve.modules</li>
<li>优化 resolve.alias</li>
<li>使用 cache-loader - terser 启动多线程</li>
<li>合理使用 sourceMap</li>
</ul>
<h4 id="优化-loader-配置"><a href="#优化-loader-配置" class="headerlink" title="优化 loader 配置"></a>优化 loader 配置</h4><p>在使用 Loader 时，可以通过配置<code>include</code>、<code>exclude</code>、<code>test</code>属性来匹配文件，通过<code>include</code>、<code>exclude</code>来规定匹配应用的 loader。例如，下面是 ES6 项目中配置 babel-loader 的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能</span></span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启</span></span><br><span class="line">        use: [<span class="string">"babel-loader?cacheDirectory"</span>],</span><br><span class="line">        <span class="comment">// 只对项目根目录下的 src 目录中的文件采用 babel-loader</span></span><br><span class="line">        include: path.resolve(__dirname, <span class="string">"src"</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="合理-resolve-extensions"><a href="#合理-resolve-extensions" class="headerlink" title="合理 resolve.extensions"></a>合理 resolve.extensions</h4><p>在开发中，我们会有各种各样的模块依赖，这些模块可能来自第三方库，也可能是自己编写的， resolve 可以帮助 Webpack 从每个 require/import 语句中，找到需要引入到合适的模块代码。</p>
<p>具体来说，通过 resolve.extensions 是解析到文件时自动添加拓展名，默认情况如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    extensions:[<span class="string">".warm"</span>,<span class="string">".mjs"</span>,<span class="string">".js"</span>,<span class="string">".json"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们引入文件的时候，若没有文件后缀名，则会根据数组内的值依次查找。所以，处理配置的时候，不要随便把所有后缀都写在里面。</p>
<h4 id="优化-resolve-modules"><a href="#优化-resolve-modules" class="headerlink" title="优化 resolve.modules"></a>优化 resolve.modules</h4><p>resolve.modules 用于配置 webpack 去哪些目录下寻找第三方模块，默认值为[‘node_modules’]。所以，在项目构建时，可以通过指明存放第三方模块的绝对路径来减少寻找的时间。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    modules: [path.resolve(__dirname, <span class="string">"node_modules"</span>)], <span class="comment">// __dirname 表示当前工作目录</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="优化-resolve-alias"><a href="#优化-resolve-alias" class="headerlink" title="优化 resolve.alias"></a>优化 resolve.alias</h4><p>alias 给一些常用的路径起一个别名，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是./../../的形式，通过配置 alias 以减少查找过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    resolve:&#123;</span><br><span class="line">        alias:&#123;</span><br><span class="line">            <span class="string">"@"</span>:path.resolve(__dirname,<span class="string">'./src'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化-resolve-mainFields"><a href="#优化-resolve-mainFields" class="headerlink" title="优化 resolve.mainFields"></a>优化 resolve.mainFields</h4><p>在一些性能开销较大的 loader 之前添加 cache-loader，以将结果缓存到磁盘里，显著提升二次构建速度。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.ext$/</span>,</span><br><span class="line">        use: [<span class="string">"cache-loader"</span>, ...loaders],</span><br><span class="line">        include: path.resolve(<span class="string">"src"</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>需要说明的是，保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 loader 使用此 loader。</p>
<h4 id="开启多线程"><a href="#开启多线程" class="headerlink" title="开启多线程"></a>开启多线程</h4><p>开启多进程并行运行可以提高构建速度，配置如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">        parallel: <span class="literal">true</span>, <span class="comment">//开启多线程</span></span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="合理使用-sourceMap"><a href="#合理使用-sourceMap" class="headerlink" title="合理使用 sourceMap"></a>合理使用 sourceMap</h4><p>sourceMap 用于定位错误位置，但会降低构建速度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">"source-map"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Webpack-Proxy-工作原理"><a href="#Webpack-Proxy-工作原理" class="headerlink" title="Webpack Proxy 工作原理"></a>Webpack Proxy 工作原理</h3><p><strong>代理</strong><br>在项目开发中不可避免会遇到跨越问题，Webpack 中的 Proxy 就是解决前端跨域的方法之一。所谓代理，指的是在接收客户端发送的请求后转发给其他服务器的行为，webpack 中提供服务器的工具为 webpack-dev-server。</p>
<blockquote>
<p>服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制</p>
</blockquote>
<p><strong>webpack-dev-server</strong><br>webpack-dev-server 是 webpack 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起。同时，为了提高开发者日常的开发效率，只适用在开发阶段。在 webpack 配置对象属性中配置代理的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">  contentBase: path.join(\_\_dirname, <span class="string">'dist'</span>),</span><br><span class="line">  compress: <span class="literal">true</span>,</span><br><span class="line">  port: <span class="number">9000</span>,</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    <span class="string">'/api'</span>: &#123;</span><br><span class="line">            <span class="string">`target: 'https://api.github.com'</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>其中，devServetr 里面 proxy 则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配。</p>
<p>属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为 /api，值为对应的代理匹配规则，对应如下：</p>
<ul>
<li>target：表示的是代理到的目标地址。</li>
<li>pathRewrite：默认情况下，我们的 /api-hy 也会被写入到 URL 中，如果希望删除，可以使用 pathRewrite。</li>
<li>secure：默认情况下不接收转发到 https 的服务器上，如果希望支持，可以设置为 false。</li>
<li>changeOrigin：它表示是否更新代理后请求的 headers 中 host 地址。</li>
</ul>
<p><strong>实现概述</strong><br>在开发阶段， webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 localhost 的一个端口上，而后端服务又是运行在另外一个地址上。所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题。</p>
<p>解决这种问题时，只需要设置 webpack proxy 代理即可。当本地发送请求的时候，代理服务器响（proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器）应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。</p>

        
    </section>
</article>





<div class="comments">
    <div id="comments"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
    new Gitalk({
        clientID: "7fbe80427f54741e289f",
        clientSecret: "f34ed5fd92e54c9000bd37ba951948cb939deff5",
        repo: "sanonz.github.io",
        owner: "sanonz",
        admin: ["sanonz"],
        id: "2022/05/05/mianshi",
        distractionFreeMode: true,
        title: "常用知识总结",
        body: "http://www.shuy.cc/2022/05/05/mianshi/",
        labels: ["css js vue"]
    }).render('comments');
    </script>
</div>


        </div>
        <footer class="footer">
    Copyright © Aaron All Rights Reserved 京ICP备17007771号-1
</footer>

    </main>

    <script type="text/javascript" src="https://unpkg.com/jquery@1.9.1/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }

            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle('normal', slideDone);
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp('normal', slideDone);
            }, 3000);
        }

        function slideDone() {
            if (nodes.navInner.css('display') !== 'none') {
                nodes.navInner.css('display', '');
            }
        }

        $(window).on('resize', function() {
            console.log($(this).width())
            if ($(this).width() > 960) {
                nodes.navInner.css('display', '');
            }
        });
    });
    </script>
    
        <script src="/js/scrollspy.min.js"></script>
        <script type="text/javascript">
        $(document.body).scrollspy({target: '#aside-inner'});

        $(window).on('resize', function() {
            var hw = $('#header').width();
            var ww = $('#wrapper').width();
            var space = ($(this).width() - hw - ww) / 2 / 2;

            var pageprev = $('#pageprev');
            var pagenext = $('#pagenext');
            var avg = (pageprev.width() + pagenext.width()) / 2

            if(space > avg) {
                var len = space - avg / 2;
                // var styles = {position: 'fixed', top: '50%', marginTop: - (pageprev.width() + pagenext.width()) / 4}
                // pageprev.css($.extend({left: hw + len}, styles));
                // pagenext.css($.extend({right: len}, styles));
            } else {
                pageprev.removeAttr('style');
                // pagenext.removeAttr('style');
            }
        }).trigger('resize');
        </script>
    

</body>
</html>
