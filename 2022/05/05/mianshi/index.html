<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>常用知识总结 | 前端技术博客</title>
    <meta name="author" content="xiaosongread">
    <meta name="keywords" content="小宋 抿圪斗前端 前端 前端博客 框架 工程 css html js node markdown npm webpack">
    <meta name="description" content="– html/css— css的布局方式1.table布局2.flex布局3.float布局4.响应式布局— 盒子模型IE盒子模型：宽高包括content + padding + bording; box-sizing: border-box标准盒模型：宽高就是元素的实际宽高 content; box-sizing: content-box什么是BFC？bfc 就是 Block formatting contexts，块级格式化上下文一个独立的渲染区域，有这自己的渲染规则，其内部元素不...">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="前端技术博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <style type="text/css">
    @font-face {
        font-family: 'icomoon';
        src: url("/fonts/icomoon.eot?q628ml");
        src: url("/fonts/icomoon.eot?q628ml#iefix") format('embedded-opentype'),
             url("/fonts/icomoon.ttf?q628ml") format('truetype'),
             url("/fonts/icomoon.woff?q628ml") format('woff'),
             url("/fonts/icomoon.svg?q628ml#icomoon") format('svg');
        font-weight: normal;
        font-style: normal;
    }
    </style>
    <link rel="stylesheet" href="/css/style.css">

    <!--[if lt IE 9]><style type="text/css">.nav-inner {top:0;}.author-meta {position:static;top:0;}.search-form {height:36px;}</style><script type="text/javascript" src="https://unpkg.com/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
</head>
<body>

    <main class="app">
        <header id="header" class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">前端技术博客</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">列表</span>
            </a>
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/categories/css-end/">
                <span class="nav-text">css</span>
            </a>
        
            <a class="nav-item" href="/categories/js-end/">
                <span class="nav-text">js</span>
            </a>
        
            <a class="nav-item" href="/categories/gc-end/">
                <span class="nav-text">工程</span>
            </a>
        
            <a class="nav-item" href="/categories/sh-end/">
                <span class="nav-text">日常</span>
            </a>
        
            <a class="nav-item" href="/categories/my-end/">
                <span class="nav-text">关于我</span>
            </a>
        
    </nav>
</div>

    
<aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#–-html-css"><span class="toc-number">1.</span> <span class="toc-text">– html/css</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#—-css的布局方式"><span class="toc-number">1.1.</span> <span class="toc-text">— css的布局方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-盒子模型"><span class="toc-number">1.2.</span> <span class="toc-text">— 盒子模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是BFC？"><span class="toc-number">1.3.</span> <span class="toc-text">什么是BFC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-HTML5新增元素"><span class="toc-number">1.4.</span> <span class="toc-text">— HTML5新增元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-居中的方式"><span class="toc-number">1.5.</span> <span class="toc-text">— 居中的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-rem、em、vh、px各自代表的含义？"><span class="toc-number">1.6.</span> <span class="toc-text">— rem、em、vh、px各自代表的含义？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-有哪些方式可以影藏页面元素？区别是什么？"><span class="toc-number">1.7.</span> <span class="toc-text">— 有哪些方式可以影藏页面元素？区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-css选择器有哪些？优先级"><span class="toc-number">1.8.</span> <span class="toc-text">— css选择器有哪些？优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-清除浮动的方法"><span class="toc-number">1.9.</span> <span class="toc-text">— 清除浮动的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-常见的行内元素、块级元素"><span class="toc-number">1.10.</span> <span class="toc-text">— 常见的行内元素、块级元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-position的属性"><span class="toc-number">1.11.</span> <span class="toc-text">— position的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-SEO"><span class="toc-number">1.12.</span> <span class="toc-text">— SEO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-什么是响应式布局？"><span class="toc-number">1.13.</span> <span class="toc-text">— 什么是响应式布局？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-flex"><span class="toc-number">1.14.</span> <span class="toc-text">— flex</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#javascript"><span class="toc-number">2.</span> <span class="toc-text">javascript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#—-js中的数据类型"><span class="toc-number">2.1.</span> <span class="toc-text">— js中的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-var-let-const-的区别？"><span class="toc-number">2.2.</span> <span class="toc-text">— var/let/const 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-ES6-标准入门"><span class="toc-number">2.3.</span> <span class="toc-text">— ES6 标准入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-数组常用的方法"><span class="toc-number">2.4.</span> <span class="toc-text">— 数组常用的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-number">2.4.1.</span> <span class="toc-text">增删改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-number">2.4.2.</span> <span class="toc-text">查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null"><span class="toc-number">2.4.3.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组转字符窜"><span class="toc-number">2.4.4.</span> <span class="toc-text">数组转字符窜</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代"><span class="toc-number">2.4.5.</span> <span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#去重"><span class="toc-number">2.4.6.</span> <span class="toc-text">去重</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-bind-call-apply的区别？"><span class="toc-number">2.5.</span> <span class="toc-text">— bind/call/apply的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#箭头函数和普通函数的区别"><span class="toc-number">2.6.</span> <span class="toc-text">箭头函数和普通函数的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#普通函数"><span class="toc-number">2.6.1.</span> <span class="toc-text">普通函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#箭头函数"><span class="toc-number">2.6.2.</span> <span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#强制改变-this-指向"><span class="toc-number">2.6.3.</span> <span class="toc-text">强制改变 this 指向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">2.6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-typeof-与-instanceof-区别"><span class="toc-number">2.7.</span> <span class="toc-text">— typeof 与 instanceof 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-本地存储"><span class="toc-number">2.8.</span> <span class="toc-text">— 本地存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-深拷贝和浅拷贝"><span class="toc-number">2.9.</span> <span class="toc-text">— 深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-JSON是什么？"><span class="toc-number">2.10.</span> <span class="toc-text">— JSON是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-闭包，使用场景"><span class="toc-number">2.11.</span> <span class="toc-text">— 闭包，使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概念"><span class="toc-number">2.11.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决的问题"><span class="toc-number">2.11.2.</span> <span class="toc-text">解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包带来的问题和如何规避"><span class="toc-number">2.11.3.</span> <span class="toc-text">闭包带来的问题和如何规避</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简单实现一个闭包"><span class="toc-number">2.11.4.</span> <span class="toc-text">简单实现一个闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包的作用"><span class="toc-number">2.11.5.</span> <span class="toc-text">闭包的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包的应用场景"><span class="toc-number">2.11.6.</span> <span class="toc-text">闭包的应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-什么是防抖和节流？"><span class="toc-number">2.12.</span> <span class="toc-text">— 什么是防抖和节流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-ajax的请求过程"><span class="toc-number">2.13.</span> <span class="toc-text">— ajax的请求过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-ajax请求的时候get-和post方式的区别"><span class="toc-number">2.14.</span> <span class="toc-text">— ajax请求的时候get 和post方式的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-ajax、axios、jsonp的理解"><span class="toc-number">2.15.</span> <span class="toc-text">— ajax、axios、jsonp的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-什么是事件委托以及优缺点"><span class="toc-number">2.16.</span> <span class="toc-text">— 什么是事件委托以及优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-如何解决数字精度丢失的问题"><span class="toc-number">2.17.</span> <span class="toc-text">— 如何解决数字精度丢失的问题?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-原型，原型链-有什么特点？"><span class="toc-number">2.18.</span> <span class="toc-text">— 原型，原型链 ? 有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-如何实现上拉加载，下拉刷新？"><span class="toc-number">2.19.</span> <span class="toc-text">— 如何实现上拉加载，下拉刷新？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-说说你对作用域链的理解"><span class="toc-number">2.20.</span> <span class="toc-text">— 说说你对作用域链的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#—-浏览器输入Url之后发生了什么？"><span class="toc-number">2.21.</span> <span class="toc-text">— 浏览器输入Url之后发生了什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#从输入URL到页面加载的主干流程如下："><span class="toc-number">2.21.1.</span> <span class="toc-text">从输入URL到页面加载的主干流程如下：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-首先在浏览器中输入URL"><span class="toc-number">2.21.1.1.</span> <span class="toc-text">1.首先在浏览器中输入URL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-DNS域名解析"><span class="toc-number">2.21.1.2.</span> <span class="toc-text">2.DNS域名解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-建立TCP连接：-解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接"><span class="toc-number">2.21.1.3.</span> <span class="toc-text">3.建立TCP连接： 解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#谈谈你对promise、axios的理解"><span class="toc-number">2.22.</span> <span class="toc-text">谈谈你对promise、axios的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack-构建优化怎么搞？"><span class="toc-number">2.23.</span> <span class="toc-text">webpack 构建优化怎么搞？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue相关"><span class="toc-number">3.</span> <span class="toc-text">vue相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是mvvm"><span class="toc-number">3.1.</span> <span class="toc-text">什么是mvvm?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-是如何实现数据双向绑定的？"><span class="toc-number">3.2.</span> <span class="toc-text">Vue 是如何实现数据双向绑定的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-框架怎么实现对象和数组的监听？"><span class="toc-number">3.3.</span> <span class="toc-text">Vue 框架怎么实现对象和数组的监听？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy-与-Object-defineProperty-优劣对比"><span class="toc-number">3.4.</span> <span class="toc-text">Proxy 与 Object.defineProperty 优劣对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？"><span class="toc-number">3.5.</span> <span class="toc-text">Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生命周期函数有哪些"><span class="toc-number">3.6.</span> <span class="toc-text">生命周期函数有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么使用虚拟dom"><span class="toc-number">3.7.</span> <span class="toc-text">为什么使用虚拟dom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue中key是用来做什么的？为什么不推介使用index作为key？"><span class="toc-number">3.8.</span> <span class="toc-text">Vue中key是用来做什么的？为什么不推介使用index作为key？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#当我们没有设置key值的情况"><span class="toc-number">3.8.1.</span> <span class="toc-text">当我们没有设置key值的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如果设置了key，且key值固定的情况"><span class="toc-number">3.8.2.</span> <span class="toc-text">如果设置了key，且key值固定的情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-show和v-if的区别"><span class="toc-number">3.9.</span> <span class="toc-text">v-show和v-if的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双向数据绑定"><span class="toc-number">3.10.</span> <span class="toc-text">双向数据绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的指令？常用的内置组件有哪些？"><span class="toc-number">3.11.</span> <span class="toc-text">常用的指令？常用的内置组件有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computed-和-watch-的区别"><span class="toc-number">3.12.</span> <span class="toc-text">computed 和 watch 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#computed"><span class="toc-number">3.12.1.</span> <span class="toc-text">computed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#watch"><span class="toc-number">3.12.2.</span> <span class="toc-text">watch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue自定义指令设置"><span class="toc-number">3.13.</span> <span class="toc-text">vue自定义指令设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#父子组件之间的通信"><span class="toc-number">3.14.</span> <span class="toc-text">父子组件之间的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路由跳转的方式，传参方式有哪些？"><span class="toc-number">3.15.</span> <span class="toc-text">路由跳转的方式，传参方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#router-和-route的区别"><span class="toc-number">3.16.</span> <span class="toc-text">router 和 route的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编程式导航的使用方法"><span class="toc-number">3.17.</span> <span class="toc-text">编程式导航的使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是路由守卫？路由的钩子函数有哪些？"><span class="toc-number">3.18.</span> <span class="toc-text">什么是路由守卫？路由的钩子函数有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vuex的理解"><span class="toc-number">3.19.</span> <span class="toc-text">vuex的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#你有对-Vue-项目进行哪些优化？"><span class="toc-number">3.20.</span> <span class="toc-text">你有对 Vue 项目进行哪些优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#登陆权限的实现"><span class="toc-number">3.21.</span> <span class="toc-text">登陆权限的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#登陆"><span class="toc-number">3.21.1.</span> <span class="toc-text">登陆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#权限"><span class="toc-number">3.21.2.</span> <span class="toc-text">权限</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小程序相关"><span class="toc-number">4.</span> <span class="toc-text">小程序相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生命周期函数有哪些？小程序的周期函数？"><span class="toc-number">4.1.</span> <span class="toc-text">生命周期函数有哪些？小程序的周期函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用与页面生命周期发生顺序"><span class="toc-number">4.2.</span> <span class="toc-text">应用与页面生命周期发生顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小程序是如何传值？"><span class="toc-number">4.3.</span> <span class="toc-text">小程序是如何传值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wxss和css的区别"><span class="toc-number">4.4.</span> <span class="toc-text">wxss和css的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小程序是如何传递数据？"><span class="toc-number">4.5.</span> <span class="toc-text">小程序是如何传递数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webview的理解"><span class="toc-number">4.6.</span> <span class="toc-text">webview的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小程序和h5页面的交互"><span class="toc-number">4.7.</span> <span class="toc-text">小程序和h5页面的交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意事项"><span class="toc-number">4.8.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小程序的双向绑定和vue的有什么区别"><span class="toc-number">4.9.</span> <span class="toc-text">小程序的双向绑定和vue的有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#下拉刷新的实现方法"><span class="toc-number">4.10.</span> <span class="toc-text">下拉刷新的实现方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跳转的方式有哪些"><span class="toc-number">4.11.</span> <span class="toc-text">跳转的方式有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#描述一下小程序的登陆流程"><span class="toc-number">4.12.</span> <span class="toc-text">描述一下小程序的登陆流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wx-if和hidden的区别，如何使用？"><span class="toc-number">4.13.</span> <span class="toc-text">wx:if和hidden的区别，如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#app-json的配置项"><span class="toc-number">4.14.</span> <span class="toc-text">app.json的配置项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法题"><span class="toc-number">5.</span> <span class="toc-text">算法题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#去重-1"><span class="toc-number">5.1.</span> <span class="toc-text">去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快排算法"><span class="toc-number">5.2.</span> <span class="toc-text">快排算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序"><span class="toc-number">5.3.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#防抖、节流"><span class="toc-number">5.4.</span> <span class="toc-text">防抖、节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求和"><span class="toc-number">5.5.</span> <span class="toc-text">求和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组转对象"><span class="toc-number">5.6.</span> <span class="toc-text">数组转对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#时间相关"><span class="toc-number">5.7.</span> <span class="toc-text">时间相关</span></a></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
            <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            常用知识总结
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://www.shuy.cc/2022/05/05/mianshi/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2022-05-05T05:54:03.000Z" itemprop="datePublished">2022-05-05</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/css-js-vue/">css js vue</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="–-html-css"><a href="#–-html-css" class="headerlink" title="– html/css"></a>– html/css</h2><h3 id="—-css的布局方式"><a href="#—-css的布局方式" class="headerlink" title="— css的布局方式"></a>— css的布局方式</h3><p>1.table布局<br>2.flex布局<br>3.float布局<br>4.响应式布局</p>
<h3 id="—-盒子模型"><a href="#—-盒子模型" class="headerlink" title="— 盒子模型"></a>— 盒子模型</h3><p>IE盒子模型：宽高包括content + padding + bording; box-sizing: border-box<br>标准盒模型：宽高就是元素的实际宽高 content; box-sizing: content-box<br><a id="more"></a></p>
<h3 id="什么是BFC？"><a href="#什么是BFC？" class="headerlink" title="什么是BFC？"></a>什么是BFC？</h3><p>bfc 就是 Block formatting contexts，<strong><em>块级格式化上下文</em></strong><br>一个独立的渲染区域，有这自己的渲染规则，其内部元素不会和外部元素相互影响。<br>常见触发 <strong>BFC</strong> 方式：</p>
<ol>
<li>元素设置了 float 属性（float 不为 none）;</li>
<li>元素设置了 position 属性为 absolute 或 fixed;</li>
<li>元素设置了 display 属性为 inline-block;</li>
<li>元素 overflow 属性值除了 visible 外。</li>
</ol>
<h3 id="—-HTML5新增元素"><a href="#—-HTML5新增元素" class="headerlink" title="— HTML5新增元素"></a>— HTML5新增元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">canvas/audio/video</span><br><span class="line">source(定义媒体资源&lt;video&gt;/&lt;audio&gt;)/</span><br><span class="line">embed(定义嵌入的内容)/track(为诸如video和audio元素之类的媒介规定外部文本轨道)</span><br><span class="line">article 定义页面独立的内容区域</span><br><span class="line">aside 定义页面的侧边栏内容</span><br><span class="line">details 描述文档或文档某个部分的细节</span><br><span class="line">dialog 定义对话框</span><br><span class="line">footer header 定义文档的头尾区域</span><br><span class="line">nav 定义导航链接的部分</span><br><span class="line">等等</span><br></pre></td></tr></table></figure>
<h3 id="—-居中的方式"><a href="#—-居中的方式" class="headerlink" title="— 居中的方式"></a>— 居中的方式</h3><!-- 1) 使用Flexbox布局
在父级容器中设置 display: flex; 和 justify-content: center; align-items: center;
这将使子元素水平和垂直居中

2) 使用Grid布局
在父级容器中设置 display: grid; 和 place-items: center;
这将使子元素水平和垂直居中

3) 使用绝对定位
+ 在子元素中设置 position: absolute; 和 top: 50%; left: 50%; (transform: translate(-50%, -50%)/margin-top: -50%;margin-left: -50%;);
+ 在子元素中设置 position: absolute; 和 top:0; left: 0; bottom: 0; right: 0;
这将使子元素相对于父级容器垂直和水平居中 -->
<ul>
<li>使用绝对定位 + transform，给子元素添加如下样式<br>这种方式比较常用，<strong><em>父子元素都不确定宽高</em></strong>的情况也适用。<br>如果 <strong><em>子元素的宽高确定</em></strong>的话，translate中的值也可以设置为子元素宽高的一半，即transform: translate(-100px, -100px); </li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.work</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用绝对定位 + margin，给子元素添加如下样式<br>这种方式适合 <strong><em>子元素宽高确定</em></strong>的情况，给margin-top设置百分比的大小将不生效，即margin-top: -50%;不能达到垂直居中的效果</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.work1</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用绝对定位 + margin: auto，给子元素添加如下样式<br><strong><em>父子元素宽高都未知时也适用</em></strong>。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.work2</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>父元素使用flex布局，并设置相关的属性值为center<br>这种方式要求 <strong><em>父元素的高度是确定的</em></strong> ，百分比形式的高度将不能生效。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.par-work</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">  <span class="attribute">justify-content</span>:center;</span><br><span class="line">  <span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用table-cell实现<br>这种方式需要 <strong><em>父元素的宽高都是确定的</em></strong>，才能保证子元素在父元素中垂直水平都居中。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.par-work2</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son-work2</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用grid布局<br>这种方式适用于 <strong><em>父元素高度确定</em></strong>的情况</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.par-work3</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.son-work3</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: center; <span class="comment">/*设置单元格内容的垂直位置*/</span></span><br><span class="line">  <span class="attribute">justify-self</span>: center; <span class="comment">/*设置单元格内容的水平位置*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="—-rem、em、vh、px各自代表的含义？"><a href="#—-rem、em、vh、px各自代表的含义？" class="headerlink" title="— rem、em、vh、px各自代表的含义？"></a>— rem、em、vh、px各自代表的含义？</h3><p>px: 绝对单位，页面按精确像素展示</p>
<p>em: 相对单位，基准为父节点字体大小，如果自身定义了font-size按照自身来计算，整个页面内1em不是一个固定值</p>
<p>rem: 相对单位，可以理解为root em，相对根节点html的字体大小来计算<br>默认根元素的 font-size 都是 16px 的。如果想要设置 12px 的字体大小也就 是 12px/16px = 0.75rem</p>
<p>vh/vw: 主要用于页面视口大小布局，在页面布局上更加方便简单</p>
<h3 id="—-有哪些方式可以影藏页面元素？区别是什么？"><a href="#—-有哪些方式可以影藏页面元素？区别是什么？" class="headerlink" title="— 有哪些方式可以影藏页面元素？区别是什么？"></a>— 有哪些方式可以影藏页面元素？区别是什么？</h3><ul>
<li>display: none</li>
<li>visibility: hidden</li>
<li>opacity: 0 </li>
<li>width + height 设置为0</li>
<li>定位到可视范围之外</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>display: none</th>
<th>visibility: hidden</th>
<th>opacity: 0</th>
</tr>
</thead>
<tbody>
<tr>
<td>页面中</td>
<td>不存在</td>
<td>存在</td>
<td>存在</td>
</tr>
<tr>
<td>重排</td>
<td>会</td>
<td>不会</td>
<td>不会</td>
</tr>
<tr>
<td>重绘</td>
<td>会</td>
<td>会</td>
<td>不一定</td>
</tr>
<tr>
<td>自身绑定事件</td>
<td>不触发</td>
<td>不触发</td>
<td>触发</td>
</tr>
<tr>
<td>transition</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>被遮挡的元素可出发事件</td>
<td>能</td>
<td>能</td>
<td>不能</td>
</tr>
</tbody>
</table>
<h3 id="—-css选择器有哪些？优先级"><a href="#—-css选择器有哪些？优先级" class="headerlink" title="— css选择器有哪些？优先级"></a>— css选择器有哪些？优先级</h3><ul>
<li>!important </li>
<li>行内样式</li>
<li>Id选择器</li>
<li>类选择器 class</li>
<li>后代选择器 .box dox</li>
<li>子选择器 .box&gt;.child 选择.box下面所有类名为child的元素</li>
<li>相邻同胞选择器 .one+.two,选择紧邻.one之后的所有.two元素</li>
<li>div,p 选择所有的div、p的所有元素 </li>
<li>伪类选择器</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:link</span> 选择未被访问的链接</span><br><span class="line"><span class="selector-pseudo">:visited</span>：选取已被访问的链接</span><br><span class="line"><span class="selector-pseudo">:active</span>：选择活动链接</span><br><span class="line"><span class="selector-pseudo">:hover</span> ：鼠标指针浮动在上面的元素</span><br><span class="line"><span class="selector-pseudo">:focus</span> ：选择具有焦点的</span><br><span class="line"><span class="selector-pseudo">:first-child</span>：父元素的首个子元</span><br></pre></td></tr></table></figure>
<ul>
<li>伪元素选择器</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:first-letter</span> ：用于选取指定选择器的首字母</span><br><span class="line"><span class="selector-pseudo">:first-line</span> ：选取指定选择器的首行</span><br><span class="line"><span class="selector-pseudo">:before</span> : 选择器在被选元素的内容前面插入内容</span><br><span class="line"><span class="selector-pseudo">:after</span> : 选择器在被选元素的内容后面插入内容</span><br></pre></td></tr></table></figure>
<ul>
<li>属性选择器</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[attribute]</span> 选择带有<span class="selector-tag">attribute</span>属性的元素</span><br><span class="line">[attribute=value] 选择所有使用attribute=value的元素</span><br><span class="line"><span class="selector-attr">[attribute~=value]</span> 选择<span class="selector-tag">attribute</span>属性包含<span class="selector-tag">value</span>的元素</span><br><span class="line"><span class="selector-attr">[attribute|=value]</span>：选择<span class="selector-tag">attribute</span>属性以<span class="selector-tag">value</span>开头的元素</span><br></pre></td></tr></table></figure>
<ul>
<li>伪类选择器（css3） </li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:first-of-type</span> 父元素的首个元素</span><br><span class="line"><span class="selector-pseudo">:last-of-type</span> 父元素的最后一个元素</span><br><span class="line"><span class="selector-pseudo">:only-of-type</span> 父元素的特定类型的唯一子元素</span><br><span class="line"><span class="selector-pseudo">:only-child</span> 父元素中唯一子元素</span><br><span class="line"><span class="selector-pseudo">:nth-child(n)</span> 选择父元素中第<span class="selector-tag">N</span>个子元素</span><br><span class="line"><span class="selector-pseudo">:nth-last-of-type(n)</span> 选择父元素中第<span class="selector-tag">N</span>个子元素，从后往前</span><br><span class="line"><span class="selector-pseudo">:last-child</span> 父元素的最后一个元素</span><br><span class="line"><span class="selector-pseudo">:root</span> 设置<span class="selector-tag">HTML</span>文档</span><br><span class="line"><span class="selector-pseudo">:empty</span> 指定空的元素</span><br><span class="line"><span class="selector-pseudo">:enabled</span> 选择被禁用元素</span><br><span class="line"><span class="selector-pseudo">:disabled</span> 选择被禁用元素</span><br><span class="line"><span class="selector-pseudo">:checked</span> 选择选中的元素</span><br><span class="line"><span class="selector-pseudo">:not(selector)</span> 选择非 &lt;<span class="selector-tag">selector</span>&gt; 元素的所有元素</span><br></pre></td></tr></table></figure>
<ul>
<li>属性选择器（css3） </li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[attribute*=value]</span>：选择<span class="selector-tag">attribute</span>属性值包含<span class="selector-tag">value</span>的所有元素</span><br><span class="line"><span class="selector-attr">[attribute^=value]</span>：选择<span class="selector-tag">attribute</span>属性开头为<span class="selector-tag">value</span>的所有元素</span><br><span class="line"><span class="selector-attr">[attribute$=value]</span>：选择<span class="selector-tag">attribute</span>属性结尾为<span class="selector-tag">value</span>的所有元素</span><br></pre></td></tr></table></figure>
<p>nth-child/nth-of-type的区别<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>1<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>2<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>3<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>4<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>6<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>7<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2n+1 // 1 3 5 7</span><br><span class="line"><span class="selector-tag">h5</span><span class="selector-pseudo">:nth-child(2n+1)</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/img-folder/2023/ms-1.png"></p>
<p>1）先找设置标签的全部同级标签<br>2）然后找对应的下标，如果选择器一致，那就匹配上，不一致就继续匹配下个下标的选择器</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h5</span><span class="selector-pseudo">:nth-of-type(2n+1)</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/img-folder/2023/ms-2.png"></p>
<p>1）找出和设置标签一样的标签<br>2）然后再找对应的下标标签</p>
<h3 id="—-清除浮动的方法"><a href="#—-清除浮动的方法" class="headerlink" title="— 清除浮动的方法"></a>— 清除浮动的方法</h3><p>1）使用带clear属性的空元素<br>在浮动元素的后面设置一个空元素，然后给这个空元素设置属性.clear{clear:both;}<br>2）使用overflow属性<br>给浮动元素的容器添加overflow:hidden;或 overflow:auto;可以清除浮动，另外在 IE6 中还 需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。 在添加 overflow 属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动 的效果。<br>3）使用css的:after伪元素<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span>  solid<span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"020"</span>; </span><br><span class="line">  <span class="attribute">display</span>: block; </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attribute">clear</span>: both; </span><br><span class="line">  <span class="comment">/* 表示元素不可见 */</span></span><br><span class="line">  <span class="attribute">visibility</span>: hidden;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.media</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background-color</span>:aquamarine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&lt;div class="container"&gt;</span><br><span class="line">  &lt;div class="media"&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;p&gt;hello&lt;/p&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="—-常见的行内元素、块级元素"><a href="#—-常见的行内元素、块级元素" class="headerlink" title="— 常见的行内元素、块级元素"></a>— 常见的行内元素、块级元素</h3><p>1.块级元素<br>  div/p/h1~h6/ol/ul/li/table<br>2.行内元素<br>  span/img/a/strong/input</p>
<h3 id="—-position的属性"><a href="#—-position的属性" class="headerlink" title="— position的属性"></a>— position的属性</h3><p>相对定位：relative,相对于当前元素的位置来移动<br>绝对定位：absolute,相对于父元素（具有相对定位属性）来定位<br>固定定位：fixed,相对于页面的左上角定位</p>
<h3 id="—-SEO"><a href="#—-SEO" class="headerlink" title="— SEO"></a>— SEO</h3><p>1）语义化的html的标签使用<br>2）设置合理的title,description,keywords<br>3）重要的html代码放到页面的前面<br>4）尽量少用iframe，搜索引擎抓不到里面的内容<br>5）图片上面加上alt属性</p>
<h3 id="—-什么是响应式布局？"><a href="#—-什么是响应式布局？" class="headerlink" title="— 什么是响应式布局？"></a>— 什么是响应式布局？</h3><p>响应式网站设计（Responsive Web design）是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整</p>
<p>1&gt; 响应式网站常见特点：</p>
<ul>
<li>同时适配PC + 平板 + 手机等</li>
<li>标签导航在接近手持终端设备时改变为经典的抽屉式导航</li>
<li>网站的布局会根据视口来调整模块的大小和位置</li>
</ul>
<p>2&gt; 实现响应式布局的方式有如下：</p>
<ul>
<li>媒体查询（我们可以设置不同类型的媒体条件，并根据对应的条件，给相应符合条件的媒体调用相对应的样式表）</li>
<li>百分比</li>
<li>vw/vh</li>
<li>rem</li>
</ul>
<p>3&gt; 响应式设计实现通常会从以下几方面思考：</p>
<ul>
<li>弹性盒子（包括图片、表格、视频）和媒体查询等技术</li>
<li>使用百分比布局创建流式布局的弹性UI，同时使用媒体查询限制元素的尺寸和内容变更范围</li>
<li>使用相对单位使得内容自适应调节</li>
<li>选择断点，针对不同断点实现不同布局和内容展示</li>
</ul>
<h3 id="—-flex"><a href="#—-flex" class="headerlink" title="— flex"></a>— flex</h3><p>参考文档：<a href="/2020/11/05/flex布局教程/">flex布局教程</a></p>
<h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="—-js中的数据类型"><a href="#—-js中的数据类型" class="headerlink" title="— js中的数据类型"></a>— js中的数据类型</h3><ul>
<li>基本类型 string number null undefind boolean Symbol(ES6 引入了一种新的原始数据类型，表示独一无二的值)</li>
<li>引用类型 Object Array Function</li>
</ul>
<h3 id="—-var-let-const-的区别？"><a href="#—-var-let-const-的区别？" class="headerlink" title="— var/let/const 的区别？"></a>— var/let/const 的区别？</h3><ul>
<li>变量提升<br>var声明存在变量提升，let和const不存在变量提升，不声明是不可以使用的，否则会报错</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1</span></span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="keyword">var</span> a <span class="comment">// 重复声明会被忽视</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"><span class="keyword">var</span> a </span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 示例3</span></span><br><span class="line"><span class="keyword">var</span> a </span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//undefined</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>js中，变量提升指的是变量声明的提升，赋值还是按照代码中的顺序逐行执行。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式声明 会变量提升</span></span><br><span class="line">fn(<span class="number">10</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 表达式声明 不会变量提升</span></span><br><span class="line"><span class="built_in">console</span>.log(test) <span class="comment">// undefined</span></span><br><span class="line">test(<span class="number">10</span>) <span class="comment">// TypeError: test is not a function</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// f a()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">v</span>)</span>&#123;<span class="keyword">return</span> v&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// f a()</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// ƒ a(v)&#123;return v&#125;</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">v</span>)</span>&#123;<span class="keyword">return</span> v&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数的提升是优先变量的提升的。<br>变量提升指的是变量声明的提升，赋值还是按照代码中的顺序逐行执行。<br>函数式声明存在变量提升，函数表达式声明不存在变量提升。</p>
</blockquote>
<ul>
<li>作用域<br>var 没有块级作用域一说，不声明也是可以使用的，let，const有块级作用域一说，只能在声明的花括号里面使用</li>
<li>使用的方法<br>const声明一个只读的变量，一旦声明，不可以修改，其余使用let，避免使用var，因为有不可控性，代码复杂的时候，不容易查找问题。</li>
</ul>
<h3 id="—-ES6-标准入门"><a href="#—-ES6-标准入门" class="headerlink" title="— ES6 标准入门"></a>— ES6 标准入门</h3><p>文档参考：<a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">ES6 入门教程</a></p>
<h3 id="—-数组常用的方法"><a href="#—-数组常用的方法" class="headerlink" title="— 数组常用的方法"></a>— 数组常用的方法</h3><h4>增删改</h4>

<table>
<thead>
<tr>
<th></th>
<th>向前+</th>
<th>向前-</th>
<th>向后+</th>
<th>向后-</th>
</tr>
</thead>
<tbody>
<tr>
<td>页面中</td>
<td>unshift</td>
<td>shift</td>
<td>push</td>
<td>pop</td>
</tr>
<tr>
<td>语法</td>
<td>array.unshift(item1,item2, …, itemX)</td>
<td>array.shift()</td>
<td>array.push(item1, item2, …, itemX)</td>
<td>array.pop()</td>
</tr>
<tr>
<td>返回结果</td>
<td>数组新长度</td>
<td>数组原来的第一个元素的值（移除的元素）</td>
<td>数组新长度</td>
<td>返回删除的元素</td>
</tr>
<tr>
<td>原数组</td>
<td>改变原数组</td>
<td>改变了原数组</td>
<td>改变原数组</td>
<td>改变了原数组</td>
</tr>
</tbody>
</table>
<ul>
<li>concat 合并两个数组</li>
<li>splice （增、删、改）传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组<br>array.splice(index,howmany,item1,…..,itemX)</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>必需。规定从何处添加/删除元素。<br>该参数是开始插入和（或）删除的数组元素的下标，必须是数字。</td>
</tr>
<tr>
<td>howmany</td>
<td>可选。规定应该删除多少元素。必须是数字，但可以是 “0”。<br>如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。</td>
</tr>
<tr>
<td>item1, …, itemX</td>
<td>可选。要添加到数组的新元素</td>
</tr>
</tbody>
</table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除数组的第三个元素，并在数组第三个位置添加新元素:</span></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line">fruits.splice(<span class="number">2</span>,<span class="number">1</span>,<span class="string">"Lemon"</span>,<span class="string">"Kiwi"</span>);</span><br><span class="line"><span class="comment">// Banana,Orange,Lemon,Kiwi,Mango</span></span><br><span class="line"><span class="comment">// 从第三个位置开始删除数组后的两个元素：</span></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line"><span class="comment">// Banana,Orange</span></span><br><span class="line">fruits.splice(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>slice() 方法可从已有的数组中返回选定的元素。<br>slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。【不会影响原始数组】<br>array.slice(start, end)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用负值从数组中读取元素</span></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Lemon"</span>, <span class="string">"Apple"</span>, <span class="string">"Mango"</span>];</span><br><span class="line"><span class="keyword">var</span> myBest = fruits.slice(<span class="number">-3</span>,<span class="number">-1</span>); <span class="comment">// 截取倒数第三个（包含）到倒数第一个（不包含）的两个元素</span></span><br><span class="line"><span class="keyword">var</span> myBest = fruits.slice(<span class="number">-3</span>);  <span class="comment">// 截取最后三个元素</span></span><br><span class="line"><span class="comment">// Lemon,Apple</span></span><br><span class="line"><span class="comment">// 截取字符串</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">"www.runoob.com!"</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str.slice(<span class="number">4</span>)+<span class="string">"&lt;br&gt;"</span>); <span class="comment">// 从第 5 个字符开始截取到末尾</span></span><br><span class="line"><span class="built_in">document</span>.write(str.slice(<span class="number">4</span>,<span class="number">10</span>)); <span class="comment">// 从第 5 个字符开始截取到第10个字符</span></span><br></pre></td></tr></table></figure>
<p></p><h4>查</h4><br>查找元素，返回元素坐标或者元素值<p></p>
<ul>
<li>indexOf() 返回要查找的元素在数组中的位置，如果没找到则返回 -1</li>
<li>includes() 返回要查找的元素在数组中的位置，找到返回true，否则false</li>
<li>find() 返回通过测试（函数内判断）的数组的第一个元素的值<br>当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。<br>如果没有符合条件的元素返回 undefined</li>
</ul>
<blockquote>
<p>array.find(function(currentValue, index, arr),thisValue)<br>[参数]<br>callback：必须。为数组中每个元素执行的函数，该函数接受三个参数：<br>currentValue：必须。数组中正在处理的当前元素。<br>index：可选。当前元素的索引值。<br>arr：可选。当前元素所在的数组对象。<br>thisValue：可选。传递给函数的值一般用 “this” 值。<br>如果这个参数为空， “undefined” 会传递给 “this” 值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> num = arr1.find(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>findIndex() 返回传入一个测试条件（函数）符合条件的数组第一个元素位置。<br>当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。<br>如果没有符合条件的元素返回 -1</li>
</ul>
<blockquote>
<p>array.findIndex(function(currentValue, index, arr), thisValue)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 可以这么写</span></span><br><span class="line"><span class="keyword">const</span> index = arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(index) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 也可以这么写</span></span><br><span class="line"><span class="keyword">const</span> index = arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p></p><h4>排序</h4><p></p>
<ul>
<li>reverse() 将数组元素翻转</li>
<li>sort() </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">22</span>,<span class="number">11</span>,<span class="number">33</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort()) <span class="comment">// [1,11,2,22,3,33,4,5]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下sort方法是按ascii字母顺序排序的，而非我们认为是按数字大小排序 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">v1,v2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (v1&gt;v2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(v1&lt;v2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v1===v2)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a.sort(compare)</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [1, 1, 2, 3, 4, 5, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">v1, v2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v2-v1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a.sort(compare)</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [10, 9, 5, 4, 3, 2, 1, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">v1, v2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v1-v2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a.sort(compare)</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [1, 1, 2, 3, 4, 5, 9, 10]</span></span><br></pre></td></tr></table></figure>
<h4 id="数组转字符窜"><a href="#数组转字符窜" class="headerlink" title="数组转字符窜"></a>数组转字符窜</h4><p>join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串</p>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><ul>
<li>some() 对数组每一项都运行传入的函数，有一项符合就返回true</li>
<li>every() 每一项都符合才返回true</li>
<li>forEach() 循环数组每一项，没有返回值</li>
<li>filter() 返回符合的项会组成函数</li>
<li>map() 返回由每次函数调用的结果组成的函数</li>
<li>for…in 遍历对象的属性key</li>
<li>for…of 遍历对象的值value</li>
</ul>
<h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><p>1.利用ES6 Set去重</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>,&#123;&#125;,&#123;&#125;, <span class="number">1</span>, <span class="string">'a'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">// [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", &#123;&#125;, &#123;&#125;]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Array.from()方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组，也是ES6的新增方法。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'tom'</span>, </span><br><span class="line">  <span class="number">1</span>: <span class="string">'65'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'男'</span>,</span><br><span class="line">  <span class="number">3</span>: [<span class="string">'jane'</span>,<span class="string">'john'</span>,<span class="string">'Mary'</span>],</span><br><span class="line">  <span class="string">'length'</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(arrayLike)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ['tom','65','男',['jane','john','Mary']]</span></span><br></pre></td></tr></table></figure>
<p>2.利用for嵌套for，然后splice去重（ES5中最常用）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;            </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>; j&lt;arr.length; j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(arr[i]==arr[j])&#123;         <span class="comment">//第一个等同于第二个，splice方法删除第二个</span></span><br><span class="line">              arr.splice(j,<span class="number">1</span>);</span><br><span class="line">              j--;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, "true", 15, false, undefined, NaN, NaN, "NaN", "a", &#123;…&#125;, &#123;…&#125;]     //NaN和&#123;&#125;没有去重，两个null直接消失了</span></span><br></pre></td></tr></table></figure></p>
<p>3.利用indexOf去重<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'type error!'</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> array = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array .indexOf(arr[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">          array .push(arr[i])</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">// [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", &#123;…&#125;, &#123;…&#125;]  //NaN、&#123;&#125;没有去重</span></span><br></pre></td></tr></table></figure></p>
<p>4.利用includes<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'type error!'</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> array =[];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>( !array.includes( arr[i]) ) &#123;<span class="comment">//includes 检测数组是否有某个值</span></span><br><span class="line">            array.push(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">'true'</span>,<span class="string">'true'</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", &#123;…&#125;, &#123;…&#125;]     //&#123;&#125;没有去重</span></span><br></pre></td></tr></table></figure></p>
<h3 id="—-bind-call-apply的区别？"><a href="#—-bind-call-apply的区别？" class="headerlink" title="— bind/call/apply的区别？"></a>— bind/call/apply的区别？</h3><ul>
<li>call()的第一个参数为this绑定的对象，后面传入一串字符窜<br>当第一个参数为null或者undefined的时候，默认指向window</li>
<li>apply()和call类似，不同在于第二个参数是一个数组</li>
<li>bind()和call()类似，不通电在于bind()不会立即执行，而是返回了一个改变this后的函数；不同点二在于当你调用fn1 = fn.bind(newThis,param1)方法后，执行fn2(prama2)时，参数prama2会加到param1后面。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">'obj1'</span>,</span><br><span class="line">  fn1(param) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, param);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">'obj2'</span>,</span><br><span class="line">  fn1(param) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, param);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一般调用</span></span><br><span class="line">obj1.fn1(<span class="string">'param1'</span>)  <span class="comment">//输出 obj1 param1</span></span><br><span class="line"><span class="comment">//call的第一参数为调用该函数的对象时，等价于一般调用</span></span><br><span class="line">obj1.fn1.call(obj1, <span class="string">'param1'</span>)     <span class="comment">//输出 obj1 param1</span></span><br><span class="line"><span class="comment">//改变this指针，指向obj2</span></span><br><span class="line">obj1.fn1.call(obj2, <span class="string">'param1'</span>)     <span class="comment">//输出 obj2 param1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//apply的第二个参数为参数数组</span></span><br><span class="line">obj1.fn1.apply(obj2, [<span class="string">'param1'</span>])  <span class="comment">//输出 obj2 param1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bind方法返回一个函数,但不会执行，这个函数的参数继承bind方法的参数</span></span><br><span class="line"><span class="keyword">let</span> fun = obj1.fn1.bind(obj2, <span class="string">'param'</span>)</span><br><span class="line">fun()   <span class="comment">//输出 obj2 param1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>求数组中的最大最小值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">46</span>]</span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr) <span class="comment">// 46</span></span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, arr) <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">window</span>.Math.max(...arr)</span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">window</span>.Math.min(...arr)</span><br></pre></td></tr></table></figure>
<p>这里利用apply的第二个参数是接受一个数组，而在调用函数的时候会自动展开这个数组，而max和min方法接受参数的形式是(1,2,3,4)。</p>
<blockquote>
<p>将 arguments 等类数组转换为数组</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trueArr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">0</span>,<span class="built_in">arguments</span>.length)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 log 代替 console.log</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><p>普通函数的this是调用者；箭头函数的this是根据作用域的上下文确定的，是不可以修改的。</p>
<ul>
<li>全局声明的函数，this指向的是window</li>
<li>对象里面的函数，this指向的是当前的对象，但是可以修改</li>
<li>构造函数的this，指向的是new出来的对象</li>
<li>箭头函数的this，是当前声明箭头函数的作用域this指向的是谁，this就是指向谁</li>
</ul>
<h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><p>一句话：谁调用就指向谁。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">   age:<span class="number">20</span>,</span><br><span class="line">   getAge()&#123;</span><br><span class="line">       <span class="keyword">var</span> age = <span class="number">30</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">person.getAge(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这个的 getAge 方法是 person 调用的，所以 this 指向 person，person.age 输出为 20；</p>
</blockquote>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>一句话：调用者指向谁，则指向谁。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">   age:<span class="number">20</span>,</span><br><span class="line">   getAge:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> age = <span class="number">30</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">person.getAge(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这个的 getAge 方法是 person 调用的，则 getAge 和 person 的指向一致，person 是 window 调用的（参照上述普通函数），所以 person 指向 window，因此 getAge 也指向 window，输出 10。</p>
</blockquote>
<h4 id="强制改变-this-指向"><a href="#强制改变-this-指向" class="headerlink" title="强制改变 this 指向"></a>强制改变 this 指向</h4><p>一句话：你说指向谁就指向谁。<br>改变 this 指向，有 call，apply，bind 这几种方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">   age:<span class="number">20</span>,</span><br><span class="line">   getAge:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> age = <span class="number">30</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">person.getAge.call(person);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里 call 方法将 person 作为 this 指向，所以输出 20。<br>这里在执行 getAge 方法的时候，传入了 person，那么 getAge 的 this 指向 person，所以输出 20。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>箭头函数没有 this，箭头函数的 this 指向的是外层第一个普通函数的 this，如果外层没有普通函数，则指向 window。</li>
<li>普通函数的 this 指向调用者，如果调用者是 window，则指向 window。</li>
<li>箭头函数的 this 指向是固定的，不会指向调用者，而是指向外层第一个普通函数的 this。</li>
</ol>
<h3 id="—-typeof-与-instanceof-区别"><a href="#—-typeof-与-instanceof-区别" class="headerlink" title="— typeof 与 instanceof 区别"></a>— typeof 与 instanceof 区别</h3><p>typeof 和 instanceof 都是 JavaScript 中用来检测数据类型的运算符，但它们的作用不同。<br>1.typeof 运算符是用来检测一个变量或表达式的数据类型的。它返回一个字符串，表示该值的数据类型。</p>
<blockquote>
<p>基本数据类型可以用typeof检测出来，但null、数组、对象、函数的实例(new+函数),返回的都是object，无法检测到真实的数据类型，需要使用instanceof</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">123</span>);<span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'hello'</span>);<span class="comment">//输出 string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);<span class="comment">//输出 boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);<span class="comment">//输出 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;);<span class="comment">//输出 function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);<span class="comment">//输出 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> [<span class="number">123</span>]);<span class="comment">//输出 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123; <span class="attr">name</span>: <span class="string">'tom'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);<span class="comment">//输出 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>());<span class="comment">//输出 object</span></span><br></pre></td></tr></table></figure>
<p>2.instanceof<br>instanceof 运算符是用来判断一个对象是否属于某个类（构造函数）的实例。<br>instanceof 检查的是对象的原型链上是否有该类实例，只要原型链上有该类实例，就会返回true，否则为false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// 返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">date <span class="keyword">instanceof</span> <span class="built_in">Date</span> <span class="comment">// 返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/hello/</span>;</span><br><span class="line">reg <span class="keyword">instanceof</span> <span class="built_in">RegExp</span> <span class="comment">// 返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line"><span class="built_in">console</span>.log(dog <span class="keyword">instanceof</span> Dog);<span class="comment">//输出 true</span></span><br><span class="line"><span class="built_in">console</span>.log(dog <span class="keyword">instanceof</span> Person);<span class="comment">//输出 true</span></span><br><span class="line"><span class="built_in">console</span>.log(dog <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//输出 true</span></span><br><span class="line"><span class="comment">//执行顺序：dog--&gt;Person的实例--&gt;Object实例--&gt;Object原型</span></span><br><span class="line"><span class="comment">//Object是所有对象的原型，所以任何和对象和Object进行instanceof运算都会返回true</span></span><br><span class="line"><span class="keyword">let</span> b = &#123; <span class="attr">name</span>: <span class="string">'Bob'</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> Person);<span class="comment">//输出 false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，instanceof 运算符只能用来判断对象是否为该类的实例，不能用来判断基本数据类型的值。而且，如果要判断对象是否为某个类的实例，该类必须是通过构造函数定义的，不能是字面量对象或匿名函数等其他形式。</p>
</blockquote>
<p>3.typeof与instanceof总结：<br>①typeof与instanceof用来判断变量是否为空,或者属于什么数据类型<br>②typeof返回的是一个字符串,用来判断是什么数据类型<br>③instanceof返回的是一个布尔值,用来判断一个变量是否属于对象上的实例<br>④typeof检测的是简单数据类型,instanceof检测的是引用数据类型</p>
<h3 id="—-本地存储"><a href="#—-本地存储" class="headerlink" title="— 本地存储"></a>— 本地存储</h3><ul>
<li>cookie<br>存储数据大小为4K左右，客户端请求服务器。将cookie返给服务器，以此来判断用户的状态，可以设置过期时间，不可跨域访问</li>
<li>sessionStorage<br>存储数据大小为5M左右，在当前浏览器窗口关闭后自动删除，存储位置为当前域名的浏览器本地</li>
<li>localStorage<br>存储数据大小为5M左右，可以手动添加删除，不手动删除，会一直保存在当前域名的浏览器本地</li>
</ul>
<blockquote>
<p>标记用户与跟踪用户行为的情况，推荐使用cookie<br>适合长期保存在本地的数据（令牌），推荐使用localStorage<br>敏感账号一次性登录，推荐使用sessionStorage</p>
</blockquote>
<h3 id="—-深拷贝和浅拷贝"><a href="#—-深拷贝和浅拷贝" class="headerlink" title="— 深拷贝和浅拷贝"></a>— 深拷贝和浅拷贝</h3><p>浅拷贝指的是创建一个属性、值完全一样的变量，如果是基本类型，拷贝的就是基本类型，如果是引用类型那拷贝的就是一个内存对象，只是拷贝出了一个引用值，改变拷贝值，原值也会改变。<br>深拷贝完全是开辟了一个栈，两个引用类型出了属性、值一样，完全都是独立的，修改其中的一个，不会影响另一个的值。</p>
<ul>
<li>Object.assign</li>
<li>Array.prototype.slice()</li>
<li>Array.prototype.concat()</li>
<li>… 拓展符实现的复制</li>
</ul>
<p>以上方法都存在浅拷贝的现象</p>
<p>深拷贝的方法有：</p>
<ul>
<li>_cloneDeep() Lodash库的方法</li>
<li>jQuery.extend()</li>
<li>JSON.stringify()</li>
<li>循环递归</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone = <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      result[key] = deepClone(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="—-JSON是什么？"><a href="#—-JSON是什么？" class="headerlink" title="— JSON是什么？"></a>— JSON是什么？</h3><p>JSON是轻量级的文本数据格式，是一门独立的语言，是用js语法描述的数据对象，但独立于任何的语言，编程语言都支持JSON，具有自我描述性，更容易理解。</p>
<ul>
<li>json对象转化为json字符窜</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonStr = <span class="built_in">JSON</span>.stringify(jsonObj);</span><br></pre></td></tr></table></figure>
<ul>
<li>JSON字符串转化为JSON对象</li>
</ul>
<p>1). 使用eval()函数进行转换<br>使用 eval() 转换时需要在 json 字符外包裹一对小括号。</p>
<p>ie8(兼容模式)、ie7、ie6 不要使用此方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">eval</span>(<span class="string">'('</span> + jsonStr + <span class="string">')'</span>);</span><br></pre></td></tr></table></figure>
<p>2). 使用JSON.parse()方法进行转换<br>ie8(兼容模式)、ie7、ie6 不要使用此方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.parse(jsonStr);</span><br></pre></td></tr></table></figure>
<p>3). 使用jQuery进行转换<br>如果我们项目中有使用 jQuery，那么直接使用 $.parseJSON() 方法即可，而且可以确保各个浏览器的兼容性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = $.parseJSON(jsonStr);</span><br></pre></td></tr></table></figure>
<h3 id="—-闭包，使用场景"><a href="#—-闭包，使用场景" class="headerlink" title="— 闭包，使用场景"></a>— 闭包，使用场景</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>闭包是指一个函数中有权访问另一个函数中的变量，本质就是在函数A中返回另一个函数B，这时候B函数可以访问A函数中的变量，这样就形成了一个闭包，A函数中变量不会被销毁，并且这个变量只能通过B函数来访问。</p>
<h4 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h4><p>能够让函数执行后，其中的变量不会被销毁，同时能够让函数内的局部变量被访问。</p>
<h4 id="闭包带来的问题和如何规避"><a href="#闭包带来的问题和如何规避" class="headerlink" title="闭包带来的问题和如何规避"></a>闭包带来的问题和如何规避</h4><p>由于垃圾回收机制不能销毁闭包中的局部变量，从而导致内存泄漏，一旦闭包使用的太多，就会导致内存溢出，导致程序不安全和卡顿，所以必须手动设置闭包=null,让垃圾回收机制回收闭包中的变量。</p>
<h4 id="简单实现一个闭包"><a href="#简单实现一个闭包" class="headerlink" title="简单实现一个闭包"></a>简单实现一个闭包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = getA()</span><br><span class="line"><span class="built_in">console</span>.log(a()) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4><ul>
<li>延长变量的生命周期</li>
<li>创建私有变量</li>
<li>闭包可以在函数外部访问到函数内部作用域的变量</li>
<li>闭包可以让访问变量不会被垃圾机制回收</li>
</ul>
<h4 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h4><ul>
<li><p>使用场景一:给对象设置私有变量并且利用特权方法去访问私有属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'tom'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> Fun(); </span><br><span class="line"><span class="built_in">console</span>.log(fun.name);<span class="comment">//输出undefined,在外部无法直接访问name</span></span><br><span class="line"><span class="built_in">console</span>.log(fun.getName());<span class="comment">//可以通过特定方法去访问</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>防抖节流</p>
</li>
</ul>
<h3 id="—-什么是防抖和节流？"><a href="#—-什么是防抖和节流？" class="headerlink" title="— 什么是防抖和节流？"></a>— 什么是防抖和节流？</h3><ul>
<li>防抖 n秒后在执行该事件，若在n秒之内被重复触发，则重新计时(单位时间内，频繁触发一个事件，以最后一次触发为准。)</li>
</ul>
<blockquote>
<p>简单点理解就是：<br>防抖是频繁执行某个事件的时候，就等事件停止之后的n秒后再执行相关的操作；<br>节流是频繁执行某个事件的时候，规定n秒执行一次回调（执行相关的操作），比如规定了1S执行一次，那就是如果用户某个按钮频繁点击了3S，那就执行相关操作（执行回调方法）3次。</p>
</blockquote>
<p>使用场景：<br>最典型的防抖函数应用场景就是搜索输入框了，用户输入之后需要自动发送网络请求获取数据，但是普通函数会频繁的触发事件，而用户的输入并没有完成，请求的结果也是无意义的，毫无疑问地给服务器造成了巨大地压力。<br>现在需要优化的关键点就是，如何使网络请求触发的不那么频繁，比如在用户输入停下一段时间后，这时，可能代表用户输入已经完毕，在这时才发送请求是最合适的。防抖函数就可以很好的做到这一点。<br>防抖函数的功能：如果在某个时间内反复触发的函数，那么它只会执行最后触发的那一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖动</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>func 需要防抖执行的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>delay 多少毫秒不调用后执行一次,延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>节流 n秒内只运行一次，若在n秒内重复触发，只有一次生效(单位时间内，频繁触发一个事件，只会触发一次。)</li>
</ul>
<p>应用场景：假如有一个轮播图，轮播图以固定的频率播放图片，用户可以点击切换上一张或者下一张，如果用户点击过快，轮播图就会一直切换。这时候，应该控制轮播图切换的频率，在用户的持续点击下，只按照固定的频率切换。<br>节流函数的功能：连续的触发某个函数，只会以固定的频率去执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, delay = <span class="number">500</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">**<span class="doctag">@param<span class="type">&#123;fn: function&#125;</span> </span>需要节流的函数</span></span><br><span class="line"><span class="comment">**<span class="doctag">@param<span class="type">&#123;interval: number&#125;</span> </span>函数触发的频率</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, interval</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 记录上一次触发函数时的时间，初始值为0</span></span><br><span class="line">  <span class="keyword">let</span> lastTime  = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取现在的时间</span></span><br><span class="line">    <span class="keyword">const</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    <span class="comment">// 如果现在的时间减去上次触发的事件大于等于interval，则可以执行函数了</span></span><br><span class="line">    <span class="keyword">if</span>(nowTime - lastTime &gt;= interval)&#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">      <span class="comment">// 将上次触发函数的时间赋值成当前时间</span></span><br><span class="line">      lastTime = nowTimes</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>fn 方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>delay 每隔多少毫秒执行一次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, delay</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="—-ajax的请求过程"><a href="#—-ajax的请求过程" class="headerlink" title="— ajax的请求过程"></a>— ajax的请求过程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ajax 提交 post 请求的数据</span></span><br><span class="line"><span class="comment">// 1. 创建核心对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 2. 准备建立连接</span></span><br><span class="line">xhr.open(<span class="string">"POST"</span>, <span class="string">"register.php"</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 3. 发送请求</span></span><br><span class="line"><span class="comment">// 如果要POST提交数据，则需要设置请求头</span></span><br><span class="line"><span class="comment">// 有的面试官会问为什么要设置请求头？ 知道请求正文是以什么格式</span></span><br><span class="line"><span class="comment">// Content-Type: application/x-www-form-urlencoded，请求正文是类似 get 请求 url 的请求参数</span></span><br><span class="line"><span class="comment">// Content-Type: application/json，请求正文是一个 json 格式的字符串</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">xhr.send(querystring);</span><br><span class="line"><span class="comment">// 4. 处理响应</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123; <span class="comment">// 请求处理完毕，响应就绪</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123; <span class="comment">// 请求成功</span></span><br><span class="line">      <span class="keyword">var</span> data = xhr.responseText;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="—-ajax请求的时候get-和post方式的区别"><a href="#—-ajax请求的时候get-和post方式的区别" class="headerlink" title="— ajax请求的时候get 和post方式的区别"></a>— ajax请求的时候get 和post方式的区别</h3><ul>
<li>get请求，传递的参数是链接传递，有长度限制（IE 和 Safari 浏览器 限制 2k，Opera 限制4k，Firefox 限制 8k（非常老的版本 256byte）），post请求无限制</li>
<li>get请求参数在url后面传递，不安全，容易被窃取</li>
<li>post请求需要设置请求头</li>
</ul>
<h3 id="—-ajax、axios、jsonp的理解"><a href="#—-ajax、axios、jsonp的理解" class="headerlink" title="— ajax、axios、jsonp的理解"></a>— ajax、axios、jsonp的理解</h3><p>1、jsonp是一种可以解决跨域问题的方式，就是通过动态创建script标签用src引入外部文件实现跨域，script加载实际上就是一个get请求，并不能实现post请求。(其他实现跨域的方法有：iframe,window.name,postMessage,CORS…)<br>2、ajax是一种技术，ajax技术包含了get和post请求的，但是它仅仅是一种获取数据的技术，不能直接实现跨域，只有后台服务器配置好Access-Control-Allow-Origin，才可以实现跨域的请求。<br>3、axios是通过promise实现对ajax技术的一种封装，axios是ajax，ajax不止axios。</p>
<h3 id="—-什么是事件委托以及优缺点"><a href="#—-什么是事件委托以及优缺点" class="headerlink" title="— 什么是事件委托以及优缺点"></a>— 什么是事件委托以及优缺点</h3><p>js事件委托就是利用冒泡的原理，把本应该添加到某个元素上的事件委托给他的父级，从而减少DOM交互达到网页优化。</p>
<p>【优点】</p>
<p>1.可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错。<br>2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适</p>
<p>【缺点】</p>
<p>事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。</p>
<h3 id="—-如何解决数字精度丢失的问题"><a href="#—-如何解决数字精度丢失的问题" class="headerlink" title="— 如何解决数字精度丢失的问题?"></a>— 如何解决数字精度丢失的问题?</h3><p>理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果</p>
<p>当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="number">1.4000000000000001</span>.toPrecision(<span class="number">12</span>)) === <span class="number">1.4</span>  <span class="comment">// True</span></span><br></pre></td></tr></table></figure></p>
<p>封装成方法就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strip</span>(<span class="params">num, precision = <span class="number">12</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +<span class="built_in">parseFloat</span>(num.toPrecision(precision));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后还可以使用第三方库，如Math.js、BigDecimal.js</p>
<h3 id="—-原型，原型链-有什么特点？"><a href="#—-原型，原型链-有什么特点？" class="headerlink" title="— 原型，原型链 ? 有什么特点？"></a>— 原型，原型链 ? 有什么特点？</h3><p>JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象</p>
<p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</p>
<p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p>
<h3 id="—-如何实现上拉加载，下拉刷新？"><a href="#—-如何实现上拉加载，下拉刷新？" class="headerlink" title="— 如何实现上拉加载，下拉刷新？"></a>— 如何实现上拉加载，下拉刷新？</h3><p>开源社区有很多优秀的解决方案，如iscroll、better-scroll、pulltorefresh.js库等等</p>
<h3 id="—-说说你对作用域链的理解"><a href="#—-说说你对作用域链的理解" class="headerlink" title="— 说说你对作用域链的理解"></a>— 说说你对作用域链的理解</h3><p>1、作用域就是变量与函数的可访问范围<br>2、一般情况下，变量取值到创建这个变量的函数的作用域中取值。 但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链</p>
<!-- ### — 浏览器内核 -->
<h3 id="—-浏览器输入Url之后发生了什么？"><a href="#—-浏览器输入Url之后发生了什么？" class="headerlink" title="— 浏览器输入Url之后发生了什么？"></a>— 浏览器输入Url之后发生了什么？</h3><p>浏览器输入URL链接 -&gt; 回车 -&gt; 浏览器查找当前URL是否有本地缓存 -&gt; dns解析URL对应的IP -&gt; 根据IP建立TCP连接(三次握手) -&gt; 发起http请求 -&gt; 服务器处理请求 -&gt;  关闭TCP连接(四次握手) -&gt; 浏览器根据发回的response响应，启用浏览器的渲染引擎和JS引擎，更具HTML/CSS/JS/IMG等等渲染页面。</p>
<h4 id="从输入URL到页面加载的主干流程如下："><a href="#从输入URL到页面加载的主干流程如下：" class="headerlink" title="从输入URL到页面加载的主干流程如下："></a>从输入URL到页面加载的主干流程如下：</h4><p>1、浏览器的地址栏输入URL并按下回车。</p>
<p>2、浏览器查找当前URL的DNS缓存记录。</p>
<p>3、DNS解析URL对应的IP。</p>
<p>4、根据IP建立TCP连接（三次握手）。</p>
<p>5、HTTP发起请求。</p>
<p>6、服务器处理请求，浏览器接收HTTP响应。</p>
<p>7、渲染页面，构建DOM树。</p>
<p>8、关闭TCP连接（四次挥手）。</p>
<h5 id="1-首先在浏览器中输入URL"><a href="#1-首先在浏览器中输入URL" class="headerlink" title="1.首先在浏览器中输入URL"></a>1.首先在浏览器中输入URL</h5><p>我们常见的RUL是这样的:<br><a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a><br>这个域名由三部分组成：协议名、域名、端口号，这里端口是默认所以隐藏。除此之外URL还会包含一些路径、查询和其他片段<br>例如：<a href="http://www.tuicool.com/search?kw=%E4%。" target="_blank" rel="noopener">http://www.tuicool.com/search?kw=%E4%。</a><br>我们最常见的的协议是HTTP协议，除此之外还有加密的HTTPS协议、FTP协议、FILe协议等等。URL的中间部分为域名或者是IP，之后就是端口号了。通常端口号不常见是因为大部分的都是使用默认端口，如HTTP默认端口80，HTTPS默认端口443。</p>
<ul>
<li><p>查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。</p>
</li>
<li><p>浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；</p>
</li>
<li><p>操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；</p>
</li>
<li><p>路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；</p>
</li>
<li><p>ISP缓存：若上述均失败，继续向ISP搜索。</p>
</li>
</ul>
<h5 id="2-DNS域名解析"><a href="#2-DNS域名解析" class="headerlink" title="2.DNS域名解析"></a>2.DNS域名解析</h5><p>我们知道在地址栏输入的域名并不是最后资源所在的真实位置，域名只是与IP地址的一个映射。网络服务器的IP地址那么多，我们不可能去记一串串的数字，因此域名就产生了，域名解析的过程实际是将域名还原为IP地址的过程。</p>
<p>首先浏览器先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。</p>
<p>如果没找到则会查找本地DNS解析器缓存，如果查找到则返回。</p>
<p>如果还是没有找到则会查找本地DNS服务器，如果查找到则返回。</p>
<p>最后迭代查询，按根域服务器 -&gt;顶级域,.cn-&gt;第二层域，hb.cn -&gt;子域，<a href="http://www.hb.cn的顺序找到IP地址。" target="_blank" rel="noopener">www.hb.cn的顺序找到IP地址。</a></p>
<p>DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</p>
<h5 id="3-建立TCP连接：-解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接"><a href="#3-建立TCP连接：-解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接" class="headerlink" title="3.建立TCP连接： 解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接"></a>3.建立TCP连接： 解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接</h5><p>发起HTTP请求： 浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器</p>
<p>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器</p>
<p>关闭TCP连接 ： 通过四次挥手释放TCP连接</p>
<p>浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析</p>
<p><strong>构建DOM树：</strong>词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象</p>
<p>构建CSS规则树：生成CSS规则树（CSS Rule Tree）<br>构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）<br>布局（Layout）：计算出每个节点在屏幕中的位置<br>绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。<br>JS引擎解析过程：<br>调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</p>
<p>创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。<br>加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译<br>预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为’undefined’；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。<br>解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。<br>浏览器重绘与重排的区别？<br>重排/回流（Reflow）：当DOM的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。<br>重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变<br>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分<br>重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。<br>『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。<br>如何触发重排和重绘？<br>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p>
<p>添加、删除、更新DOM节点<br>通过display: none隐藏一个DOM节点-触发重排和重绘<br>通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化<br>移动或者给页面中的DOM节点添加动画<br>添加一个样式表，调整样式属性<br>用户行为，例如调整窗口大小，改变字号，或者滚动。<br>如何避免重绘或者重排？<br>集中改变样式，不要一条一条地修改 DOM 的样式。</p>
<p>不要把 DOM 结点的属性值放在循环里当成循环里的变量。</p>
<p>为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。</p>
<p>不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</p>
<p>尽量只修改position：absolute或fixed元素，对其他元素影响不大</p>
<p>动画开始GPU加速，translate使用3D变化</p>
<p>提升为合成层</p>
<blockquote>
<p>将元素提升为合成层有以下优点：<br>合成层的位图，会交由 GPU 合成，比 CPU 处理要快<br>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层<br>对于 transform 和 opacity 效果，不会触发 layout 和 paint<br>提升合成层的最好方式是使用 CSS 的 will-change 属性：#target {will-change: transform;}</p>
</blockquote>
<h3 id="谈谈你对promise、axios的理解"><a href="#谈谈你对promise、axios的理解" class="headerlink" title="谈谈你对promise、axios的理解"></a>谈谈你对promise、axios的理解</h3><p><strong><em>promise</em></strong> 是 js 用来处理所有异步操作的<br>传统的方式处理异步操作，就是 ajax 嵌套 ajax,就是常说的回调地狱，是非常难维护，而 promise 有 resolive 和 reject 这两个方法，将成功和失败返回的数据，传递给使用者，promise 开始的状态是 pending ，当成功或者失败的时候，状态会切换到 fulfilled(成功)或者rejected（失败）状态，把结果通过then()或者catch()交出去。<br>promise 不仅仅一次处理一个异步请求，它还有两个方法，all() 和 race() ,all() 只有在里面所有的异步操作都成功才算是成功，race() 只有在一个异步请求成功就会往后面继续执行代码。</p>
<h3 id="webpack-构建优化怎么搞？"><a href="#webpack-构建优化怎么搞？" class="headerlink" title="webpack 构建优化怎么搞？"></a>webpack 构建优化怎么搞？</h3><p>webpack构建的时候，需要找出所有模块文件进行编译处理，那么我们可以在以下几个点上做优化处理：</p>
<ol>
<li>缩小文件的搜索范围，用alias extensions等配置缩小范围</li>
<li>减少需要解析的文件，使用 noParse配置告诉webpack 排除指定的文件，不对它们进行解析</li>
<li>避免重复编译第三方库，可以吧第三方文件库单独打包到一个文件夹中，他不会跟着业务代码一起重新打包</li>
</ol>
<p>构建的时候，如果对多个js文件需要被压缩，他会一个一个的进行压缩，可以使用 parallelUglifyPlugin插件来开启多个子进程，采用并行方式对多个js文件进行压缩</p>
<h2 id="vue相关"><a href="#vue相关" class="headerlink" title="vue相关"></a>vue相关</h2><h3 id="什么是mvvm"><a href="#什么是mvvm" class="headerlink" title="什么是mvvm?"></a>什么是mvvm?</h3><p>modal + view + viewModal的缩写，是modal驱动view的渐进式框架，不需要直接操作dom来实现页面的改变。<br>1）View 层<br>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。<br>（2）Model 层<br>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。<br>（3）ViewModel 层<br>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。</p>
<p>（1）View 层<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button v-on:click="showMessage()"&gt;Click me&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>（2）ViewModel 层<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data: &#123;  <span class="comment">// 用于描述视图状态</span></span><br><span class="line">        message: <span class="string">'Hello Vue!'</span>, </span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;  <span class="comment">// 用于描述视图行为</span></span><br><span class="line">        showMessage()&#123;</span><br><span class="line">            <span class="keyword">let</span> vm = <span class="keyword">this</span>;</span><br><span class="line">            alert(vm.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        <span class="keyword">let</span> vm = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// Ajax 获取 Model 层的数据</span></span><br><span class="line">        ajax(&#123;</span><br><span class="line">            url: <span class="string">'/your/server/data/api'</span>,</span><br><span class="line">            success(res)&#123;</span><br><span class="line">                vm.message = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>（3） Model 层<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"/your/server/data/api"</span>,</span><br><span class="line">    <span class="string">"res"</span>: &#123;</span><br><span class="line">        <span class="string">"success"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"IoveC"</span>,</span><br><span class="line">        <span class="string">"domain"</span>: <span class="string">"www.cnblogs.com"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Vue-是如何实现数据双向绑定的？"><a href="#Vue-是如何实现数据双向绑定的？" class="headerlink" title="Vue 是如何实现数据双向绑定的？"></a>Vue 是如何实现数据双向绑定的？</h3><p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据.<br>即：</p>
<ul>
<li><p>输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。</p>
</li>
<li><p>Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。</p>
</li>
</ul>
<p>其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。</p>
<h3 id="Vue-框架怎么实现对象和数组的监听？"><a href="#Vue-框架怎么实现对象和数组的监听？" class="headerlink" title="Vue 框架怎么实现对象和数组的监听？"></a>Vue 框架怎么实现对象和数组的监听？</h3><p>通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持。<br>同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observe a list of Array items.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observe(items[i])  <span class="comment">// observe 功能为监测数据的变化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对属性进行递归遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val) <span class="comment">// observe 功能为监测数据的变化</span></span><br></pre></td></tr></table></figure>
<p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p>
<h3 id="Proxy-与-Object-defineProperty-优劣对比"><a href="#Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="Proxy 与 Object.defineProperty 优劣对比"></a>Proxy 与 Object.defineProperty 优劣对比</h3><p><strong><em>Proxy 的优势如下:</em></strong></p>
<ul>
<li>Proxy 可以直接监听对象而非属性；</li>
<li>Proxy 可以直接监听数组的变化；</li>
<li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li>
<li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li>
<li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li>
</ul>
<p><strong><em>Object.defineProperty 的优势如下:</em></strong></p>
<p>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</p>
<h3 id="Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？"><a href="#Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？" class="headerlink" title="Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？"></a>Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</h3><p>受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。<br>由于 Vue 会在初始化实例时对属性执行 <code>getter/setter</code> 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。<br>但是 Vue 提供了 <code>Vue.set (object, propertyName, value)</code> / <code>vm.$set (object, propertyName, value)</code>来实现为对象添加响应式属性，那框架本身是如何实现的呢？<br>我们查看对应的 Vue 源码：<code>vue/src/core/instance/index.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target: Array&lt;any&gt; | Object, key: any, val: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// target 为数组</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    <span class="comment">// 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span></span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    <span class="comment">// 利用数组的splice变异方法触发响应式</span></span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// key 已经存在，直接修改属性值</span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line">  <span class="comment">// target 本身就不是响应式数据, 直接赋值</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对属性进行响应式处理</span></span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们阅读以上源码可知，<code>vm.$set</code> 的实现原理是：</p>
<ul>
<li>如果目标是数组，直接使用数组的 <code>splice</code> 方法触发相应式；</li>
<li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 <code>defineReactive</code> 方法进行响应式处理（ <code>defineReactive</code> 方法就是 Vue 在初始化对象时，给对象属性采用 <code>Object.defineProperty</code> 动态添加 <code>getter</code> 和 <code>setter</code> 的功能所调用的方法）</li>
</ul>
<h3 id="生命周期函数有哪些"><a href="#生命周期函数有哪些" class="headerlink" title="生命周期函数有哪些"></a>生命周期函数有哪些</h3><ul>
<li>beforeCreate 实例刚在内存中被创建出来，此时dom data methods 都是取不到的</li>
<li>created 实例已经在内存中创建出来，此时dom 是取不到的 data methods可以取到</li>
<li>beforeMount 此时已经完成了模板的编译，但是还没有挂载到页面上，此时dom 是取不到的 data methods可以取到</li>
<li>mounted 已经将编译好的模板，挂载到了页面指定的容器中显示,dom data methods都可以取到</li>
<li>beforeUpdate 状态更新之前执行此函数，此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始重新渲染DOM节点</li>
<li>updated 实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了</li>
<li>beforeDestory 实例销毁之前调用，在这一步，实例仍然完全可用</li>
<li>destoryed Vue实例销毁之后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁</li>
</ul>
<blockquote>
<p><strong>调用解耦一般在那个生命周期函数中执行？</strong><br>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。<br>但是推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：<br><u>1.能更快获取到服务端数据，减少页面loading 时间；</u><br><u>2.ssr不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</u></p>
</blockquote>
<p>但是 <strong><em>具体的需求</em></strong> 需要具体的分析：</p>
<p>比如：如果一个页面里面用到了三个子组件，<br>页面初始化进来的生命周期执行的顺序是：<br>父 beforeCreate -&gt; created -&gt; beforeMount<br>子1 beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted<br>子2 beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted<br>子3 beforeCreate -&gt; created -&gt; beforeMount -&gt; mounted<br>父 mounted</p>
<blockquote>
<p>那么就应该父组件的调用接口逻辑放到 mounted ,子组件的调用接口放到 created , 这样就避免了父组件里面接口调用阻塞子组件的接口返回，使得子组件的数据先显示到页面中去。</p>
</blockquote>
<h3 id="为什么使用虚拟dom"><a href="#为什么使用虚拟dom" class="headerlink" title="为什么使用虚拟dom"></a>为什么使用虚拟dom</h3><ul>
<li>创建真实DOM的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。</li>
<li>触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，以减少浏览器的重绘及回流。<br>1). 重绘：元素样式的改变（但宽高、大小、位置等不变）<br>如：outline、visibility、color、background-color等<br>只改变自身样式，不会影响到其他元素<br>2). 回流：元素的大小或者位置发生改变（当页面布局和几何信息发生改变的时候），触发了重新布局导致渲染树重新计算布局和渲染<br>​ 如添加或删除可见的DOM元素；元素的位置发生变化；元素的尺寸发生变化、内容发生变化（如文本变化或图片被另一个不同尺寸的图片所代替）；页面一开始渲染的时候（无法避免）；<br>​因为回流是根据视口大小来计算元素的位置和大小的，所以浏览器窗口尺寸变化也会引起回流</li>
</ul>
<blockquote>
<p>注意：回流一定会触发重绘，而重绘不一定会回流</p>
</blockquote>
<ul>
<li>虚拟dom由于本质是一个js对象，因此天生具备跨平台的能力，可以实现在不同平台的准确显示。</li>
<li>Virtual DOM 在性能上的收益并不是最主要的，更重要的是它使得 Vue 具备了现代框架应有的高级特性。</li>
</ul>
<h3 id="Vue中key是用来做什么的？为什么不推介使用index作为key？"><a href="#Vue中key是用来做什么的？为什么不推介使用index作为key？" class="headerlink" title="Vue中key是用来做什么的？为什么不推介使用index作为key？"></a>Vue中key是用来做什么的？为什么不推介使用index作为key？</h3><blockquote>
<p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p>
</blockquote>
<p>为什么会更快速，更准确呢，下面来看vnode中关于节点更新复用的详情情况<br>在diff中比较两个节点是否可以复用，主要通过下面sameVnode函数来判断</p>
<p><img src="/images/img-folder/2023/vnode.png"></p>
<ul>
<li>key：列表上每一项设置的key值</li>
<li>data：render函数中设置的一些属性</li>
<li>sel：标签和id或者class，例如 div#app.item，表示div标签有一个id：app，class：item</li>
</ul>
<h4 id="当我们没有设置key值的情况"><a href="#当我们没有设置key值的情况" class="headerlink" title="当我们没有设置key值的情况"></a>当我们没有设置key值的情况</h4><p>默认是undefined，undefined===undefined = true</p>
<p>因为是列表，所以标签，class，属性基本上是一样，只是里面内容不一样，通过调用上诉函数，可以判断出：可以复用的dom<br>我们来设想一下，如果我们有一个列表，然后我们在列表的头部新增一条数据<br>1、首先会比较新增的vnode和老元素第一个元素比较，因为sameVnode返回true，标签可以复用，修改里面的内容<br>2、比较第二个元素，是不是sameVnode返回的还是true，标签复用，修改列面的内容，以此类推，是不每一个节点都要替换内容<br>3、如果我们列表每一项有一个chekbox元素，勾选的第一项，再插入新元素的时候，是不是你插入的节点被勾选了，这样是不是就不对了，有问题<br>4、而且每一个元素都替换，是不是特别慢，并且列表需要全部重新渲染，大大的影响的性能</p>
<blockquote>
<p>把key值设置成index，有什么问题吧，为什么说最好不要设置成index</p>
</blockquote>
<p>1、列表每一项设置了一个index值，从0、1、2、3、4、5</p>
<p>2、当我们在头部插入一个节点，是不是插入的节点就变成0，原来的0、1、2、3、4都加一位，我们来diff比较的时候，是不是每一项又都不一样了，sameVnode返回的都是false，标签不能复用，都要重新创建一个，插入到节点中，这样是不是也全部需要重新渲染，影响性能</p>
<h4 id="如果设置了key，且key值固定的情况"><a href="#如果设置了key，且key值固定的情况" class="headerlink" title="如果设置了key，且key值固定的情况"></a>如果设置了key，且key值固定的情况</h4><p>下面我们来把key设置成唯一的值，且是固定的值，当我们在头部插入一个节点，这个节点的key没有一样的，我们就创建一个，插入到头部</p>
<p>后面的节点，是不是sel没有变，标签没有变，key值也没有变，是不是节点全部都可以复用，只是把位置挪动下，实际上就只创建了一个元素，这样就可以大大加快渲染速度</p>
<p>这就是我们所说的diff操作更加准确，更快速的原因</p>
<h3 id="v-show和v-if的区别"><a href="#v-show和v-if的区别" class="headerlink" title="v-show和v-if的区别"></a>v-show和v-if的区别</h3><p>v-show原理是修改元素的css属性display:none来决定是显示还是隐藏</p>
<p>v-if则是通过操作DOM来进行切换显示</p>
<h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p>实现mvvm的双向绑定，是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<h3 id="常用的指令？常用的内置组件有哪些？"><a href="#常用的指令？常用的内置组件有哪些？" class="headerlink" title="常用的指令？常用的内置组件有哪些？"></a>常用的指令？常用的内置组件有哪些？</h3><p>常用指令：<br>v-html v-text v-modal v-if v-show v-hide v-once v-on v-for v-slot v-pre</p>
<p>常用内置组件<br>transition 动画<br>keepAlive 多个组件动态切换时缓存被移除的组件实例</p>
<h3 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a>computed 和 watch 的区别</h3><h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><p>computed有缓存，关联的data里面的数据不变则不会重新计算，遇到双向绑定的属性值即v-model的属性值需要使用 get()和set(),才能监听</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;num &#123;&#123;num&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;double1 &#123;&#123;double1&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;input v-model=<span class="string">"double2"</span>/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            num: <span class="number">20</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        double1() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.num * <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        double2: &#123;<span class="comment">//双向绑定的值需要使用get()和set()</span></span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.num * <span class="number">2</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>(val) &#123;</span><br><span class="line">                <span class="keyword">this</span>.num = val/<span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>计算属性的特点</strong></p>
<ul>
<li>支持缓存，只有依赖数据发生改变，才会重新进行计算,否则只会执行一次</li>
<li>不支持异步，当 computed 内有异步操作时无效</li>
<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed</li>
<li>如果 computed 属性属性值是函数，那么默认会走 get() ；函数的返回值就是属性的属性值；在 computed 中的，属性都有一个 get() 和一个 set()，当数据变化时，调用 set()。</li>
</ul>
</blockquote>
<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>监听引用类型需要深度监测，而且是拿不到oldVal，值类型不需要深度监听<br>其可以监听的数据来源：data，props，computed 内的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input v-model=<span class="string">"name"</span>/&gt;</span><br><span class="line">        &lt;input v-model=<span class="string">"info.city"</span>/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: <span class="string">'小宋'</span>,</span><br><span class="line">            info: &#123;</span><br><span class="line">                city: <span class="string">'北京'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        name(oldVal, val) &#123;</span><br><span class="line">            <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'watch name'</span>, oldVal, val) <span class="comment">// 值类型，可正常拿到 oldVal 和 val</span></span><br><span class="line">        &#125;,</span><br><span class="line">        info: &#123;</span><br><span class="line">            handler(oldVal, val) &#123;</span><br><span class="line">                <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'watch info'</span>, oldVal, val) <span class="comment">// 引用类型，拿不到 oldVal 。因为指针相同，此时已经指向了新的 val</span></span><br><span class="line">            &#125;,</span><br><span class="line">            deep: <span class="literal">true</span> <span class="comment">// 深度监听</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>监听的特点</strong></p>
<ul>
<li>主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，可以看作是 computed 和 methods 的结合体；</li>
<li>可以监听的数据来源：data，props，computed 内的数据；</li>
<li>watch 支持异步；</li>
<li>不支持缓存，监听的数据改变，直接会触发相应的操作；</li>
<li>监听函数有两个参数，第一个参数是最新的值，第二个参数是输入之前的值，顺序一定是新值，旧值。</li>
</ul>
</blockquote>
<h3 id="vue自定义指令设置"><a href="#vue自定义指令设置" class="headerlink" title="vue自定义指令设置"></a>vue自定义指令设置</h3><ul>
<li>全局: Vue.directive(‘指令名称，不需要写v-开头’,对象或函数)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'test'</span>,&#123;</span><br><span class="line">	bind(el,bind)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(el)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.directive(<span class="string">'red'</span>, &#123;</span><br><span class="line">    <span class="comment">// bind 第一次绑定到元素时调用</span></span><br><span class="line">    bind(el, bindings) &#123;</span><br><span class="line">        el.style.cssText = <span class="string">`color:red;font-size:30px`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>私有<br>在组件中的</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	directives: &#123;</span><br><span class="line">		test:&#123;</span><br><span class="line">			bind(el,bind)&#123;&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">// bind/update</span></span><br><span class="line">		test2(el,bind)&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义局部指令，只有当前的实例能用</span></span><br><span class="line">directives: &#123;</span><br><span class="line">    red: &#123;</span><br><span class="line">        <span class="comment">// bind它还没有绑定到父元素中,初始化</span></span><br><span class="line">        bind(el) &#123;</span><br><span class="line">            el.style.cssText = <span class="string">`color:red;font-size:30px`</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="父子组件之间的通信"><a href="#父子组件之间的通信" class="headerlink" title="父子组件之间的通信"></a>父子组件之间的通信</h3><p>父传子：通过props来传递<br>父组件(:变量名) -&gt; 子组件([props])来接收<br>子传父：$emit/$on<br>子组件($emit(‘事件名’，值)) -&gt; 父组件(@事件名=’aa’,aa(传递的值))来接收<br>兄弟组件：创建一个事件中心 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Hub = <span class="keyword">new</span> Vue()</span><br><span class="line">Hub.$emit(<span class="string">'change'</span>, 值) <span class="comment">// Hub触发事件</span></span><br><span class="line">Hub.$on(<span class="string">'change'</span>, ()=&gt;&#123;</span><br><span class="line">  <span class="comment">// Hub接收事件</span></span><br><span class="line">  <span class="keyword">this</span>.msg = 值</span><br><span class="line">&#125;)</span><br><span class="line">通过Hub.$off()方法名销毁之后无法进行传递数据</span><br></pre></td></tr></table></figure>
<p>详细介绍：<a href="http://shuy.cc/2019/04/27/jc-6/" target="_blank" rel="noopener">http://shuy.cc/2019/04/27/jc-6/</a></p>
<h3 id="路由跳转的方式，传参方式有哪些？"><a href="#路由跳转的方式，传参方式有哪些？" class="headerlink" title="路由跳转的方式，传参方式有哪些？"></a>路由跳转的方式，传参方式有哪些？</h3><p>1). 标签<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">"&#123;name: '路由名'&#125;"</span></span><br></pre></td></tr></table></figure></p>
<p>2). 动态路由<br>App.vue</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">"'/user/' + userId"</span>&gt;用户&lt;<span class="regexp">/router-link&gt;</span></span><br></pre></td></tr></table></figure>
<p>router.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">path</span>: <span class="string">'/user/:userId'</span>&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">"&#123;name: 'users', params: &#123;id: 12&#125;&#125;"</span>&gt;用户&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">this.$route.push(&#123;name: 'users', params: &#123;id: 12&#125;&#125;)</span></span><br><span class="line"><span class="regexp">this.$route.push('/u</span>ser/<span class="number">12</span><span class="string">')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 获取：$route.params.id</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=<span class="string">"&#123;path: '/profile', query: &#123;id: 12&#125;&#125;"</span>&gt;档案&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;router-link :to="&#123;name: '/u</span>sers<span class="string">', query: &#123;id: 12&#125;&#125;"&gt;档案&lt;/router-link&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">aa() &#123;</span></span><br><span class="line"><span class="string">  this.$router.push(&#123;</span></span><br><span class="line"><span class="string">    path: '</span>/profile<span class="string">',</span></span><br><span class="line"><span class="string">    query: &#123;</span></span><br><span class="line"><span class="string">      name: '</span>yaoyao<span class="string">',</span></span><br><span class="line"><span class="string">      id: 12</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 获取：$route.query.id</span></span><br></pre></td></tr></table></figure>
<h3 id="router-和-route的区别"><a href="#router-和-route的区别" class="headerlink" title="router 和 route的区别"></a>router 和 route的区别</h3><ul>
<li>$route对象<br>表示当前的所有的路由信息，包括路径，参数，query对象等</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'../views/layout/Layout'</span></span><br><span class="line"><span class="keyword">const</span> asyncRoutes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/product-define'</span>,</span><br><span class="line">    component: Layout,</span><br><span class="line">    redirect: <span class="string">'/product-define/'</span>,</span><br><span class="line">    name: <span class="string">'ProductDefineManagement'</span>,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      title: <span class="string">'产品定义定价'</span>,</span><br><span class="line">      icon: <span class="string">'icon-dingyidingjia'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'CarType'</span>,</span><br><span class="line">        name: <span class="string">'CarType'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/product_define/CarType'</span>),</span><br><span class="line">        meta: &#123; <span class="attr">title</span>: <span class="string">'车型'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>$route.path 路径<br>  $route.params 一个key: val对象<br>  $route.query 一个key: val对象<br>  $route.hash #号后面的数据<br>  $route.fullPath url，包含参数和hash完整路径<br>  $route.matched 数组，常用作面包屑<br>  $route.name 当前路由的名称<br>  $route.meta 路由元信息，一些额外标注参数</p>
</blockquote>
<ul>
<li>$router对象：是全局的路由实例。</li>
</ul>
<h3 id="编程式导航的使用方法"><a href="#编程式导航的使用方法" class="headerlink" title="编程式导航的使用方法"></a>编程式导航的使用方法</h3><p>1.路由的跳转<br>this.$router.push()<br>2.路由替换<br>this.$router.replace()<br>3.后退<br>this$router.back()<br>4.前进<br>this.$router.forward()<br>5.前进后退<br>this.$router.go() -1为后退<br>6.配置路由常用参数</p>
<ul>
<li>path 路径</li>
<li>component 路由相对于组件的路径</li>
<li>name 路由的名称</li>
<li>children 嵌套路由的子组件的配置项 </li>
<li>props 路由解耦</li>
<li>redirect 路由重定向</li>
</ul>
<h3 id="什么是路由守卫？路由的钩子函数有哪些？"><a href="#什么是路由守卫？路由的钩子函数有哪些？" class="headerlink" title="什么是路由守卫？路由的钩子函数有哪些？"></a>什么是路由守卫？路由的钩子函数有哪些？</h3><p>路由守卫：路由跳转前后的一些验证<br>路由钩子函数：</p>
<ul>
<li>beforeRouterEnter 当路由跳转之前（登录之前）</li>
<li>beforeRouterUpdate 当路由进行更新的时候，如果当前路由发生了变化，但是不需要组件进行销毁</li>
<li>beforeRouterLeave 当路由离开的时候（当用户没有支付离开的时候、当用户填写完用户信息没有保存的时候）</li>
<li>beforeEach 全局守卫，验证用户是否登录 </li>
</ul>
<h3 id="vuex的理解"><a href="#vuex的理解" class="headerlink" title="vuex的理解"></a>vuex的理解</h3><p>vuex是专门为vue开发的一款状态管理库，主要采用集中管理应用所有的组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<ul>
<li>state 保存应用的全部状态的对象 this.$store.state(key)</li>
<li>Getter 其实就是state通过计算属性，衍变出的新的状态 this.$store.getters(key)</li>
<li>Mutation 包含一个字符窜名称和回调函数，必须是同步函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  name(state) &#123;</span><br><span class="line">    state.count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>它其实就是操作state的，它不能直接调用，这更像是一个事件注册，需要 store.commit(‘name’)来调用对应的mutation</p>
</blockquote>
<ul>
<li>action 类似于mutation,但是action提交的数mutation，并且是异步的，使用commit(‘mutation名’)来调用，action使用dispatch来调用</li>
</ul>
<blockquote>
<p>在main.js引入store，注入。新建了一个store目录，然后….. export 。 场景：单页应用中，组件之间的共享状态和方法 state Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。 mutations mutations定义的方法动态修改Vuex 的 store 中的状态或数据。 getters 类似vue的计算属性，主要用来过滤一些数据。 action actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。 modules 项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。</p>
</blockquote>
<p>快速掌握vuex常用的所有api用法: <a href="http://shuy.cc/2019/07/24/vuex/" target="_blank" rel="noopener">http://shuy.cc/2019/07/24/vuex/</a></p>
<h3 id="你有对-Vue-项目进行哪些优化？"><a href="#你有对-Vue-项目进行哪些优化？" class="headerlink" title="你有对 Vue 项目进行哪些优化？"></a>你有对 Vue 项目进行哪些优化？</h3><p>如果没有对 Vue 项目没有进行过优化总结的同学，可以参考本文作者的另一篇文章《 Vue 项目性能优化 — 实践指南 》，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。<br>（1）代码层面的优化</p>
<ul>
<li>v-if 和 v-show 区分使用场景</li>
<li>computed 和 watch 区分使用场景</li>
<li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li>
<li>长列表性能优化</li>
<li>事件的销毁</li>
<li>图片资源懒加载</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入</li>
<li>优化无限列表性能</li>
<li>服务端渲染 SSR or 预渲染</li>
</ul>
<p>（2）Webpack 层面的优化</p>
<ul>
<li>Webpack 对图片进行压缩</li>
<li>减少 ES6 转为 ES5 的冗余代码</li>
<li>提取公共代码</li>
<li>模板预编译</li>
<li>提取组件的 CSS</li>
<li>优化 SourceMap</li>
<li>构建结果输出分析</li>
<li>Vue 项目的编译优化</li>
</ul>
<p>（3）基础的 Web 技术的优化</p>
<ul>
<li>开启 gzip 压缩</li>
<li>浏览器缓存</li>
<li>CDN 的使用</li>
<li>使用 Chrome Performance 查找性能瓶颈</li>
</ul>
<h3 id="登陆权限的实现"><a href="#登陆权限的实现" class="headerlink" title="登陆权限的实现"></a>登陆权限的实现</h3><h4 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h4><p>在登陆页面，前端需要进行表单校验，通过前端校验，过滤拦截一些不符合规则的参数请求，然后调用后端的提供登陆接口，将符合规则的参数传递给后端，后端接受到请求后，会获取这个请求携带的参数，这些参数通常会有用户名、密码一级验证码、然后来验证这些参数，如果验证不通过，前端将后端提供的错误提示提示给用户即可，如果验证通过，那么就会生成一个token，并且返回给前端，前端接受到这个token之后，需要将这个token保存在本地，在我们下次去调用需要携带token的接口时，通常会将这个token塞入到请求头中，一并发送给后端，那么将token 添加到请求头中，我们通常会去封装一个请求方法，在这个请求方法中完成给请求头添加token的操作，我们在本地保存token，是因为有的页面是需要登录才可以进入的，那么我们就可以通过路由守卫来判断当前本地有没有token，如果没有token就跳转到登录页面，如果你的项目做了token过期之后会自动刷新这个token，然后继续完成请求这么一个功能，那么就更好了，</p>
<h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>路由控制的核心包含用户、角色、菜单，用户和角色具备某种关联关系，而角色和菜单具备某种关联关系，所以用户和菜单会通过角色产生关联关系，那对应到后台页面上，首先我们会创建好菜单，然后在创建角色，在创建角色的时候，可以给角色分配菜单，最好当创建用户账号时，就可以给这个用户分配角色，那么当登陆该账号的时候，前端会请求一次后端提供的返回了用户所具备菜单列表的数据接口，然后在前端代码定义路由时，我们会维护两份路由，一份是静态路由，他是所有用户都可以访问的路由，直接挂载在路由实例上即可，还有一份是动态路由，这份路由会根据当前用户所具备的菜单进行筛选asyncRoutes.forEach((item)=&gt;{<br>    If(menus.find(menu))<br>})<br>最后筛选出的路由，通过addRoute这个方法，动态添加上去，这一步通常会在路由守卫中完成（router.beforeEach）,遍历这份动态路由（asyncRoutes.forEach），判断当前遍历项是否存在于后端返回的菜单列表中，那返回一个筛选完成的路由数组，最后我们就可以用这份路由数组去渲染菜单栏了。</p>
<h2 id="小程序相关"><a href="#小程序相关" class="headerlink" title="小程序相关"></a>小程序相关</h2><h3 id="生命周期函数有哪些？小程序的周期函数？"><a href="#生命周期函数有哪些？小程序的周期函数？" class="headerlink" title="生命周期函数有哪些？小程序的周期函数？"></a>生命周期函数有哪些？小程序的周期函数？</h3><p>生命周期函数：<br>onLoad 监听页面加载，一个页面只调用1次<br>onReady 监听页面初次渲染完成，一个页面只调用1次<br>onShow 监听页面显示<br>onHide 监听页面隐藏<br>onUnLoad 监听页面卸载<br>小程序周期函数：<br>onLaunch 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）。可以做一些初始化的工作<br>onShow 当小程序启动，或从后台进入前台显示，会触发 onShow<br>onHide 当小程序从前台进入后台，会触发 onHide</p>
<h3 id="应用与页面生命周期发生顺序"><a href="#应用与页面生命周期发生顺序" class="headerlink" title="应用与页面生命周期发生顺序"></a>应用与页面生命周期发生顺序</h3><p>应用onLaunch -&gt; 应用onShow -&gt; 页面page -&gt; onLoad -&gt; onShow -&gt; onReady</p>
<h3 id="小程序是如何传值？"><a href="#小程序是如何传值？" class="headerlink" title="小程序是如何传值？"></a>小程序是如何传值？</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindTap</span>=<span class="string">"get"</span> <span class="attr">id</span>=<span class="string">'123'</span> <span class="attr">data-name</span>=<span class="string">"按钮名"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>(e) &#123;</span><br><span class="line">  <span class="keyword">let</span> id = e.currentTarget.id</span><br><span class="line">  <span class="keyword">let</span> name = e.currentTarget.dataset.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="wxss和css的区别"><a href="#wxss和css的区别" class="headerlink" title="wxss和css的区别"></a>wxss和css的区别</h3><ul>
<li>wxss背景图只能引入外联，不能使用本地图片</li>
<li>小程序使用@important引入外链样式，地址为相对路径</li>
<li>单位为rpx，是响应式像素，可根据屏幕宽度做自适应</li>
</ul>
<h3 id="小程序是如何传递数据？"><a href="#小程序是如何传递数据？" class="headerlink" title="小程序是如何传递数据？"></a>小程序是如何传递数据？</h3><ul>
<li>在app.js中，this.globalData={}中存放数据，在组件.js中，头部引入const app = getApp(),来获取全局变量，直接使用app.globalData.key来获取变量</li>
<li>使用路由，wx.navigation/redircetTo/url+参数等方式，在页面onLoad(e),通过e.key来获取参数</li>
<li>本地缓存，如storage等存储数据</li>
</ul>
<h3 id="webview的理解"><a href="#webview的理解" class="headerlink" title="webview的理解"></a>webview的理解</h3><p>在小程序中嵌套H5页面，域名必须在白名单里面</p>
<h3 id="小程序和h5页面的交互"><a href="#小程序和h5页面的交互" class="headerlink" title="小程序和h5页面的交互"></a>小程序和h5页面的交互</h3><p><a href="http://shuy.cc/2020/06/09/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%92%8Ch5%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BA%A4%E4%BA%92" target="_blank" rel="noopener">http://shuy.cc/2020/06/09/%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%92%8Ch5%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BA%A4%E4%BA%92</a></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1.rpx，规定屏幕宽度为750rpx，可适配不同的屏幕宽度<br>2.本地资源wxss无法获取，bgimg可使用网络图片，base64,或者使用标签来引入<br>3.navigateTo，一个应用同时能发开5个页面或者使用redirct</p>
<h3 id="小程序的双向绑定和vue的有什么区别"><a href="#小程序的双向绑定和vue的有什么区别" class="headerlink" title="小程序的双向绑定和vue的有什么区别"></a>小程序的双向绑定和vue的有什么区别</h3><p>小程序必须使用this.setState({key:val})来更新数据，直接赋值不能更新页面变化</p>
<h3 id="下拉刷新的实现方法"><a href="#下拉刷新的实现方法" class="headerlink" title="下拉刷新的实现方法"></a>下拉刷新的实现方法</h3><p>app.json中，将’enablePullDownFresh’: true,开启全局下拉刷新，组件.json中，将’enablePullDownFresh’: true,开启单页下拉刷新，组件中的onPullDownRefresh写加载的逻辑，wx.stopPullDownRefresh()更新完数据，停止更新。</p>
<h3 id="跳转的方式有哪些"><a href="#跳转的方式有哪些" class="headerlink" title="跳转的方式有哪些"></a>跳转的方式有哪些</h3><ul>
<li>wx.navigateTo() 保留当前页，跳转到应用指定页面，不能跳转tabar页面</li>
<li>wx.redircetTo() 关闭当前页，跳转到应用指定页面，不能跳转tabar页面</li>
<li>wx.relaunch() 关闭所有页，打开到应用内的某个页面（应用场景：登陆跳转到其他页面）</li>
<li>wx.switchTo() 跳转到tabbar页面，关闭其他非tabar页面</li>
<li>wx.navigateBack() 关闭当前页，返回上一级或多级页面，可通过getCurrentPages()获取当前的页面栈，决定要返回第几层</li>
</ul>
<h3 id="描述一下小程序的登陆流程"><a href="#描述一下小程序的登陆流程" class="headerlink" title="描述一下小程序的登陆流程"></a>描述一下小程序的登陆流程</h3><p>点击登陆按钮 -&gt; 调用微信登陆程序接口wx.login,获取code(有效期5分钟) -&gt; 后台使用code、appid,appSercrent获取openid、session-key,然后生成token返回给前端 -&gt; 前端保存token，便于之后的业务请求</p>
<h3 id="wx-if和hidden的区别，如何使用？"><a href="#wx-if和hidden的区别，如何使用？" class="headerlink" title="wx:if和hidden的区别，如何使用？"></a>wx:if和hidden的区别，如何使用？</h3><p>wx:if 有更高的切换消耗<br>hidden 有更高的初始渲染消耗<br>页面数据切换使用hidden,运行条件变化使用wx:if</p>
<h3 id="app-json的配置项"><a href="#app-json的配置项" class="headerlink" title="app.json的配置项"></a>app.json的配置项</h3><p>pages 存放小程序所有pages的路径<br>window 小程序所有页面的顶部、背景颜色，文字tabbar等的设置<br>tabBar 设置底部导航，最多5个，最少2个</p>
<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><h3 id="去重-1"><a href="#去重-1" class="headerlink" title="去重"></a>去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">22</span>,<span class="number">4</span>, <span class="number">444</span>,<span class="number">444</span>]</span><br><span class="line"><span class="comment">// 循环 + includes</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equal</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newArr = [arr[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!newArr.includes(arr[i])) &#123;</span><br><span class="line">      newArr.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(equal(arr));</span><br><span class="line"><span class="comment">// 双循环 判断是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equal</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newArr = [arr[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; newArr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newArr[j] === arr[i])&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">      newArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(equal(arr));</span><br><span class="line"><span class="comment">// filter 过滤判断下标是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equal</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = arr.filter(<span class="function">(<span class="params">item, index, self</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> self.indexOf(item) === index;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(equal(arr));</span><br><span class="line"><span class="comment">// es6的 set + from 转化类数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equal</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> setArr = <span class="keyword">new</span> <span class="built_in">Set</span>(arr);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">Array</span>.from(setArr);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(equal(arr));</span><br></pre></td></tr></table></figure>
<h3 id="快排算法"><a href="#快排算法" class="headerlink" title="快排算法"></a>快排算法</h3><p><strong>快速排序</strong>（Quick Sort）是一种常用的排序算法，其基本思想是分治法。它的主要步骤是:</p>
<ul>
<li>选择一个基准元素，将数组分为两个子数组，左边的元素都小于基准元素，右边的元素都大于基准元素。</li>
<li>然后对这两个子数组递归地应用快速排序。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left = <span class="number">0</span>, right = arr.length - <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> pivotIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pivot = arr[right];</span><br><span class="line">    <span class="keyword">let</span> i = left;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = left; j &lt; right; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">            [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [arr[i], arr[right]] = [arr[right], arr[i]];</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(quickSort(arr));  <span class="comment">// 输出：[0, 1, 2, 3, 5, 6, 9]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr; <span class="comment">// 如果数组长度为1或者空数组，则直接返回</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>); <span class="comment">// 选择基准数的索引</span></span><br><span class="line">  <span class="keyword">let</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>]; <span class="comment">// 取出基准数</span></span><br><span class="line">  <span class="keyword">let</span> left = [];</span><br><span class="line">  <span class="keyword">let</span> right = [];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">      left.push(arr[i]); <span class="comment">// 小于基准数的放在左边数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.push(arr[i]); <span class="comment">// 大于等于基准数的放在右边数组</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 递归地对左右子数组进行排序，并将结果合并</span></span><br><span class="line">  <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> sortedArr = quickSort(arr);</span><br><span class="line"><span class="built_in">console</span>.log(sortedArr); <span class="comment">// 输出 [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>];</span><br><span class="line"><span class="comment">// sort 排序</span></span><br><span class="line"><span class="keyword">let</span> result = arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// for 循环</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;=arr.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=arr.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;arr[i+<span class="number">1</span>])&#123; </span><br><span class="line">            <span class="keyword">var</span> tmp = arr[i];</span><br><span class="line">            arr[i] = arr[i+<span class="number">1</span>]</span><br><span class="line">            arr[i+<span class="number">1</span>] = tmp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="防抖、节流"><a href="#防抖、节流" class="headerlink" title="防抖、节流"></a>防抖、节流</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖动</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>fn 需要防抖执行的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>delay 多少毫秒不调用后执行一次,延迟时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">fn, delay = <span class="number">500</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 存储定时器的timerId</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在每一次调用函数时，都清除上一次的定时器</span></span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    <span class="comment">// 开启一个定时器</span></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">**<span class="doctag">@param<span class="type">&#123;fn: function&#125;</span> </span>需要节流的函数</span></span><br><span class="line"><span class="comment">**<span class="doctag">@param<span class="type">&#123;interval: number&#125;</span> </span>函数触发的频率</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, interval</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 记录上一次触发函数时的时间，初始值为0</span></span><br><span class="line">  <span class="keyword">let</span> lastTime  = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取现在的时间</span></span><br><span class="line">    <span class="keyword">const</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    <span class="comment">// 如果现在的时间减去上次触发的事件大于等于interval，则可以执行函数了</span></span><br><span class="line">    <span class="keyword">if</span>(nowTime - lastTime &gt;= interval)&#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">      <span class="comment">// 将上次触发函数的时间赋值成当前时间</span></span><br><span class="line">      lastTime = nowTimes</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>fn 方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>delay 每隔多少毫秒执行一次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, delay</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span>;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求数组的和</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment">// for 循环</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; array.length; index++) &#123;</span><br><span class="line">    result += array[index]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(arr));</span><br><span class="line"><span class="comment">// reduce 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = arr.reduce(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(prev, cur, array);</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(arr));</span><br></pre></td></tr></table></figure>
<h3 id="数组转对象"><a href="#数组转对象" class="headerlink" title="数组转对象"></a>数组转对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">let data = [&#123;</span></span><br><span class="line"><span class="comment">  key: 'name',</span></span><br><span class="line"><span class="comment">  value : 'xiaosong'</span></span><br><span class="line"><span class="comment">&#125;, &#123;</span></span><br><span class="line"><span class="comment">  key: 'age',</span></span><br><span class="line"><span class="comment">  value : 12</span></span><br><span class="line"><span class="comment">&#125;]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">转||化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">let obj = &#123;</span></span><br><span class="line"><span class="comment">  name: 'xiaosong',</span></span><br><span class="line"><span class="comment">  age: 12</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> data = [&#123;</span><br><span class="line">  key: <span class="string">'name'</span>,</span><br><span class="line">  value : <span class="string">'xiaosong'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  key: <span class="string">'age'</span>,</span><br><span class="line">  value : <span class="number">12</span></span><br><span class="line">&#125;]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setArr</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 写法1：</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; data.length; index++) &#123;</span><br><span class="line">    obj[data[index].key] = data[index].value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写法2：</span></span><br><span class="line">  data.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;key, value&#125; = item;</span><br><span class="line">    obj[key] = value;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(setArr())</span><br></pre></td></tr></table></figure>
<h3 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h3><p><strong><em>写一个类似于抢购的倒计时</em></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  开抢时间：&#123;&#123; date &#125;&#125;</span><br><span class="line">  &lt;Time1 :date=<span class="string">"date"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">data() &#123;</span></span><br><span class="line"><span class="regexp">  return &#123;</span></span><br><span class="line"><span class="regexp">    date: '2023/</span><span class="number">8</span>/<span class="number">29</span> <span class="number">23</span>:<span class="number">56</span>:<span class="number">00</span><span class="string">'</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;&#123; str &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">created() &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 将传入的时间字符串转化为时间戳</span></span><br><span class="line"><span class="regexp">  this.format(this.date)</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">methods: &#123;</span></span><br><span class="line"><span class="regexp">  format(date) &#123;</span></span><br><span class="line"><span class="regexp">    const that = this</span></span><br><span class="line"><span class="regexp">    setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 根据时间戳获取时分秒</span></span><br><span class="line"><span class="regexp">      const endTime = new Date(date).getTime()</span></span><br><span class="line"><span class="regexp">      const newTime = new Date().getTime()</span></span><br><span class="line"><span class="regexp">      const diffTime = (endTime - newTime) /</span> <span class="number">1000</span></span><br><span class="line">      <span class="keyword">var</span> day = <span class="built_in">parseInt</span>(diffTime / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>)</span><br><span class="line">      <span class="keyword">var</span> honur = <span class="built_in">parseInt</span>((diffTime / <span class="number">60</span> / <span class="number">60</span>) % <span class="number">24</span>)</span><br><span class="line">      <span class="keyword">var</span> min = <span class="built_in">parseInt</span>((diffTime / <span class="number">60</span>) % <span class="number">60</span>)</span><br><span class="line">      <span class="keyword">var</span> sen = <span class="built_in">parseInt</span>(diffTime % <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (diffTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        that.str = <span class="string">'开抢了！'</span></span><br><span class="line">        clearInterval(that.timer)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        that.str = day + <span class="string">'天 '</span> + honur + <span class="string">'小时 '</span> + min + <span class="string">'分 '</span> + sen + <span class="string">'秒'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>写一个显示当前时间的方法</em></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; time &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  this.timeFn()</span></span><br><span class="line"><span class="regexp">&#125;, 1000)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">timeFn() &#123;</span></span><br><span class="line"><span class="regexp">  let timeStr = new Date()</span></span><br><span class="line"><span class="regexp">  let year = timeStr.getFullYear()</span></span><br><span class="line"><span class="regexp">  let mounth = timeStr.getMonth() + 1</span></span><br><span class="line"><span class="regexp">  let day = timeStr.getDate()</span></span><br><span class="line"><span class="regexp">  let hour = timeStr.getHours()</span></span><br><span class="line"><span class="regexp">  let minu = timeStr.getMinutes()</span></span><br><span class="line"><span class="regexp">  let secon = timeStr.getSeconds()</span></span><br><span class="line"><span class="regexp">  if (mounth &lt; 10) &#123;</span></span><br><span class="line"><span class="regexp">    mounth = '0' + mounth</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  if (day &lt; 10) &#123;</span></span><br><span class="line"><span class="regexp">    day = '0' + day</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  if (hour &lt; 10) &#123;</span></span><br><span class="line"><span class="regexp">    hour = '0' + hour</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  if (minu &lt; 10) &#123;</span></span><br><span class="line"><span class="regexp">    minu = '0' + minu</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  if (secon &lt; 10) &#123;</span></span><br><span class="line"><span class="regexp">    secon = '0' + secon</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  this.time = `$&#123;year&#125;/</span>$&#123;mounth&#125;/$&#123;day&#125; $&#123;hour&#125;:$&#123;minu&#125;:$&#123;secon&#125;<span class="string">`</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
        
    </section>
</article>





<div class="comments">
    <div id="comments"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
    new Gitalk({
        clientID: "7fbe80427f54741e289f",
        clientSecret: "f34ed5fd92e54c9000bd37ba951948cb939deff5",
        repo: "sanonz.github.io",
        owner: "sanonz",
        admin: ["sanonz"],
        id: "2022/05/05/mianshi",
        distractionFreeMode: true,
        title: "常用知识总结",
        body: "http://www.shuy.cc/2022/05/05/mianshi/",
        labels: ["css js vue"]
    }).render('comments');
    </script>
</div>


        </div>
        <footer class="footer">
    Copyright © Aaron All Rights Reserved 京ICP备17007771号-1
</footer>

    </main>

    <script type="text/javascript" src="https://unpkg.com/jquery@1.9.1/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }

            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle('normal', slideDone);
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp('normal', slideDone);
            }, 3000);
        }

        function slideDone() {
            if (nodes.navInner.css('display') !== 'none') {
                nodes.navInner.css('display', '');
            }
        }

        $(window).on('resize', function() {
            console.log($(this).width())
            if ($(this).width() > 960) {
                nodes.navInner.css('display', '');
            }
        });
    });
    </script>
    
        <script src="/js/scrollspy.min.js"></script>
        <script type="text/javascript">
        $(document.body).scrollspy({target: '#aside-inner'});

        $(window).on('resize', function() {
            var hw = $('#header').width();
            var ww = $('#wrapper').width();
            var space = ($(this).width() - hw - ww) / 2 / 2;

            var pageprev = $('#pageprev');
            var pagenext = $('#pagenext');
            var avg = (pageprev.width() + pagenext.width()) / 2

            if(space > avg) {
                var len = space - avg / 2;
                // var styles = {position: 'fixed', top: '50%', marginTop: - (pageprev.width() + pagenext.width()) / 4}
                // pageprev.css($.extend({left: hw + len}, styles));
                // pagenext.css($.extend({right: len}, styles));
            } else {
                pageprev.removeAttr('style');
                // pagenext.removeAttr('style');
            }
        }).trigger('resize');
        </script>
    

</body>
</html>
