<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>vue-Router | 前端技术博客</title>
    <meta name="author" content="xiaosongread">
    <meta name="keywords" content="小宋 抿圪斗前端 前端 前端博客 框架 工程 css html js node markdown npm webpack">
    <meta name="description" content="任何框架的学习，要想学习好，首先必须全部了解最基本的 api，然后才是框架的封装，框架的优化，框架的底层原理，框架的源码。工作项目的开发没有问题，不代表你就已经完全了解了vue-Router，认真的研究文档的每一个细节，会保证你的开发思路更加清晰，开发效率更高。基础入门router-link使用 router-link 组件进行导航通过传递 to 来指定链接&amp;lt;router-link&amp;gt; 将呈现一个带有正确 href 属性的 &amp;lt;a&amp;gt; 标签请注意，我们没有使用常...">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="前端技术博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <style type="text/css">
    @font-face {
        font-family: 'icomoon';
        src: url("/fonts/icomoon.eot?q628ml");
        src: url("/fonts/icomoon.eot?q628ml#iefix") format('embedded-opentype'),
             url("/fonts/icomoon.ttf?q628ml") format('truetype'),
             url("/fonts/icomoon.woff?q628ml") format('woff'),
             url("/fonts/icomoon.svg?q628ml#icomoon") format('svg');
        font-weight: normal;
        font-style: normal;
    }
    </style>
    <link rel="stylesheet" href="/css/style.css">

    <!--[if lt IE 9]><style type="text/css">.nav-inner {top:0;}.author-meta {position:static;top:0;}.search-form {height:36px;}</style><script type="text/javascript" src="https://unpkg.com/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
</head>
<body>

    <main class="app">
        <header id="header" class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">前端技术博客</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">列表</span>
            </a>
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/categories/css-end/">
                <span class="nav-text">css</span>
            </a>
        
            <a class="nav-item" href="/categories/js-end/">
                <span class="nav-text">js</span>
            </a>
        
            <a class="nav-item" href="/categories/gc-end/">
                <span class="nav-text">工程</span>
            </a>
        
            <a class="nav-item" href="/categories/sh-end/">
                <span class="nav-text">日常</span>
            </a>
        
            <a class="nav-item" href="/categories/my-end/">
                <span class="nav-text">关于我</span>
            </a>
        
    </nav>
</div>

    <!--
 * @Author: xiaosongwindow 598349146@qq.com
 * @Date: 2023-04-25 23:16:16
 * @LastEditors: xiaosongwindow 598349146@qq.com
 * @LastEditTime: 2023-07-18 16:47:46
 * @FilePath: \github-xiaosongread-hexo\themes\landscape\layout\_partial\aside.ejs
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
<aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#入门"><span class="toc-number">1.1.</span> <span class="toc-text">入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#router-link"><span class="toc-number">1.1.1.</span> <span class="toc-text">router-link</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#router-view"><span class="toc-number">1.1.2.</span> <span class="toc-text">router-view</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态路由匹配"><span class="toc-number">1.2.</span> <span class="toc-text">动态路由匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#带参数的动态路由匹配"><span class="toc-number">1.2.1.</span> <span class="toc-text">带参数的动态路由匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#响应路由参数的变化"><span class="toc-number">1.2.2.</span> <span class="toc-text">响应路由参数的变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#捕获所有路由或-404-Not-found-路由"><span class="toc-number">1.2.3.</span> <span class="toc-text">捕获所有路由或 404 Not found 路由</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路由的匹配语法"><span class="toc-number">1.3.</span> <span class="toc-text">路由的匹配语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#在参数中自定义正则"><span class="toc-number">1.3.1.</span> <span class="toc-text">在参数中自定义正则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可重复的参数"><span class="toc-number">1.3.2.</span> <span class="toc-text">可重复的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sensitive-与-strict-路由配置"><span class="toc-number">1.3.3.</span> <span class="toc-text">Sensitive 与 strict 路由配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可选参数"><span class="toc-number">1.3.4.</span> <span class="toc-text">可选参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套路由"><span class="toc-number">1.4.</span> <span class="toc-text">嵌套路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#嵌套的命名路由"><span class="toc-number">1.4.1.</span> <span class="toc-text">嵌套的命名路由</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编程导航"><span class="toc-number">1.5.</span> <span class="toc-text">编程导航</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#导航到不同的位置"><span class="toc-number">1.5.1.</span> <span class="toc-text">导航到不同的位置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#router-push"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">router.push()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#替换当前位置"><span class="toc-number">1.5.2.</span> <span class="toc-text">替换当前位置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#router-replace"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">router.replace()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#横跨历史"><span class="toc-number">1.5.3.</span> <span class="toc-text">横跨历史</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#router-go"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">router.go()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#篡改历史"><span class="toc-number">1.5.4.</span> <span class="toc-text">篡改历史</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命名路由"><span class="toc-number">1.6.</span> <span class="toc-text">命名路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命名视图"><span class="toc-number">1.7.</span> <span class="toc-text">命名视图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#嵌套命名视图"><span class="toc-number">1.7.1.</span> <span class="toc-text">嵌套命名视图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重定向和别名"><span class="toc-number">1.8.</span> <span class="toc-text">重定向和别名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#重定向"><span class="toc-number">1.8.1.</span> <span class="toc-text">重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#相对重定向"><span class="toc-number">1.8.2.</span> <span class="toc-text">相对重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#别名"><span class="toc-number">1.8.3.</span> <span class="toc-text">别名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路由组件传参"><span class="toc-number">1.9.</span> <span class="toc-text">路由组件传参</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#布尔模式"><span class="toc-number">1.9.1.</span> <span class="toc-text">布尔模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命名视图-1"><span class="toc-number">1.9.2.</span> <span class="toc-text">命名视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象模式"><span class="toc-number">1.9.3.</span> <span class="toc-text">对象模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数模式"><span class="toc-number">1.9.4.</span> <span class="toc-text">函数模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不同的历史记录模式"><span class="toc-number">1.10.</span> <span class="toc-text">不同的历史记录模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash-模式"><span class="toc-number">1.10.1.</span> <span class="toc-text">Hash 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTML5-模式"><span class="toc-number">1.10.2.</span> <span class="toc-text">HTML5 模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进阶"><span class="toc-number">2.</span> <span class="toc-text">进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#导航守卫"><span class="toc-number">2.1.</span> <span class="toc-text">导航守卫</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#全局前置守卫"><span class="toc-number">2.1.1.</span> <span class="toc-text">全局前置守卫</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#router-beforeEach-to-from-next"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">router.beforeEach(to, from, next)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#next"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">next()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全局解析守卫"><span class="toc-number">2.1.2.</span> <span class="toc-text">全局解析守卫</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#router-beforeResolve"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">router.beforeResolve</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全局后置钩子"><span class="toc-number">2.1.3.</span> <span class="toc-text">全局后置钩子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#router-afterEach"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">router.afterEach</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#路由独享的守卫"><span class="toc-number">2.1.4.</span> <span class="toc-text">路由独享的守卫</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#beforeEnter"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">beforeEnter</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组件内的守卫"><span class="toc-number">2.1.5.</span> <span class="toc-text">组件内的守卫</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#beforeRouteEnter"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">beforeRouteEnter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#beforeRouteUpdate"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">beforeRouteUpdate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#beforeRouteLeave"><span class="toc-number">2.1.5.3.</span> <span class="toc-text">beforeRouteLeave</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用组合-API"><span class="toc-number">2.1.6.</span> <span class="toc-text">使用组合 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#完整的导航解析流程"><span class="toc-number">2.1.7.</span> <span class="toc-text">完整的导航解析流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路由元信息"><span class="toc-number">2.2.</span> <span class="toc-text">路由元信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeScript"><span class="toc-number">2.2.1.</span> <span class="toc-text">TypeScript</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据获取"><span class="toc-number">2.3.</span> <span class="toc-text">数据获取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#导航完成后获取数据"><span class="toc-number">2.3.1.</span> <span class="toc-text">导航完成后获取数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#导航完成之前获取"><span class="toc-number">2.3.2.</span> <span class="toc-text">导航完成之前获取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组合式-API"><span class="toc-number">2.4.</span> <span class="toc-text">组合式 API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#在-setup-中访问路由和当前路由"><span class="toc-number">2.4.1.</span> <span class="toc-text">在 setup 中访问路由和当前路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#导航守卫-1"><span class="toc-number">2.4.2.</span> <span class="toc-text">导航守卫</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#useLink"><span class="toc-number">2.4.3.</span> <span class="toc-text">useLink</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#过渡动效"><span class="toc-number">2.5.</span> <span class="toc-text">过渡动效</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单个路由的过渡"><span class="toc-number">2.5.1.</span> <span class="toc-text">单个路由的过渡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基于路由的动态过渡"><span class="toc-number">2.5.2.</span> <span class="toc-text">基于路由的动态过渡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#强制在复用的视图之间进行过渡"><span class="toc-number">2.5.3.</span> <span class="toc-text">强制在复用的视图之间进行过渡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#滚动行为"><span class="toc-number">2.6.</span> <span class="toc-text">滚动行为</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#延迟滚动"><span class="toc-number">2.6.1.</span> <span class="toc-text">延迟滚动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路由懒加载"><span class="toc-number">2.7.</span> <span class="toc-text">路由懒加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#把组件按组分块"><span class="toc-number">2.7.1.</span> <span class="toc-text">把组件按组分块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#使用-webpack"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">使用 webpack</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用-Vite"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">使用 Vite</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态路由"><span class="toc-number">2.8.</span> <span class="toc-text">动态路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#添加路由"><span class="toc-number">2.8.1.</span> <span class="toc-text">添加路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在导航守卫中添加路由"><span class="toc-number">2.8.2.</span> <span class="toc-text">在导航守卫中添加路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除路由"><span class="toc-number">2.8.3.</span> <span class="toc-text">删除路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#添加嵌套路由"><span class="toc-number">2.8.4.</span> <span class="toc-text">添加嵌套路由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查看现有路由"><span class="toc-number">2.8.5.</span> <span class="toc-text">查看现有路由</span></a></li></ol></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
            <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            vue-Router
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://www.shuy.cc/2023/08/21/vRouter/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2023-08-21T02:06:09.000Z" itemprop="datePublished">2023-08-21</time>
</a>

            

        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>任何框架的学习，要想学习好，首先必须全部了解最基本的 api，然后才是框架的封装，框架的优化，框架的底层原理，框架的源码。</p>
<p>工作项目的开发没有问题，不代表你就已经完全了解了vue-Router，认真的研究文档的每一个细节，会保证你的开发思路更加清晰，开发效率更高。</p>
<a id="more"></a>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h4><p>使用 router-link 组件进行导航<br>通过传递 <code>to</code> 来指定链接<br><code>&lt;router-link&gt;</code> 将呈现一个带有正确 <code>href</code> 属性的 <code>&lt;a&gt;</code> 标签</p>
<blockquote>
<p>请注意，我们没有使用常规的 a 标签，而是使用一个自定义组件 router-link 来创建链接。这使得 Vue Router 可以在不重新加载页面的情况下更改 URL，处理 URL 的生成以及编码。</p>
</blockquote>
<h4 id="router-view"><a href="#router-view" class="headerlink" title="router-view"></a>router-view</h4><p>路由出口<br>路由匹配到的组件将渲染在这里</p>
<blockquote>
<p>router-view 将显示与 url 对应的组件。你可以把它放在任何地方，以适应你的布局。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue@3"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/vue-router@4"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello App!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用 router-link 组件进行导航 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过传递 `to` 来指定链接 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--`&lt;router-link&gt;` 将呈现一个带有正确 `href` 属性的 `&lt;a&gt;` 标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>Go to Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>Go to About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由出口 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义路由组件.</span></span><br><span class="line"><span class="comment">// 也可以从其他文件导入</span></span><br><span class="line"><span class="keyword">const</span> Home = &#123; <span class="attr">template</span>: <span class="string">'&lt;div&gt;Home&lt;/div&gt;'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> About = &#123; <span class="attr">template</span>: <span class="string">'&lt;div&gt;About&lt;/div&gt;'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义一些路由</span></span><br><span class="line"><span class="comment">// 每个路由都需要映射到一个组件。</span></span><br><span class="line"><span class="comment">// 我们后面再讨论嵌套路由。</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: Home &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/about'</span>, <span class="attr">component</span>: About &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建路由实例并传递 `routes` 配置</span></span><br><span class="line"><span class="comment">// 你可以在这里输入更多的配置，但我们在这里</span></span><br><span class="line"><span class="comment">// 暂时保持简单</span></span><br><span class="line"><span class="keyword">const</span> router = VueRouter.createRouter(&#123;</span><br><span class="line">  <span class="comment">// 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。</span></span><br><span class="line">  history: VueRouter.createWebHashHistory(),</span><br><span class="line">  routes, <span class="comment">// `routes: routes` 的缩写</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 创建并挂载根实例</span></span><br><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;)</span><br><span class="line"><span class="comment">//确保 _use_ 路由实例使</span></span><br><span class="line"><span class="comment">//整个应用支持路由。</span></span><br><span class="line">app.use(router)</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，应用已经启动了！</span></span><br></pre></td></tr></table></figure>
<p>通过调用 app.use(router)，我们会触发第一次导航且可以在任意组件中以 this.$router 的形式访问它，并且以 this.$route 的形式访问当前路由：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Home.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    username() &#123;</span><br><span class="line">      <span class="comment">// 我们很快就会看到 `params` 是什么</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$route.params.username</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    goToDashboard() &#123;</span><br><span class="line">      <span class="keyword">if</span> (isAuthenticated) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$router.push(<span class="string">'/dashboard'</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$router.push(<span class="string">'/login'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要在 setup 函数中访问路由，请调用 useRouter 或 useRoute 函数。我们将在 <a href="https://router.vuejs.org/zh/guide/advanced/composition-api.html#%E5%9C%A8-setup-%E4%B8%AD%E8%AE%BF%E9%97%AE%E8%B7%AF%E7%94%B1%E5%92%8C%E5%BD%93%E5%89%8D%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener">Composition API</a> 中了解更多信息。</p>
<p>在整个文档中，我们会经常使用 router 实例，请记住，this.$router 与直接使用通过 createRouter 创建的 router 实例完全相同。我们使用 this.$router 的原因是，我们不想在每个需要操作路由的组件中都导入路由。</p>
<h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3><h4 id="带参数的动态路由匹配"><a href="#带参数的动态路由匹配" class="headerlink" title="带参数的动态路由匹配"></a>带参数的动态路由匹配</h4><p>很多时候，我们需要将给定匹配模式的路由映射到同一个组件。例如，我们可能有一个 User 组件，它应该对所有用户进行渲染，但用户 ID 不同。在 Vue Router 中，我们可以在路径中使用一个动态字段来实现，我们称之为 路径参数 ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;User&lt;/div&gt;'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些都会传递给 `createRouter`</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// 动态字段以冒号开始</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/users/:id'</span>, <span class="attr">component</span>: User &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>现在像 /users/johnny 和 /users/jolyne 这样的 URL 都会映射到同一个路由。</p>
<p>路径参数 用冒号 : 表示。当一个路由被匹配时，它的 params 的值将在每个组件中以 this.$route.params 的形式暴露出来。因此，我们可以通过更新 User 的模板来呈现当前的用户 ID：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在同一个路由中设置有多个 路径参数，它们会映射到 $route.params 上的相应字段。例如：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>匹配路径</th>
<th>$route.params</th>
</tr>
</thead>
<tbody>
<tr>
<td>/user/:username</td>
<td>/user/evan</td>
<td>username: ‘evan’</td>
</tr>
<tr>
<td>/user/:username/post/:post_id</td>
<td>/user/evan/post/123</td>
<td>username: ‘evan’, post_id: 123</td>
</tr>
</tbody>
</table>
<p>除了 $route.params 之外，$route 对象还公开了其他有用的信息，如 $route.query（如果 URL 中存在参数）、$route.hash 等。你可以在 <a href="https://router.vuejs.org/zh/api/#routelocationnormalized" target="_blank" rel="noopener">API参考</a> 中查看完整的细节。</p>
<h4 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a>响应路由参数的变化</h4><p>使用带有参数的路由时需要注意的是，当用户从 /users/johnny 导航到 /users/jolyne 时，<strong>相同的组件实例将被重复使用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，<strong>这也意味着组件的生命周期钩子不会被调用</strong>。</p>
<p>要对同一个组件中参数的变化做出响应的话，你可以简单地 watch $route 对象上的任意属性，在这个场景中，就是 $route.params ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$watch(</span><br><span class="line">      () =&gt; <span class="keyword">this</span>.$route.params,</span><br><span class="line">      (toParams, previousParams) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 对路由变化做出响应...</span></span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，使用 beforeRouteUpdate <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener">导航守卫</a>，它也可以取消导航：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'...'</span>,</span><br><span class="line">  <span class="keyword">async</span> beforeRouteUpdate(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">    <span class="comment">// 对路由变化做出响应...</span></span><br><span class="line">    <span class="keyword">this</span>.userData = <span class="keyword">await</span> fetchUser(to.params.id)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="捕获所有路由或-404-Not-found-路由"><a href="#捕获所有路由或-404-Not-found-路由" class="headerlink" title="捕获所有路由或 404 Not found 路由"></a>捕获所有路由或 404 Not found 路由</h4><p>常规参数只匹配 url 片段之间的字符，用 / 分隔。如果我们想匹配<strong>任意路径</strong>，我们可以使用自定义的 <strong><em>路径参数</em></strong> 正则表达式，在 路径参数 后面的括号中加入 正则表达式 :</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// 将匹配所有内容并将其放在 `$route.params.pathMatch` 下</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/:pathMatch(.*)*'</span>, <span class="attr">name</span>: <span class="string">'NotFound'</span>, <span class="attr">component</span>: NotFound &#125;,</span><br><span class="line">  <span class="comment">// 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/user-:afterUser(.*)'</span>, <span class="attr">component</span>: UserGeneric &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在这个特定的场景中，我们在括号之间使用了<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#%E5%9C%A8%E5%8F%82%E6%95%B0%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AD%A3%E5%88%99" target="_blank" rel="noopener">自定义正则表达式</a>，并将pathMatch 参数标记为<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">可选可重复</a>。这样做是为了让我们在需要的时候，可以通过将 path 拆分成一个数组，直接导航到路由：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">  name: <span class="string">'NotFound'</span>,</span><br><span class="line">  <span class="comment">// 保留当前路径并删除第一个字符，以避免目标 URL 以 `//` 开头。</span></span><br><span class="line">  params: &#123; <span class="attr">pathMatch</span>: <span class="keyword">this</span>.$route.path.substring(<span class="number">1</span>).split(<span class="string">'/'</span>) &#125;,</span><br><span class="line">  <span class="comment">// 保留现有的查询和 hash 值，如果有的话</span></span><br><span class="line">  query: <span class="keyword">this</span>.$route.query,</span><br><span class="line">  hash: <span class="keyword">this</span>.$route.hash,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>更多内容请参见<a href="https://router.vuejs.org/zh/guide/essentials/route-matching-syntax.html#%E5%8F%AF%E9%87%8D%E5%A4%8D%E7%9A%84%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">重复参数</a>部分。</p>
<p>如果你正在使用<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noopener">历史模式</a>，请务必按照说明正确配置你的服务器。</p>
<h3 id="路由的匹配语法"><a href="#路由的匹配语法" class="headerlink" title="路由的匹配语法"></a>路由的匹配语法</h3><p>大多数应用都会使用 /about 这样的静态路由和 /users/:userId 这样的动态路由，就像我们刚才在动态路由匹配中看到的那样，但是 Vue Router 可以提供更多的方式！</p>
<h4 id="在参数中自定义正则"><a href="#在参数中自定义正则" class="headerlink" title="在参数中自定义正则"></a>在参数中自定义正则</h4><p>当定义像 :userId 这样的参数时，我们内部使用以下的正则 ([^/]+) (至少有一个字符不是斜杠 / )来从 URL 中提取参数。这很好用，除非你需要根据参数的内容来区分两个路由。想象一下，两个路由 /:orderId 和 /:productName，两者会匹配完全相同的 URL，所以我们需要一种方法来区分它们。最简单的方法就是在路径中添加一个静态部分来区分它们：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// 匹配 /o/3549</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/o/:orderId'</span> &#125;,</span><br><span class="line">  <span class="comment">// 匹配 /p/books</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/p/:productName'</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>但在某些情况下，我们并不想添加静态的 /o /p 部分。由于，orderId 总是一个数字，而 productName 可以是任何东西，所以我们可以在括号中为参数指定一个自定义的正则：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// /:orderId -&gt; 仅匹配数字</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/:orderId(\\d+)'</span> &#125;,</span><br><span class="line">  <span class="comment">// /:productName -&gt; 匹配其他任何内容</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/:productName'</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，转到 /25 将匹配 /:orderId，其他情况将会匹配 /:productName。routes 数组的顺序并不重要!</p>
</blockquote>
<h4 id="可重复的参数"><a href="#可重复的参数" class="headerlink" title="可重复的参数"></a>可重复的参数</h4><p>如果你需要匹配具有多个部分的路由，如 /first/second/third，你应该用 *（0 个或多个）和 +（1 个或多个）将参数标记为可重复：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// /:chapters -&gt;  匹配 /one, /one/two, /one/two/three, 等</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/:chapters+'</span> &#125;,</span><br><span class="line">  <span class="comment">// /:chapters -&gt; 匹配 /, /one, /one/two, /one/two/three, 等</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/:chapters*'</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这将为你提供一个参数数组，而不是一个字符串，并且在使用命名路由时也需要你传递一个数组：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定 &#123; path: '/:chapters*', name: 'chapters' &#125;,</span></span><br><span class="line">router.resolve(&#123; <span class="attr">name</span>: <span class="string">'chapters'</span>, <span class="attr">params</span>: &#123; <span class="attr">chapters</span>: [] &#125; &#125;).href</span><br><span class="line"><span class="comment">// 产生 /</span></span><br><span class="line">router.resolve(&#123; <span class="attr">name</span>: <span class="string">'chapters'</span>, <span class="attr">params</span>: &#123; <span class="attr">chapters</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>] &#125; &#125;).href</span><br><span class="line"><span class="comment">// 产生 /a/b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定 &#123; path: '/:chapters+', name: 'chapters' &#125;,</span></span><br><span class="line">router.resolve(&#123; <span class="attr">name</span>: <span class="string">'chapters'</span>, <span class="attr">params</span>: &#123; <span class="attr">chapters</span>: [] &#125; &#125;).href</span><br><span class="line"><span class="comment">// 抛出错误，因为 `chapters` 为空</span></span><br></pre></td></tr></table></figure></p>
<p>这些也可以通过在右括号后添加它们与自定义正则结合使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// 仅匹配数字</span></span><br><span class="line">  <span class="comment">// 匹配 /1, /1/2, 等</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/:chapters(\\d+)+'</span> &#125;,</span><br><span class="line">  <span class="comment">// 匹配 /, /1, /1/2, 等</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/:chapters(\\d+)*'</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="Sensitive-与-strict-路由配置"><a href="#Sensitive-与-strict-路由配置" class="headerlink" title="Sensitive 与 strict 路由配置"></a>Sensitive 与 strict 路由配置</h4><p>默认情况下，所有路由是不区分大小写的，并且能匹配带有或不带有尾部斜线的路由。例如，路由 /users 将匹配 /users、/users/、甚至 /Users/。这种行为可以通过 strict 和 sensitive 选项来修改，它们可以既可以应用在整个全局路由上，又可以应用于当前路由上：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  history: createWebHistory(),</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// 将匹配 /users/posva 而非：</span></span><br><span class="line">    <span class="comment">// - /users/posva/ 当 strict: true</span></span><br><span class="line">    <span class="comment">// - /Users/posva 当 sensitive: true</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/users/:id'</span>, <span class="attr">sensitive</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    <span class="comment">// 将匹配 /users, /Users, 以及 /users/42 而非 /users/ 或 /users/42/</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/users/:id?'</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">  strict: <span class="literal">true</span>, <span class="comment">// applies to all routes</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>你也可以通过使用 ? 修饰符(0 个或 1 个)将一个参数标记为可选：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// 匹配 /users 和 /users/posva</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/users/:userId?'</span> &#125;,</span><br><span class="line">  <span class="comment">// 匹配 /users 和 /users/42</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/users/:userId(\\d+)?'</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，* 在技术上也标志着一个参数是可选的，但 ? 参数不能重复。</p>
</blockquote>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>一些应用程序的 UI 由多层嵌套的组件组成。在这种情况下，URL 的片段通常对应于特定的嵌套组件结构，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/user/johnny/profile                     /user/johnny/posts</span><br><span class="line">+------------------+                  +-----------------+</span><br><span class="line">| User             |                  | User            |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">| | Profile      | |  +------------&gt;  | | Posts       | |</span><br><span class="line">| |              | |                  | |             | |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">+------------------+                  +-----------------+</span><br></pre></td></tr></table></figure>
<p>通过 Vue Router，你可以使用嵌套路由配置来表达这种关系。</p>
<p>接着上节创建的 app ：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些都会传递给 `createRouter`</span></span><br><span class="line"><span class="keyword">const</span> routes = [&#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User &#125;]</span><br></pre></td></tr></table></figure>
<p>这里的 <code>&lt;router-view&gt;</code> 是一个顶层的 router-view。它渲染顶层路由匹配的组件。同样地，一个被渲染的组件也可以包含自己嵌套的 <code>&lt;router-view&gt;</code>。例如，如果我们在 User 组件的模板内添加一个 <code>&lt;router-view&gt;</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="user"&gt;</span></span><br><span class="line"><span class="string">      &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;router-view&gt;&lt;/router-view&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要将组件渲染到这个嵌套的 <code>router-view</code> 中，我们需要在路由中配置 <code>children</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/user/:id'</span>,</span><br><span class="line">    component: User,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 当 /user/:id/profile 匹配成功</span></span><br><span class="line">        <span class="comment">// UserProfile 将被渲染到 User 的 &lt;router-view&gt; 内部</span></span><br><span class="line">        path: <span class="string">'profile'</span>,</span><br><span class="line">        component: UserProfile,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 当 /user/:id/posts 匹配成功</span></span><br><span class="line">        <span class="comment">// UserPosts 将被渲染到 User 的 &lt;router-view&gt; 内部</span></span><br><span class="line">        path: <span class="string">'posts'</span>,</span><br><span class="line">        component: UserPosts,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，以 / 开头的嵌套路径将被视为根路径。这允许你利用组件嵌套，而不必使用嵌套的 URL。</p>
</blockquote>
<p>如你所见，<code>children</code> 配置只是另一个路由数组，就像 routes 本身一样。因此，你可以根据自己的需要，不断地嵌套视图。</p>
<p>此时，按照上面的配置，当你访问 <code>/user/eduardo</code> 时，在 User 的 <code>router-view</code> 里面什么都不会呈现，因为没有匹配到嵌套路由。也许你确实想在那里渲染一些东西。在这种情况下，你可以提供一个空的嵌套路径：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/user/:id'</span>,</span><br><span class="line">    component: User,</span><br><span class="line">    children: [</span><br><span class="line">      <span class="comment">// 当 /user/:id 匹配成功</span></span><br><span class="line">      <span class="comment">// UserHome 将被渲染到 User 的 &lt;router-view&gt; 内部</span></span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">''</span>, <span class="attr">component</span>: UserHome &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ...其他子路由</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="嵌套的命名路由"><a href="#嵌套的命名路由" class="headerlink" title="嵌套的命名路由"></a>嵌套的命名路由</h4><p>在处理<a href="https://router.vuejs.org/zh/guide/essentials/named-routes.html" target="_blank" rel="noopener">命名路由</a>时，<strong>你通常会给子路由命名：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/user/:id'</span>,</span><br><span class="line">    component: User,</span><br><span class="line">    <span class="comment">// 请注意，只有子路由具有名称</span></span><br><span class="line">    children: [&#123; <span class="attr">path</span>: <span class="string">''</span>, <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">component</span>: UserHome &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这将确保导航到 <code>/user/:id</code> 时始终显示嵌套路由。</p>
<p>在一些场景中，你可能希望导航到命名路由而不导航到嵌套路由。例如，你想导航 <code>/user/:id</code> 而不显示嵌套路由。那样的话，你还可以<strong>命名父路由</strong>，但请注意<strong>重新加载页面将始终显示嵌套的子路由</strong>，因为它被视为指向路径<code>/users/:id</code> 的导航，而不是命名路由：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/user/:id'</span>,</span><br><span class="line">    name: <span class="string">'user-parent'</span>,</span><br><span class="line">    component: User,</span><br><span class="line">    children: [&#123; <span class="attr">path</span>: <span class="string">''</span>, <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">component</span>: UserHome &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="编程导航"><a href="#编程导航" class="headerlink" title="编程导航"></a>编程导航</h3><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 <code>router</code> 的实例方法，通过编写代码来实现。</p>
<h4 id="导航到不同的位置"><a href="#导航到不同的位置" class="headerlink" title="导航到不同的位置"></a>导航到不同的位置</h4><h5 id="router-push"><a href="#router-push" class="headerlink" title="router.push()"></a>router.push()</h5><blockquote>
<p>注意：在 Vue 实例中，你可以通过 $router 访问路由实例。因此你可以调用 <code>this.$router.push</code>。</p>
</blockquote>
<p>想要导航到不同的 URL，可以使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，会回到之前的 URL。</p>
<p>当你点击 <code>&lt;router-link&gt;</code> 时，内部会调用这个方法，所以点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 相当于调用 <code>router.push(...) ：</code></p>
<table>
<thead>
<tr>
<th>声明式</th>
<th>编程式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>
<td><code>router.push(...)</code></td>
</tr>
</tbody>
</table>
<p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串路径</span></span><br><span class="line">router.push(<span class="string">'/users/eduardo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有路径的对象</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/users/eduardo'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由，并加上参数，让路由建立 url</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">username</span>: <span class="string">'eduardo'</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，结果是 /register?plan=private</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/register'</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">'private'</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带 hash，结果是 /about#team</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/about'</span>, <span class="attr">hash</span>: <span class="string">'#team'</span> &#125;)</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path</code> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> username = <span class="string">'eduardo'</span></span><br><span class="line"><span class="comment">// 我们可以手动建立 url，但我们必须自己处理编码</span></span><br><span class="line">router.push(<span class="string">`/user/<span class="subst">$&#123;username&#125;</span>`</span>) <span class="comment">// -&gt; /user/eduardo</span></span><br><span class="line"><span class="comment">// 同样</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;username&#125;</span>`</span> &#125;) <span class="comment">// -&gt; /user/eduardo</span></span><br><span class="line"><span class="comment">// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; username &#125; &#125;) <span class="comment">// -&gt; /user/eduardo</span></span><br><span class="line"><span class="comment">// `params` 不能与 `path` 一起使用</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/user'</span>, <span class="attr">params</span>: &#123; username &#125; &#125;) <span class="comment">// -&gt; /user</span></span><br></pre></td></tr></table></figure>
<p>当指定 <code>params</code> 时，可提供 <code>string</code> 或 <code>number</code> 参数（或者对于可重复的参数可提供一个数组）。<strong>任何其他类型</strong>（如 undefined、false 等）都将被自动字符串化。对于可选参数，你可以提供一个空字符串（<code>&quot;&quot;</code>）来跳过它。</p>
<p>由于属性 <code>to</code> 与 <code>router.push</code> 接受的对象种类相同，所以两者的规则完全相同。</p>
<p><code>router.push</code> 和所有其他导航方法都会返回一个 <code>Promise</code>，让我们可以等到导航完成后才知道是成功还是失败。</p>
<h4 id="替换当前位置"><a href="#替换当前位置" class="headerlink" title="替换当前位置"></a>替换当前位置</h4><h5 id="router-replace"><a href="#router-replace" class="headerlink" title="router.replace()"></a>router.replace()</h5><p>它的作用类似于 <code>router.push</code>，唯一不同的是，它在导航时不会向 <code>history</code> 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。</p>
<table>
<thead>
<tr>
<th style="text-align:left">声明式</th>
<th style="text-align:left">编程式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td>
<td style="text-align:left"><code>router.replace(...)</code></td>
</tr>
</tbody>
</table>
<p>也可以直接在传递给 <code>router.push</code> 的 routeLocation 中增加一个属性 <code>replace: true</code> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/home'</span>, <span class="attr">replace</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">router.replace(&#123; <span class="attr">path</span>: <span class="string">'/home'</span> &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="横跨历史"><a href="#横跨历史" class="headerlink" title="横跨历史"></a>横跨历史</h4><h5 id="router-go"><a href="#router-go" class="headerlink" title="router.go()"></a>router.go()</h5><p>该方法采用一个整数作为参数，表示在历史堆栈中前进或后退多少步，类似于 <code>window.history.go(n)</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向前移动一条记录，与 router.forward() 相同</span></span><br><span class="line">router.go(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一条记录，与 router.back() 相同</span></span><br><span class="line">router.go(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进 3 条记录</span></span><br><span class="line">router.go(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有那么多记录，静默失败</span></span><br><span class="line">router.go(<span class="number">-100</span>)</span><br><span class="line">router.go(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<h4 id="篡改历史"><a href="#篡改历史" class="headerlink" title="篡改历史"></a>篡改历史</h4><p>你可能已经注意到，<code>router.push</code>、<code>router.replace</code> 和 <code>router.go</code> 是 <code>window.history.pushState</code>、<code>window.history.replaceState</code> 和 <code>window.history.go</code> 的翻版，它们确实模仿了 <code>window.history</code> 的 API。</p>
<p>因此，如果你已经熟悉 <a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" target="_blank" rel="noopener">Browser History APIs</a>，在使用 <code>Vue Router</code> 时，操作历史记录就会觉得很熟悉。</p>
<p>值得一提的是，无论在创建路由器实例时传递什么样的 <a href="https://router.vuejs.org/zh/api/#history" target="_blank" rel="noopener">history</a> 配置，Vue Router 的导航方法( <code>push</code>、<code>replace</code>、<code>go</code> )都能始终正常工作。</p>
<h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>除了 path 之外，你还可以为任何路由提供 name。这有以下优点：</p>
<ul>
<li>没有硬编码的 URL</li>
<li>params 的自动编码/解码。</li>
<li>防止你在 url 中出现打字错误。</li>
<li>绕过路径排序（如显示一个）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/user/:username'</span>,</span><br><span class="line">    name: <span class="string">'user'</span>,</span><br><span class="line">    component: User,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>要链接到一个命名的路由，可以向 <code>router-link</code> 组件的 <code>to</code> 属性传递一个对象：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123; name: 'user', params: &#123; username: 'erina' &#125;&#125;"</span>&gt;</span></span><br><span class="line">  User</span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这跟代码调用 <code>router.push()</code> 是一回事：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; <span class="attr">username</span>: <span class="string">'erina'</span> &#125; &#125;)</span><br></pre></td></tr></table></figure>
<p>在这两种情况下，路由将导航到路径 <code>/user/erina</code>。</p>
<h3 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h3><p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code> (侧导航) 和 <code>main</code> (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view left-sidebar"</span> <span class="attr">name</span>=<span class="string">"LeftSidebar"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view main-content"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">"view right-sidebar"</span> <span class="attr">name</span>=<span class="string">"RightSidebar"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 <code>components</code> 配置 (带上 s)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  history: createWebHashHistory(),</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      components: &#123;</span><br><span class="line">        <span class="keyword">default</span>: Home,</span><br><span class="line">        <span class="comment">// LeftSidebar: LeftSidebar 的缩写</span></span><br><span class="line">        LeftSidebar,</span><br><span class="line">        <span class="comment">// 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配</span></span><br><span class="line">        RightSidebar,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><a href="https://codesandbox.io/s/named-views-vue-router-4-examples-rd20l?file=/src/router.js" target="_blank" rel="noopener">完整代码</a></p>
<h4 id="嵌套命名视图"><a href="#嵌套命名视图" class="headerlink" title="嵌套命名视图"></a>嵌套命名视图</h4><p>我们也有可能使用命名视图创建嵌套视图的复杂布局。这时你也需要命名用到的嵌套 <code>router-view</code> 组件。我们以一个设置面板为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/settings/emails                                       /settings/profile</span><br><span class="line">+-----------------------------------+                  +------------------------------+</span><br><span class="line">| UserSettings                      |                  | UserSettings                 |</span><br><span class="line">| +-----+-------------------------+ |                  | +-----+--------------------+ |</span><br><span class="line">| | Nav | UserEmailsSubscriptions | |  +------------&gt;  | | Nav | UserProfile        | |</span><br><span class="line">| |     +-------------------------+ |                  | |     +--------------------+ |</span><br><span class="line">| |     |                         | |                  | |     | UserProfilePreview | |</span><br><span class="line">| +-----+-------------------------+ |                  | +-----+--------------------+ |</span><br><span class="line">+-----------------------------------+                  +------------------------------+</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Nav</code> 只是一个常规组件。</li>
<li><code>UserSettings</code> 是一个视图组件。</li>
<li><code>UserEmailsSubscriptions</code>、<code>UserProfile</code>、<code>UserProfilePreview</code> 是嵌套的视图组件。</li>
</ul>
<p><strong>注意：</strong>我们先忘记 HTML/CSS 具体的布局的样子，只专注在用到的组件上。<br><code>UserSettings</code> 组件的 <code>&lt;template&gt;</code> 部分应该是类似下面的这段代码:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- UserSettings.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>User Settings<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">NavBar</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"helper"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么你就可以通过这个路由配置来实现上面的布局：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/settings'</span>,</span><br><span class="line">  <span class="comment">// 你也可以在顶级路由就配置命名视图</span></span><br><span class="line">  component: UserSettings,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    path: <span class="string">'emails'</span>,</span><br><span class="line">    component: UserEmailsSubscriptions</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: <span class="string">'profile'</span>,</span><br><span class="line">    components: &#123;</span><br><span class="line">      <span class="keyword">default</span>: UserProfile,</span><br><span class="line">      helper: UserProfilePreview</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://codesandbox.io/s/nested-named-views-vue-router-4-examples-re9yl?&amp;initialpath=%2Fsettings%2Femails" target="_blank" rel="noopener">完整代码</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> UserSettings <span class="keyword">from</span> <span class="string">'./views/UserSettings.vue'</span></span><br><span class="line"><span class="keyword">import</span> UserEmailsSubscriptions <span class="keyword">from</span> <span class="string">'./views/UserEmailsSubscriptions.vue'</span></span><br><span class="line"><span class="keyword">import</span> UserProfile <span class="keyword">from</span> <span class="string">'./views/UserProfile.vue'</span></span><br><span class="line"><span class="keyword">import</span> UserProfilePreview <span class="keyword">from</span> <span class="string">'./views/UserProfilePreview.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  history: createWebHistory(),</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/settings'</span>,</span><br><span class="line">      <span class="comment">// You could also have named views at tho top</span></span><br><span class="line">      component: UserSettings,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">'emails'</span>,</span><br><span class="line">          component: UserEmailsSubscriptions,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          path: <span class="string">'profile'</span>,</span><br><span class="line">          components: &#123;</span><br><span class="line">            <span class="keyword">default</span>: UserProfile,</span><br><span class="line">            helper: UserProfilePreview,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h3><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>重定向也是通过 <code>routes</code> 配置来完成，下面例子是从 <code>/home</code> 重定向到 <code>/</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [&#123; <span class="attr">path</span>: <span class="string">'/home'</span>, <span class="attr">redirect</span>: <span class="string">'/'</span> &#125;]</span><br></pre></td></tr></table></figure>
<p>重定向的目标也可以是一个命名的路由：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [&#123; <span class="attr">path</span>: <span class="string">'/home'</span>, <span class="attr">redirect</span>: &#123; <span class="attr">name</span>: <span class="string">'homepage'</span> &#125; &#125;]</span><br></pre></td></tr></table></figure>
<p>甚至是一个方法，动态返回重定向目标：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// /search/screens -&gt; /search?q=screens</span></span><br><span class="line">    path: <span class="string">'/search/:searchText'</span>,</span><br><span class="line">    redirect: <span class="function"><span class="params">to</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 方法接收目标路由作为参数</span></span><br><span class="line">      <span class="comment">// return 重定向的字符串路径/路径对象</span></span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">path</span>: <span class="string">'/search'</span>, <span class="attr">query</span>: &#123; <span class="attr">q</span>: to.params.searchText &#125; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/search'</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>请注意，导航守卫并没有应用在跳转路由上，而仅仅应用在其目标上。在上面的例子中，在 <code>/home</code> 路由中添加 <code>beforeEnter</code> 守卫不会有任何效果。</p>
<p>在写 redirect 的时候，可以省略 <code>component</code> 配置，因为它从来没有被直接访问过，所以没有组件要渲染。唯一的例外是嵌套路由：如果一个路由记录有 <code>children</code> 和 <code>redirect</code> 属性，它也应该有 <code>component</code> 属性。</p>
<h4 id="相对重定向"><a href="#相对重定向" class="headerlink" title="相对重定向"></a>相对重定向</h4><p>也可以重定向到相对位置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 将总是把/users/123/posts重定向到/users/123/profile。</span></span><br><span class="line">    path: <span class="string">'/users/:id/posts'</span>,</span><br><span class="line">    redirect: <span class="function"><span class="params">to</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 该函数接收目标路由作为参数</span></span><br><span class="line">      <span class="comment">// 相对位置不以`/`开头</span></span><br><span class="line">      <span class="comment">// 或 &#123; path: 'profile'&#125;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">'profile'</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><p>重定向是指当用户访问 <code>/home</code> 时，URL 会被 <code>/</code> 替换，然后匹配成 <code>/</code>。那么什么是别名呢？</p>
<p>将 <code>/</code> 别名为 <code>/home</code>，意味着当用户访问 <code>/home</code> 时，URL 仍然是 <code>/home</code>，但会被匹配为用户正在访问 <code>/</code>。</p>
<p>上面对应的路由配置为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [&#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">component</span>: Homepage, <span class="attr">alias</span>: <span class="string">'/home'</span> &#125;]</span><br></pre></td></tr></table></figure>
<p>通过别名，你可以自由地将 UI 结构映射到一个任意的 URL，而不受配置的嵌套结构的限制。使别名以 <code>/</code> 开头，以使嵌套路径中的路径成为绝对路径。你甚至可以将两者结合起来，用一个数组提供多个别名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/users'</span>,</span><br><span class="line">    component: UsersLayout,</span><br><span class="line">    children: [</span><br><span class="line">      <span class="comment">// 为这 3 个 URL 呈现 UserList</span></span><br><span class="line">      <span class="comment">// - /users</span></span><br><span class="line">      <span class="comment">// - /users/list</span></span><br><span class="line">      <span class="comment">// - /people</span></span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">''</span>, <span class="attr">component</span>: UserList, <span class="attr">alias</span>: [<span class="string">'/people'</span>, <span class="string">'list'</span>] &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>如果你的路由有参数，请确保在任何绝对别名中包含它们：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/users/:id'</span>,</span><br><span class="line">    component: UsersByIdLayout,</span><br><span class="line">    children: [</span><br><span class="line">      <span class="comment">// 为这 3 个 URL 呈现 UserDetails</span></span><br><span class="line">      <span class="comment">// - /users/24</span></span><br><span class="line">      <span class="comment">// - /users/24/profile</span></span><br><span class="line">      <span class="comment">// - /24</span></span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">'profile'</span>, <span class="attr">component</span>: UserDetails, <span class="attr">alias</span>: [<span class="string">'/:id'</span>, <span class="string">''</span>] &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h3><p><strong>将 <code>props</code> 传递给路由组件</strong><br>在你的组件中使用 <code>$route</code> 会与路由紧密耦合，这限制了组件的灵活性，因为它只能用于特定的 URL。虽然这不一定是件坏事，但我们可以通过 <code>props</code> 配置来解除这种行为：</p>
<p>我们可以将下面的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> routes = [&#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User &#125;]</span><br></pre></td></tr></table></figure>
<p>替换成</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  <span class="comment">// 请确保添加一个与路由参数完全相同的 prop 名</span></span><br><span class="line">  props: [<span class="string">'id'</span>],</span><br><span class="line">  template: <span class="string">'&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> routes = [&#123; <span class="attr">path</span>: <span class="string">'/user/:id'</span>, <span class="attr">component</span>: User, <span class="attr">props</span>: <span class="literal">true</span> &#125;]</span><br></pre></td></tr></table></figure>
<p>这允许你在任何地方使用该组件，使得该组件更容易重用和测试。</p>
<h4 id="布尔模式"><a href="#布尔模式" class="headerlink" title="布尔模式"></a>布尔模式</h4><p>当 <code>props</code> 设置为 <code>true</code> 时，<code>route.params</code> 将被设置为组件的 <code>props</code>。<br>具体看上面代码路由设置。</p>
<h4 id="命名视图-1"><a href="#命名视图-1" class="headerlink" title="命名视图"></a>命名视图</h4><p>对于有命名视图的路由，你必须为每个命名视图定义 <code>props</code> 配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/user/:id'</span>,</span><br><span class="line">    components: &#123; <span class="attr">default</span>: User, <span class="attr">sidebar</span>: Sidebar &#125;,</span><br><span class="line">    props: &#123; <span class="attr">default</span>: <span class="literal">true</span>, <span class="attr">sidebar</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="对象模式"><a href="#对象模式" class="headerlink" title="对象模式"></a>对象模式</h4><p>当 <code>props</code> 是一个对象时，它将原样设置为组件 <code>props</code>。当 <code>props</code> 是静态的时候很有用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/promotion/from-newsletter'</span>,</span><br><span class="line">    component: Promotion,</span><br><span class="line">    props: &#123; <span class="attr">newsletterPopup</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h4><p>你可以创建一个返回 props 的函数。这允许你将参数转换为其他类型，将静态值与基于路由的值相结合等等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/search'</span>,</span><br><span class="line">    component: SearchUser,</span><br><span class="line">    props: <span class="function"><span class="params">route</span> =&gt;</span> (&#123; <span class="attr">query</span>: route.query.q &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>URL <code>/search?q=vue</code> 将传递 <code>{query: &#39;vue&#39;}</code> 作为 <code>props</code> 传给 <code>SearchUser</code> 组件。</p>
<p>请尽可能保持 <code>props</code> 函数为无状态的，因为它只会在路由发生变化时起作用。如果你需要状态来定义 <code>props</code>，请使用包装组件，这样 <code>vue</code> 才可以对状态变化做出反应。</p>
<h3 id="不同的历史记录模式"><a href="#不同的历史记录模式" class="headerlink" title="不同的历史记录模式"></a>不同的历史记录模式</h3><p>在创建路由器实例时，<code>history</code> 配置允许我们在不同的历史模式中进行选择。</p>
<h4 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h4><p>hash 模式是用 <code>createWebHashHistory()</code> 创建的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  history: createWebHashHistory(),</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>它在内部传递的实际 URL 之前使用了一个哈希字符（<code>#</code>）。由于这部分 URL 从未被发送到服务器，所以它不需要在服务器层面上进行任何特殊处理。不过，它在 SEO 中确实有不好的影响。如果你担心这个问题，可以使用 <code>HTML5</code> 模式。</p>
<h4 id="HTML5-模式"><a href="#HTML5-模式" class="headerlink" title="HTML5 模式"></a>HTML5 模式</h4><p>用 <code>createWebHistory()</code> 创建 HTML5 模式，推荐使用这个模式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  history: createWebHistory(),</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当使用这种历史模式时，URL 会看起来很 “正常”，例如 <code>https://example.com/user/id</code>。漂亮!</p>
<p>不过，问题来了。由于我们的应用是一个单页的客户端应用，如果没有适当的服务器配置，用户在浏览器中直接访问 <code>https://example.com/user/id</code>，就会得到一个 404 错误。这就尴尬了。</p>
<p>不用担心：要解决这个问题，你需要做的就是在你的服务器上添加一个简单的回退路由。如果 URL 不匹配任何静态资源，它应提供与你的应用程序中的 <code>index.html</code> 相同的页面。漂亮依旧!</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><p>正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。这里有很多方式植入路由导航中：全局的，单个路由独享的，或者组件级的。</p>
<h4 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h4><h5 id="router-beforeEach-to-from-next"><a href="#router-beforeEach-to-from-next" class="headerlink" title="router.beforeEach(to, from, next)"></a>router.beforeEach(to, from, next)</h5><p>你可以使用 <code>router.beforeEach</code> 注册一个全局前置守卫</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = createRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 返回 false 以取消导航</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 <code>resolve</code> 完之前一直处于<strong>等待中</strong>.</p>
<p>每个守卫方法接收两个参数：</p>
<ul>
<li>to: 即将要进入的目标</li>
<li>from: 当前导航正要离开的路由</li>
</ul>
<p>可以返回的值如下:</p>
<ul>
<li><code>false</code>: 取消当前的导航。如果浏览器的 URL 改变了(可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li>
<li>一个路由地址: 通过一个路由地址跳转到一个不同的地址，就像你调用 <code>router.push()</code> 一样，你可以设置诸如 <code>replace: true</code> 或 <code>name: &#39;home&#39;</code> 之类的配置。当前的导航被中断，然后进行一个新的导航，就和 <code>from</code> 一样。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="keyword">async</span> (to, <span class="keyword">from</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="comment">// 检查用户是否已登录</span></span><br><span class="line">    !isAuthenticated &amp;&amp;</span><br><span class="line">    <span class="comment">// ❗️ 避免无限重定向</span></span><br><span class="line">    to.name !== <span class="string">'Login'</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 将用户重定向到登录页面</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">'Login'</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果遇到了意料之外的情况，可能会抛出一个 <code>Error</code>。这会取消导航并且调用 <code>router.onError()</code> 注册过的回调。</p>
<p>如果什么都没有，<code>undefined</code> 或返回 <code>true</code>，则导航是有效的，并调用下一个导航守卫</p>
<p>以上所有都同 <code>async</code> 函数 和 <code>Promise</code> 工作方式一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="keyword">async</span> (to, <span class="keyword">from</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// canUserAccess() 返回 `true` 或 `false`</span></span><br><span class="line">  <span class="keyword">const</span> canAccess = <span class="keyword">await</span> canUserAccess(to)</span><br><span class="line">  <span class="keyword">if</span> (!canAccess) <span class="keyword">return</span> <span class="string">'/login'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h5><p>在之前的 <code>Vue Router</code> 版本中，也是可以使用 第三个参数 <code>next</code> 的。这是一个常见的错误来源，可以通过 RFC 来消除错误。然而，它仍然是被支持的，这意味着你可以向任何导航守卫传递第三个参数。在这种情况下，确保 <code>next</code> 在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。这里有一个在用户未能验证身份时重定向到/login的错误用例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BAD</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.name !== <span class="string">'Login'</span> &amp;&amp; !isAuthenticated) next(&#123; <span class="attr">name</span>: <span class="string">'Login'</span> &#125;)</span><br><span class="line">  <span class="comment">// 如果用户未能验证身份，则 `next` 会被调用两次</span></span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>下面是正确的版本:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GOOD</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.name !== <span class="string">'Login'</span> &amp;&amp; !isAuthenticated) next(&#123; <span class="attr">name</span>: <span class="string">'Login'</span> &#125;)</span><br><span class="line">  <span class="keyword">else</span> next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="全局解析守卫"><a href="#全局解析守卫" class="headerlink" title="全局解析守卫"></a>全局解析守卫</h4><h5 id="router-beforeResolve"><a href="#router-beforeResolve" class="headerlink" title="router.beforeResolve"></a>router.beforeResolve</h5><p>你可以用 <code>router.beforeResolve</code> 注册一个全局守卫。这和 <code>router.beforeEach</code> 类似，因为它在每次导航时都会触发，不同的是，解析守卫刚好会在导航被确认之前、所有组件内守卫和异步路由组件被解析之后调用。这里有一个例子，确保用户可以访问自定义 meta 属性 <code>requiresCamera</code> 的路由：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">router.beforeResolve(<span class="keyword">async</span> to =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.meta.requiresCamera) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> askForCameraPermission()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">if</span> (error <span class="keyword">instanceof</span> NotAllowedError) &#123;</span><br><span class="line">        <span class="comment">// ... 处理错误，然后取消导航</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 意料之外的错误，取消导航并把错误传给全局处理器</span></span><br><span class="line">        <span class="keyword">throw</span> error</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>router.beforeResolve</code> 是获取数据或执行任何其他操作（如果用户无法进入页面时你希望避免执行的操作）的理想位置。</p>
<h4 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h4><h5 id="router-afterEach"><a href="#router-afterEach" class="headerlink" title="router.afterEach"></a>router.afterEach</h5><p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  sendToAnalytics(to.fullPath)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a>路由独享的守卫</h4><h5 id="beforeEnter"><a href="#beforeEnter" class="headerlink" title="beforeEnter"></a>beforeEnter</h5><p>你可以通过 <code>beforeEnter</code> 守卫来为特定的路由添加守卫：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/users/:id'</span>,</span><br><span class="line">    component: UserDetails,</span><br><span class="line">    beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// reject the navigation</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><code>beforeEnter</code> 守卫 只在进入路由时触发，不会在 <code>params</code>、<code>query</code> 或 <code>hash</code> 改变时触发。例如，从 <code>/users/2</code> 进入到 <code>/users/3</code> 或者从 <code>/users/2#info</code> 进入到 <code>/users/2#projects</code>。它们只有在 从一个不同的 路由导航时，才会被触发。</p>
<p>你也可以将一个函数数组传递给 <code>beforeEnter</code>，这在为不同的路由重用守卫时很有用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeQueryParams</span>(<span class="params">to</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(to.query).length)</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">path</span>: to.path, <span class="attr">query</span>: &#123;&#125;, <span class="attr">hash</span>: to.hash &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeHash</span>(<span class="params">to</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (to.hash) <span class="keyword">return</span> &#123; <span class="attr">path</span>: to.path, <span class="attr">query</span>: to.query, <span class="attr">hash</span>: <span class="string">''</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/users/:id'</span>,</span><br><span class="line">    component: UserDetails,</span><br><span class="line">    beforeEnter: [removeQueryParams, removeHash],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/about'</span>,</span><br><span class="line">    component: UserDetails,</span><br><span class="line">    beforeEnter: [removeQueryParams],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>请注意，你也可以通过使用路径 meta 字段和全局导航守卫来实现类似的行为。</p>
<h4 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h4><p>最后，你可以在路由组件内直接定义路由导航守卫(传递给路由配置的)</p>
<h5 id="beforeRouteEnter"><a href="#beforeRouteEnter" class="headerlink" title="beforeRouteEnter"></a>beforeRouteEnter</h5><h5 id="beforeRouteUpdate"><a href="#beforeRouteUpdate" class="headerlink" title="beforeRouteUpdate"></a>beforeRouteUpdate</h5><h5 id="beforeRouteLeave"><a href="#beforeRouteLeave" class="headerlink" title="beforeRouteLeave"></a>beforeRouteLeave</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserDetails = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被验证前调用</span></span><br><span class="line">    <span class="comment">// 不能获取组件实例 `this` ！</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行时，组件实例还没被创建！</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">    <span class="comment">// 在导航离开渲染该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>离开守卫 通常用来预防用户在还未保存修改前突然离开。该导航可以通过返回 false 来取消。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> answer = <span class="built_in">window</span>.confirm(<span class="string">'Do you really want to leave? you have unsaved changes!'</span>)</span><br><span class="line">  <span class="keyword">if</span> (!answer) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用组合-API"><a href="#使用组合-API" class="headerlink" title="使用组合 API"></a>使用组合 API</h4><p>如果你正在使用<a href="https://cn.vuejs.org/api/composition-api-setup.html" target="_blank" rel="noopener">组合 API 和 setup 函数</a>来编写组件，你可以通过 <code>onBeforeRouteUpdate</code> 和 <code>onBeforeRouteLeave</code> 分别添加 update 和 leave 守卫。 请参考组合 API 部分以获得更多细节。</p>
<h4 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h4><ol>
<li>导航被触发。</li>
<li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li>
<li>调用全局的 <code>beforeEach</code> 守卫。</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫(2.2+)。</li>
<li>在路由配置里调用 <code>beforeEnter</code>。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>
<li>调用全局的 <code>beforeResolve</code> 守卫(2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 <code>afterEach</code> 钩子。</li>
<li>触发 <code>DOM</code> 更新。</li>
<li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li>
</ol>
<h3 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h3><p>有时，你可能希望将任意信息附加到路由上，如过渡名称、谁可以访问路由等。这些事情可以通过接收属性对象的  <code>meta</code> 属性来实现，并且它可以在路由地址和导航守卫上都被访问到。定义路由的时候你可以这样配置 <code>meta</code> 字段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/posts'</span>,</span><br><span class="line">    component: PostsLayout,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'new'</span>,</span><br><span class="line">        component: PostsNew,</span><br><span class="line">        <span class="comment">// 只有经过身份验证的用户才能创建帖子</span></span><br><span class="line">        meta: &#123; <span class="attr">requiresAuth</span>: <span class="literal">true</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">':id'</span>,</span><br><span class="line">        component: PostsDetail</span><br><span class="line">        <span class="comment">// 任何人都可以阅读文章</span></span><br><span class="line">        meta: &#123; <span class="attr">requiresAuth</span>: <span class="literal">false</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>那么如何访问这个 <code>meta</code> 字段呢？</p>
<p>首先，我们称呼 <code>routes</code> 配置中的每个路由对象为 <strong>路由记录</strong>。路由记录可以是嵌套的，因此，当一个路由匹配成功后，它可能匹配多个路由记录。</p>
<p>例如，根据上面的路由配置，<code>/posts/new</code> 这个 URL 将会匹配父路由记录 (<code>path: &#39;/posts&#39;</code>) 以及子路由记录 (<code>path: &#39;new&#39;</code>)。</p>
<p>一个路由匹配到的所有路由记录会暴露为 <code>$route</code> 对象(还有在导航守卫中的路由对象)的 <code>$route.matched</code> 数组。我们需要遍历这个数组来检查路由记录中的 <code>meta</code> 字段，但是 <code>Vue Router</code> 还为你提供了一个 <code>$route.meta</code> 方法，它是一个非递归合并所有 <code>meta</code> 字段的（从父字段到子字段）的方法。这意味着你可以简单地写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 而不是去检查每条路由记录</span></span><br><span class="line">  <span class="comment">// to.matched.some(record =&gt; record.meta.requiresAuth)</span></span><br><span class="line">  <span class="keyword">if</span> (to.meta.requiresAuth &amp;&amp; !auth.isLoggedIn()) &#123;</span><br><span class="line">    <span class="comment">// 此路由需要授权，请检查是否已登录</span></span><br><span class="line">    <span class="comment">// 如果没有，则重定向到登录页面</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      path: <span class="string">'/login'</span>,</span><br><span class="line">      <span class="comment">// 保存我们所在的位置，以便以后再来</span></span><br><span class="line">      query: &#123; <span class="attr">redirect</span>: to.fullPath &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h4><p>可以通过扩展 <code>RouteMeta</code> 接口来输入 <code>meta</code> 字段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typings.d.ts or router.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">'vue-router'</span> &#123;</span><br><span class="line">  interface RouteMeta &#123;</span><br><span class="line">    <span class="comment">// 是可选的</span></span><br><span class="line">    isAdmin?: boolean</span><br><span class="line">    <span class="comment">// 每个路由都必须声明</span></span><br><span class="line">    requiresAuth: boolean</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><p>有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现：</p>
<ul>
<li><p><strong>导航完成之后获取</strong>：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。</p>
</li>
<li><p><strong>导航完成之前获取</strong>：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。</p>
</li>
</ul>
<p>从技术角度讲，两种方式都不错 —— 就看你想要的用户体验是哪种。</p>
<h4 id="导航完成后获取数据"><a href="#导航完成后获取数据" class="headerlink" title="导航完成后获取数据"></a>导航完成后获取数据</h4><p>当你使用这种方式时，我们会马上导航和渲染组件，然后在组件的 <code>created</code> 钩子中获取数据。这让我们有机会在数据获取期间展示一个 <code>loading</code> 状态，还可以在不同视图间展示不同的 <code>loading</code> 状态。</p>
<p>假设我们有一个 <code>Post</code> 组件，需要基于 <code>$route.params.id</code> 获取文章数据：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"loading"</span> <span class="attr">class</span>=<span class="string">"loading"</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"error"</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span>&#123;&#123; error &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"post"</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; post.title &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; post.body &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      loading: <span class="literal">false</span>,</span><br><span class="line">      post: <span class="literal">null</span>,</span><br><span class="line">      error: <span class="literal">null</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="comment">// watch 路由的参数，以便再次获取数据</span></span><br><span class="line">    <span class="keyword">this</span>.$watch(</span><br><span class="line">      () =&gt; <span class="keyword">this</span>.$route.params,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.fetchData()</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 组件创建完后获取数据，</span></span><br><span class="line">      <span class="comment">// 此时 data 已经被 observed 了</span></span><br><span class="line">      &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fetchData() &#123;</span><br><span class="line">      <span class="keyword">this</span>.error = <span class="keyword">this</span>.post = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">this</span>.loading = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// replace `getPost` with your data fetching util / API wrapper</span></span><br><span class="line">      getPost(<span class="keyword">this</span>.$route.params.id, (err, post) =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.loading = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">this</span>.error = err.toString()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.post = post</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="导航完成之前获取"><a href="#导航完成之前获取" class="headerlink" title="导航完成之前获取"></a>导航完成之前获取</h4><p>通过这种方式，我们在导航转入新的路由前获取数据。我们可以在接下来的组件的 <code>beforeRouteEnter</code> 守卫中获取数据，当数据获取成功后只调用 <code>next</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      post: <span class="literal">null</span>,</span><br><span class="line">      error: <span class="literal">null</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteEnter(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    getPost(to.params.id, (err, post) =&gt; &#123;</span><br><span class="line">      next(<span class="function"><span class="params">vm</span> =&gt;</span> vm.setData(err, post))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 路由改变前，组件就已经渲染完了</span></span><br><span class="line">  <span class="comment">// 逻辑稍稍不同</span></span><br><span class="line">  <span class="keyword">async</span> beforeRouteUpdate(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.post = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.post = <span class="keyword">await</span> getPost(to.params.id)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.error = error.toString()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，显示一些进度条或者别的指示。如果数据获取失败，同样有必要展示一些全局的错误提醒。</p>
<h3 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h3><p><strong>Vue Router 和 组合式 API</strong></p>
<p>引入 <code>setup</code> 和 Vue 的<code>组合式 API</code>，开辟了新的可能性，但要想充分发挥 <code>Vue Router</code> 的潜力，我们需要使用一些新的函数来代替访问 <code>this</code> 和组件内导航守卫。</p>
<h4 id="在-setup-中访问路由和当前路由"><a href="#在-setup-中访问路由和当前路由" class="headerlink" title="在 setup 中访问路由和当前路由"></a>在 <code>setup</code> 中访问路由和当前路由</h4><p>因为我们在 <code>setup</code> 里面没有访问 <code>this</code>，所以我们不能再直接访问 <code>this.$router</code> 或 <code>this.$route</code>。作为替代，我们使用 <code>useRouter</code> 和 <code>useRoute</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter, useRoute &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> router = useRouter()</span><br><span class="line">    <span class="keyword">const</span> route = useRoute()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pushWithQuery</span>(<span class="params">query</span>) </span>&#123;</span><br><span class="line">      router.push(&#123;</span><br><span class="line">        name: <span class="string">'search'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          ...route.query,</span><br><span class="line">          ...query,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>route</code> 对象是一个响应式对象，所以它的任何属性都可以被监听，但你应该避免监听整个 <code>route</code> 对象。在大多数情况下，你应该直接监听你期望改变的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRoute &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> route = useRoute()</span><br><span class="line">    <span class="keyword">const</span> userData = ref()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当参数更改时获取用户信息</span></span><br><span class="line">    watch(</span><br><span class="line">      () =&gt; route.params.id,</span><br><span class="line">      <span class="keyword">async</span> newId =&gt; &#123;</span><br><span class="line">        userData.value = <span class="keyword">await</span> fetchUser(newId)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，在模板中我们仍然可以访问 <code>$router</code> 和 <code>$route</code>，所以不需要在 <code>setup</code> 中返回 <code>router</code> 或 <code>route</code>。</p>
</blockquote>
<h4 id="导航守卫-1"><a href="#导航守卫-1" class="headerlink" title="导航守卫"></a>导航守卫</h4><p>虽然你仍然可以通过 <code>setup</code> 函数来使用组件内的导航守卫，但 <code>Vue Router</code> 将更新和离开守卫作为 组合式 API 函数公开：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onBeforeRouteLeave, onBeforeRouteUpdate &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="comment">// 与 beforeRouteLeave 相同，无法访问 `this`</span></span><br><span class="line">    onBeforeRouteLeave(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> answer = <span class="built_in">window</span>.confirm(</span><br><span class="line">        <span class="string">'Do you really want to leave? you have unsaved changes!'</span></span><br><span class="line">      )</span><br><span class="line">      <span class="comment">// 取消导航并停留在同一页面上</span></span><br><span class="line">      <span class="keyword">if</span> (!answer) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> userData = ref()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与 beforeRouteUpdate 相同，无法访问 `this`</span></span><br><span class="line">    onBeforeRouteUpdate(<span class="keyword">async</span> (to, <span class="keyword">from</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">//仅当 id 更改时才获取用户，例如仅 query 或 hash 值已更改</span></span><br><span class="line">      <span class="keyword">if</span> (to.params.id !== <span class="keyword">from</span>.params.id) &#123;</span><br><span class="line">        userData.value = <span class="keyword">await</span> fetchUser(to.params.id)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组合式 API 守卫也可以用在任何由 <code>&lt;router-view&gt;</code> 渲染的组件中，它们不必像组件内守卫那样直接用在路由组件上。</p>
<h4 id="useLink"><a href="#useLink" class="headerlink" title="useLink"></a>useLink</h4><p>Vue Router 将 <code>RouterLink</code> 的内部行为作为一个组合式函数 (composable) 公开。它接收一个类似 <code>RouterLink</code> 所有 prop 的响应式对象，并暴露底层属性来构建你自己的 <code>RouterLink</code> 组件或生成自定义链接：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; RouterLink, useLink &#125; <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'AppLink'</span>,</span><br><span class="line"></span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 如果使用 TypeScript，请添加 @ts-ignore</span></span><br><span class="line">    ...RouterLink.props,</span><br><span class="line">    inactiveClass: <span class="built_in">String</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="comment">// 解析出来的路由对象</span></span><br><span class="line">      route,</span><br><span class="line">      <span class="comment">// 用在链接里的 href</span></span><br><span class="line">      href,</span><br><span class="line">      <span class="comment">// 布尔类型的 ref 标识链接是否匹配当前路由</span></span><br><span class="line">      isActive,</span><br><span class="line">      <span class="comment">// 布尔类型的 ref 标识链接是否严格匹配当前路由</span></span><br><span class="line">      isExactActive,</span><br><span class="line">      <span class="comment">// 导航至该链接的函数</span></span><br><span class="line">      navigate</span><br><span class="line">      &#125; = useLink(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isExternalLink = computed(</span><br><span class="line">      () =&gt; <span class="keyword">typeof</span> props.to === <span class="string">'string'</span> &amp;&amp; props.to.startsWith(<span class="string">'http'</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; isExternalLink, href, navigate, isActive &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在 RouterLink 的 v-slot 中可以访问与 useLink 组合式函数相同的属性。</p>
<!-- [参考案例：使用 Vue Router 开发单页应用（5）](https://blog.csdn.net/GXL_1012/article/details/128267412) -->
<h3 id="过渡动效"><a href="#过渡动效" class="headerlink" title="过渡动效"></a>过渡动效</h3><p>想要在你的路径组件上使用转场，并对导航进行动画处理，你需要使用 <a href="https://router.vuejs.org/guide/advanced/composition-api.html#uselink" target="_blank" rel="noopener">v-slot API</a>：</p>
<p><a href="https://vuejs.org/guide/built-ins/transition.html" target="_blank" rel="noopener">Transition 的 API</a> 在这里同样适用。</p>
<h4 id="单个路由的过渡"><a href="#单个路由的过渡" class="headerlink" title="单个路由的过渡"></a>单个路由的过渡</h4><p>上面的用法会对所有的路由使用相同的过渡。如果你想让每个路由的组件有不同的过渡，你可以将元信息(<code>meta</code>)和动态的 <code>name</code> 结合在一起，放在<code>&lt;transition&gt;</code> 上：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/custom-transition'</span>,</span><br><span class="line">    component: PanelLeft,</span><br><span class="line">    meta: &#123; <span class="attr">transition</span>: <span class="string">'slide-left'</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/other-transition'</span>,</span><br><span class="line">    component: PanelRight,</span><br><span class="line">    meta: &#123; <span class="attr">transition</span>: <span class="string">'slide-right'</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">"&#123; Component, route &#125;"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用任何自定义过渡和回退到 `fade` --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">:name</span>=<span class="string">"route.meta.transition || 'fade'"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"Component"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="基于路由的动态过渡"><a href="#基于路由的动态过渡" class="headerlink" title="基于路由的动态过渡"></a>基于路由的动态过渡</h4><p>也可以根据目标路由和当前路由之间的关系，动态地确定使用的过渡。使用和刚才非常相似的片段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用动态过渡名称 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">"&#123; Component, route &#125;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">:name</span>=<span class="string">"route.meta.transition"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"Component"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以添加一个 <code>after</code> <code>navigation</code> <code>hook</code>，根据路径的深度动态添加信息到 <code>meta</code> 字段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> toDepth = to.path.split(<span class="string">'/'</span>).length</span><br><span class="line">  <span class="keyword">const</span> fromDepth = <span class="keyword">from</span>.path.split(<span class="string">'/'</span>).length</span><br><span class="line">  to.meta.transition = toDepth &lt; fromDepth ? <span class="string">'slide-right'</span> : <span class="string">'slide-left'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="强制在复用的视图之间进行过渡"><a href="#强制在复用的视图之间进行过渡" class="headerlink" title="强制在复用的视图之间进行过渡"></a>强制在复用的视图之间进行过渡</h4><p>Vue 可能会自动复用看起来相似的组件，从而忽略了任何过渡。幸运的是，可以添加一个 <code>key</code> 属性来强制过渡。这也允许你在相同路由上使用不同的参数触发过渡：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view v-slot=&quot;&#123; Component, route &#125;&quot;&gt;</span><br><span class="line">  &lt;transition name=&quot;fade&quot;&gt;</span><br><span class="line">    &lt;component :is=&quot;Component&quot; :key=&quot;route.path&quot; /&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vuejs.org/guide/built-ins/transition.html#the-transition-component" target="_blank" rel="noopener">参考</a></p>
<h3 id="滚动行为"><a href="#滚动行为" class="headerlink" title="滚动行为"></a>滚动行为</h3><p>使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。</p>
<blockquote>
<p>注意: 这个功能只在支持 history.pushState 的浏览器中可用。</p>
</blockquote>
<p>当创建一个 Router 实例，你可以提供一个 <code>scrollBehavior</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  history: createWebHashHistory(),</span><br><span class="line">  routes: [...],</span><br><span class="line">  scrollBehavior (to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="comment">// return 期望滚动到哪个的位置</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>scrollBehavior</code> 函数接收 <code>to</code> 和 <code>from</code> 路由对象。第三个参数 <code>savedPosition</code>，只有当这是一个 <code>popstate</code> 导航时才可用（由浏览器的后退/前进按钮触发）。<br>该函数可以返回一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/scroll" target="_blank" rel="noopener">ScrollToOptions</a> 位置对象:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  scrollBehavior(to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="comment">// 始终滚动到顶部</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">top</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>你也可以通过 <code>el</code> 传递一个 <code>CSS</code> 选择器或一个 <code>DOM</code> 元素。在这种情况下，<code>top</code> 和 <code>left</code> 将被视为该元素的相对偏移量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  scrollBehavior(to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="comment">// 始终在元素 #main 上方滚动 10px</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 也可以这么写</span></span><br><span class="line">      <span class="comment">// el: document.getElementById('main'),</span></span><br><span class="line">      el: <span class="string">'#main'</span>,</span><br><span class="line">      top: <span class="number">-10</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果返回一个 <code>false</code> 的值，或者是一个<code>空对象</code>，那么不会发生滚动。<br>返回 <code>savedPosition</code>，在按下 后退/前进 按钮时，就会像浏览器的原生表现那样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onst router = createRouter(&#123;</span><br><span class="line">  scrollBehavior(to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="keyword">if</span> (savedPosition) &#123;</span><br><span class="line">      <span class="keyword">return</span> savedPosition</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">top</span>: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>如果你要模拟 “滚动到锚点” 的行为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  scrollBehavior(to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="keyword">if</span> (to.hash) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        el: to.hash,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果你的浏览器支持滚动行为，你可以让它变得更流畅：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  scrollBehavior(to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="keyword">if</span> (to.hash) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        el: to.hash,</span><br><span class="line">        behavior: <span class="string">'smooth'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="延迟滚动"><a href="#延迟滚动" class="headerlink" title="延迟滚动"></a>延迟滚动</h4><p>有时候，我们需要在页面中滚动之前稍作等待。例如，当处理过渡时，我们希望等待过渡结束后再滚动。要做到这一点，你可以返回一个 Promise，它可以返回所需的位置描述符。下面是一个例子，我们在滚动前等待 500ms：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  scrollBehavior(to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(&#123; <span class="attr">left</span>: <span class="number">0</span>, <span class="attr">top</span>: <span class="number">0</span> &#125;)</span><br><span class="line">      &#125;, <span class="number">500</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效。</p>
<p>Vue Router 支持开箱即用的动态导入，这意味着你可以用动态导入代替静态导入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将</span></span><br><span class="line"><span class="comment">// import UserDetails from './views/UserDetails.vue'</span></span><br><span class="line"><span class="comment">// 替换成</span></span><br><span class="line"><span class="keyword">const</span> UserDetails = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./views/UserDetails.vue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  routes: [&#123; <span class="attr">path</span>: <span class="string">'/users/:id'</span>, <span class="attr">component</span>: UserDetails &#125;],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>component</code> (和 <code>components</code>) 配置接收一个返回 <code>Promise</code> 组件的函数，Vue Router 只会在第一次进入页面时才会获取这个函数，然后使用缓存数据。这意味着你也可以使用更复杂的函数，只要它们返回一个 <code>Promise</code> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserDetails = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">    <span class="comment">/* 组件定义 */</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般来说，对所有的路由都使用动态导入是个好主意。</p>
</blockquote>
<p><strong>注意</strong>：<br><strong><em>不要</em></strong>在路由中使用<strong><em>异步组件</em></strong>。异步组件仍然可以在路由组件中使用，但路由组件本身就是动态导入的。</p>
<p>如果你使用的是 <code>webpack</code> 之类的打包器，它将自动从代码分割中受益。</p>
<p>如果你使用的是 <code>Babel</code>，你将需要添加 <code>syntax-dynamic-import</code> 插件，才能使 <code>Babel</code> 正确地解析语法。</p>
<h4 id="把组件按组分块"><a href="#把组件按组分块" class="headerlink" title="把组件按组分块"></a>把组件按组分块</h4><h5 id="使用-webpack"><a href="#使用-webpack" class="headerlink" title="使用 webpack"></a>使用 webpack</h5><p>有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用命名 chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack &gt; 2.4)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserDetails = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-user" */</span> <span class="string">'./UserDetails.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> UserDashboard = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-user" */</span> <span class="string">'./UserDashboard.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> UserProfileEdit = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "group-user" */</span> <span class="string">'./UserProfileEdit.vue'</span>)</span><br></pre></td></tr></table></figure>
<p>webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中。</p>
<h5 id="使用-Vite"><a href="#使用-Vite" class="headerlink" title="使用 Vite"></a>使用 Vite</h5><p>在Vite中，你可以在 <code>rollupOptions</code> 下定义分块：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  build: &#123;</span><br><span class="line">    rollupOptions: &#123;</span><br><span class="line">      <span class="comment">// https://rollupjs.org/guide/en/#outputmanualchunks</span></span><br><span class="line">      output: &#123;</span><br><span class="line">        manualChunks: &#123;</span><br><span class="line">          <span class="string">'group-user'</span>: [</span><br><span class="line">            <span class="string">'./src/UserDetails'</span>,</span><br><span class="line">            <span class="string">'./src/UserDashboard'</span>,</span><br><span class="line">            <span class="string">'./src/UserProfileEdit'</span>,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>对路由的添加通常是通过 <code>routes</code> 选项来完成的，但是在某些情况下，你可能想在应用程序已经运行的时候添加或删除路由。具有可扩展接口(如<code>Vue CLI UI</code> )这样的应用程序可以使用它来扩展应用程序。</p>
<h4 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h4><p>动态路由主要通过两个函数实现。<code>router.addRoute()</code> 和 <code>router.removeRoute()</code>。它们只注册一个新的路由，也就是说，如果新增加的路由与当前位置相匹配，就需要你用 <code>router.push()</code> 或 <code>router.replace()</code> 来手动导航，才能显示该新路由。我们来看一个例子：</p>
<p>想象一下，只有一个路由的以下路由：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  history: createWebHistory(),</span><br><span class="line">  routes: [&#123; <span class="attr">path</span>: <span class="string">'/:articleName'</span>, <span class="attr">component</span>: Article &#125;],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>进入任何页面，<code>/about</code>，<code>/store</code>，或者 <code>/3-tricks-to-improve-your-routing-code</code> 最终都会呈现 <code>Article</code> 组件。如果我们在 <code>/about</code> 上添加一个新的路由：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router.addRoute(&#123; <span class="attr">path</span>: <span class="string">'/about'</span>, <span class="attr">component</span>: About &#125;)</span><br><span class="line">页面仍然会显示 Article 组件，我们需要手动调用 router.replace() 来改变当前的位置，并覆盖我们原来的位置（而不是添加一个新的路由，最后在我们的历史中两次出现在同一个位置）：</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.addRoute(&#123; <span class="attr">path</span>: <span class="string">'/about'</span>, <span class="attr">component</span>: About &#125;)</span><br><span class="line"><span class="comment">// 我们也可以使用 this.$route 或 route = useRoute() （在 setup 中）</span></span><br><span class="line">router.replace(router.currentRoute.value.fullPath)</span><br></pre></td></tr></table></figure>
<p>记住，如果你需要等待新的路由显示，可以使用 <code>await router.replace()</code>。</p>
<h4 id="在导航守卫中添加路由"><a href="#在导航守卫中添加路由" class="headerlink" title="在导航守卫中添加路由"></a>在导航守卫中添加路由</h4><p>如果你决定在导航守卫内部添加或删除路由，你不应该调用 <code>router.replace()</code>，而是通过返回新的位置来触发重定向：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function"><span class="params">to</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasNecessaryRoute(to)) &#123;</span><br><span class="line">    router.addRoute(generateRoute(to))</span><br><span class="line">    <span class="comment">// 触发重定向</span></span><br><span class="line">    <span class="keyword">return</span> to.fullPath</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面的例子有两个假设：<br>第一，新添加的路由记录将与 <code>to</code> 位置相匹配，实际上导致与我们试图访问的位置不同。<br>第二，<code>hasNecessaryRoute()</code> 在添加新的路由后返回 <code>false</code>，以避免无限重定向。</p>
<p>因为是在重定向中，所以我们是在替换将要跳转的导航，实际上行为就像之前的例子一样。而在实际场景中，添加路由的行为更有可能发生在导航守卫之外，例如，当一个视图组件挂载时，它会注册新的路由。</p>
<h4 id="删除路由"><a href="#删除路由" class="headerlink" title="删除路由"></a>删除路由</h4><p>有几个不同的方法来删除现有的路由：</p>
<ul>
<li>通过添加一个名称冲突的路由。如果添加与现有途径名称相同的途径，会先删除路由，再添加路由：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.addRoute(&#123; <span class="attr">path</span>: <span class="string">'/about'</span>, <span class="attr">name</span>: <span class="string">'about'</span>, <span class="attr">component</span>: About &#125;)</span><br><span class="line"><span class="comment">// 这将会删除之前已经添加的路由，因为他们具有相同的名字且名字必须是唯一的</span></span><br><span class="line">router.addRoute(&#123; <span class="attr">path</span>: <span class="string">'/other'</span>, <span class="attr">name</span>: <span class="string">'about'</span>, <span class="attr">component</span>: Other &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>通过调用 <code>router.addRoute()</code> 返回的回调：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> removeRoute = router.addRoute(routeRecord)</span><br><span class="line">removeRoute() <span class="comment">// 删除路由如果存在的话</span></span><br></pre></td></tr></table></figure>
<p>当路由没有名称时，这很有用。</p>
<ul>
<li>通过使用 <code>router.removeRoute()</code> 按名称删除路由：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.addRoute(&#123; <span class="attr">path</span>: <span class="string">'/about'</span>, <span class="attr">name</span>: <span class="string">'about'</span>, <span class="attr">component</span>: About &#125;)</span><br><span class="line"><span class="comment">// 删除路由</span></span><br><span class="line">router.removeRoute(<span class="string">'about'</span>)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果你想使用这个功能，但又想避免名字的冲突，可以在路由中使用 <code>Symbol</code> 作为名字。</p>
<p>当路由被删除时，所有的别名和子路由也会被同时删除</p>
<h4 id="添加嵌套路由"><a href="#添加嵌套路由" class="headerlink" title="添加嵌套路由"></a>添加嵌套路由</h4><p>要将嵌套路由添加到现有的路由中，可以将路由的 <strong><em>name</em></strong> 作为第一个参数传递给 <code>router.addRoute()</code>，这将有效地添加路由，就像通过 <code>children</code> 添加的一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router.addRoute(&#123; <span class="attr">name</span>: <span class="string">'admin'</span>, <span class="attr">path</span>: <span class="string">'/admin'</span>, <span class="attr">component</span>: Admin &#125;)</span><br><span class="line">router.addRoute(<span class="string">'admin'</span>, &#123; <span class="attr">path</span>: <span class="string">'settings'</span>, <span class="attr">component</span>: AdminSettings &#125;)</span><br></pre></td></tr></table></figure>
<p>这等效于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.addRoute(&#123;</span><br><span class="line">  name: <span class="string">'admin'</span>,</span><br><span class="line">  path: <span class="string">'/admin'</span>,</span><br><span class="line">  component: Admin,</span><br><span class="line">  children: [&#123; <span class="attr">path</span>: <span class="string">'settings'</span>, <span class="attr">component</span>: AdminSettings &#125;],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="查看现有路由"><a href="#查看现有路由" class="headerlink" title="查看现有路由"></a>查看现有路由</h4><p>Vue Router 提供了两个功能来查看现有的路由：</p>
<ul>
<li><code>router.hasRoute()</code>：检查路由是否存在。</li>
<li><code>router.getRoutes()</code>：获取一个包含所有路由记录的数组。</li>
</ul>

        
    </section>
</article>





<div class="comments">
    <div id="comments"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
    new Gitalk({
        clientID: "7fbe80427f54741e289f",
        clientSecret: "f34ed5fd92e54c9000bd37ba951948cb939deff5",
        repo: "sanonz.github.io",
        owner: "sanonz",
        admin: ["sanonz"],
        id: "2023/08/21/vRouter",
        distractionFreeMode: true,
        title: "vue-Router",
        body: "http://www.shuy.cc/2023/08/21/vRouter/",
        labels: []
    }).render('comments');
    </script>
</div>


        </div>
        <footer class="footer">
    Copyright © Aaron All Rights Reserved 京ICP备17007771号-1
</footer>

    </main>

    <script type="text/javascript" src="https://unpkg.com/jquery@1.9.1/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }

            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle('normal', slideDone);
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp('normal', slideDone);
            }, 3000);
        }

        function slideDone() {
            if (nodes.navInner.css('display') !== 'none') {
                nodes.navInner.css('display', '');
            }
        }

        $(window).on('resize', function() {
            console.log($(this).width())
            if ($(this).width() > 960) {
                nodes.navInner.css('display', '');
            }
        });
    });
    </script>
    
        <script src="/js/scrollspy.min.js"></script>
        <script type="text/javascript">
        $(document.body).scrollspy({target: '#aside-inner'});

        $(window).on('resize', function() {
            var hw = $('#header').width();
            var ww = $('#wrapper').width();
            var space = ($(this).width() - hw - ww) / 2 / 2;

            var pageprev = $('#pageprev');
            var pagenext = $('#pagenext');
            var avg = (pageprev.width() + pagenext.width()) / 2

            if(space > avg) {
                var len = space - avg / 2;
                // var styles = {position: 'fixed', top: '50%', marginTop: - (pageprev.width() + pagenext.width()) / 4}
                // pageprev.css($.extend({left: hw + len}, styles));
                // pagenext.css($.extend({right: len}, styles));
            } else {
                pageprev.removeAttr('style');
                // pagenext.removeAttr('style');
            }
        }).trigger('resize');
        </script>
    

</body>
</html>
