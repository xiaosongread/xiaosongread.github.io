<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>TypeScript 深入浅出 | 前端技术博客</title>
    <meta name="author" content="xiaosongread">
    <meta name="keywords" content="小宋 抿圪斗前端 前端 前端博客 框架 工程 css html js node markdown npm webpack">
    <meta name="description" content="什么是 TypeScript?TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。简而言之，TypeScript是JavaScript的超集，具有可选的类型并可以编译为纯JavaScript。从技术上讲TypeScript就是具有静态类型的 JavaScript 。为什么需要 TypeScript?TypeScript 具有类型系统，可以捕获在JavaScript中...">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="前端技术博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <style type="text/css">
    @font-face {
        font-family: 'icomoon';
        src: url("/fonts/icomoon.eot?q628ml");
        src: url("/fonts/icomoon.eot?q628ml#iefix") format('embedded-opentype'),
             url("/fonts/icomoon.ttf?q628ml") format('truetype'),
             url("/fonts/icomoon.woff?q628ml") format('woff'),
             url("/fonts/icomoon.svg?q628ml#icomoon") format('svg');
        font-weight: normal;
        font-style: normal;
    }
    </style>
    <link rel="stylesheet" href="/css/style.css">

    <!--[if lt IE 9]><style type="text/css">.nav-inner {top:0;}.author-meta {position:static;top:0;}.search-form {height:36px;}</style><script type="text/javascript" src="https://unpkg.com/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
</head>
<body>

    <main class="app">
        <header id="header" class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">前端技术博客</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">列表</span>
            </a>
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/categories/css-end/">
                <span class="nav-text">css</span>
            </a>
        
            <a class="nav-item" href="/categories/js-end/">
                <span class="nav-text">js</span>
            </a>
        
            <a class="nav-item" href="/categories/gc-end/">
                <span class="nav-text">工程</span>
            </a>
        
            <a class="nav-item" href="/categories/sh-end/">
                <span class="nav-text">日常</span>
            </a>
        
            <a class="nav-item" href="/categories/my-end/">
                <span class="nav-text">关于我</span>
            </a>
        
    </nav>
</div>

    
<aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-TypeScript"><span class="toc-number">1.</span> <span class="toc-text">什么是 TypeScript?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么需要-TypeScript"><span class="toc-number">2.</span> <span class="toc-text">为什么需要 TypeScript?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文档链接"><span class="toc-number">3.</span> <span class="toc-text">文档链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeScript-安装"><span class="toc-number">4.</span> <span class="toc-text">TypeScript 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeScript-编译"><span class="toc-number">4.1.</span> <span class="toc-text">TypeScript 编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生成-tsconfig-json-配置文件"><span class="toc-number">4.2.</span> <span class="toc-text">生成 tsconfig.json 配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#开启了监听模式-实时监测app-ts-同步到app-js"><span class="toc-number">4.3.</span> <span class="toc-text">开启了监听模式 实时监测app.ts 同步到app.js</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeScript-编译选项"><span class="toc-number">4.4.</span> <span class="toc-text">TypeScript 编译选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeScript-编译选项示例"><span class="toc-number">4.5.</span> <span class="toc-text">TypeScript 编译选项示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeScript-编译选项-1"><span class="toc-number">4.6.</span> <span class="toc-text">TypeScript 编译选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeScript-基础类型"><span class="toc-number">5.</span> <span class="toc-text">TypeScript 基础类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Boolean-类型"><span class="toc-number">5.1.</span> <span class="toc-text">Boolean 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Number-类型"><span class="toc-number">5.2.</span> <span class="toc-text">Number 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-类型"><span class="toc-number">5.3.</span> <span class="toc-text">String 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-类型"><span class="toc-number">5.4.</span> <span class="toc-text">Array 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Enum-枚举类型"><span class="toc-number">5.5.</span> <span class="toc-text">Enum 枚举类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-数组类型"><span class="toc-number">5.6.</span> <span class="toc-text">Array 数组类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#元组（tuple）类型"><span class="toc-number">5.7.</span> <span class="toc-text">元组（tuple）类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#null、undefined-类型"><span class="toc-number">5.8.</span> <span class="toc-text">null、undefined 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#any-类型"><span class="toc-number">5.9.</span> <span class="toc-text">any 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-类型"><span class="toc-number">5.10.</span> <span class="toc-text">void 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#never-类型"><span class="toc-number">5.11.</span> <span class="toc-text">never 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unknown-类型"><span class="toc-number">5.12.</span> <span class="toc-text">Unknown 类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象类型"><span class="toc-number">6.</span> <span class="toc-text">对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#object、-Object-、-类型"><span class="toc-number">6.1.</span> <span class="toc-text">object、 Object 、 {} 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类"><span class="toc-number">6.2.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组"><span class="toc-number">6.3.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数"><span class="toc-number">6.4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#函数声明"><span class="toc-number">6.4.1.</span> <span class="toc-text">函数声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#函数表达式"><span class="toc-number">6.4.2.</span> <span class="toc-text">函数表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#接口定义函数"><span class="toc-number">6.4.3.</span> <span class="toc-text">接口定义函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#可选参数"><span class="toc-number">6.4.4.</span> <span class="toc-text">可选参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#默认参数"><span class="toc-number">6.4.5.</span> <span class="toc-text">默认参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#剩余参数"><span class="toc-number">6.4.6.</span> <span class="toc-text">剩余参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#函数重载"><span class="toc-number">6.4.7.</span> <span class="toc-text">函数重载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型推论"><span class="toc-number">7.</span> <span class="toc-text">类型推论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型断言"><span class="toc-number">8.</span> <span class="toc-text">类型断言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#非空断言"><span class="toc-number">8.1.</span> <span class="toc-text">非空断言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#确定赋值断言"><span class="toc-number">8.2.</span> <span class="toc-text">确定赋值断言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#联合类型"><span class="toc-number">9.</span> <span class="toc-text">联合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型别名"><span class="toc-number">10.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#交叉类型"><span class="toc-number">11.</span> <span class="toc-text">交叉类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型守卫"><span class="toc-number">12.</span> <span class="toc-text">类型守卫</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#·-in-关键字"><span class="toc-number">12.1.</span> <span class="toc-text">· in 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#·-typeof-关键字"><span class="toc-number">12.2.</span> <span class="toc-text">· typeof 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#·-instanceof"><span class="toc-number">12.3.</span> <span class="toc-text">· instanceof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#·-自定义类型保护的类型谓词"><span class="toc-number">12.4.</span> <span class="toc-text">· 自定义类型保护的类型谓词</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口"><span class="toc-number">13.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#设置接口可选-只读"><span class="toc-number">13.1.</span> <span class="toc-text">设置接口可选|只读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#索引签名"><span class="toc-number">13.2.</span> <span class="toc-text">索引签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接口与类型别名的区别"><span class="toc-number">13.3.</span> <span class="toc-text">接口与类型别名的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不同点"><span class="toc-number">13.4.</span> <span class="toc-text">不同点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型"><span class="toc-number">14.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本使用"><span class="toc-number">14.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用"><span class="toc-number">14.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多个参数"><span class="toc-number">14.3.</span> <span class="toc-text">多个参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型约束"><span class="toc-number">14.4.</span> <span class="toc-text">泛型约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型接口"><span class="toc-number">14.5.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型类"><span class="toc-number">14.6.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型类型别名"><span class="toc-number">14.7.</span> <span class="toc-text">泛型类型别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型参数的默认类型"><span class="toc-number">14.8.</span> <span class="toc-text">泛型参数的默认类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#泛型工具类型"><span class="toc-number">14.9.</span> <span class="toc-text">泛型工具类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内置工具类型"><span class="toc-number">14.10.</span> <span class="toc-text">内置工具类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tsconfig-json"><span class="toc-number">15.</span> <span class="toc-text">tsconfig.json</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#重要字段"><span class="toc-number">15.1.</span> <span class="toc-text">重要字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#compilerOptions-选项"><span class="toc-number">15.2.</span> <span class="toc-text">compilerOptions 选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#补充"><span class="toc-number">16.</span> <span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#构造函数"><span class="toc-number">16.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#继承"><span class="toc-number">16.2.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super"><span class="toc-number">16.3.</span> <span class="toc-text">super</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#抽象"><span class="toc-number">16.4.</span> <span class="toc-text">抽象</span></a></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
            <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            TypeScript 深入浅出
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://www.shuy.cc/2023/10/04/typescript/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2023-10-04T03:18:41.000Z" itemprop="datePublished">2023-10-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/TypeScript-js/">TypeScript js</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h3 id="什么是-TypeScript"><a href="#什么是-TypeScript" class="headerlink" title="什么是 TypeScript?"></a>什么是 TypeScript?</h3><p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</p>
<blockquote>
<p>简而言之，TypeScript是JavaScript的超集，具有可选的类型并可以编译为纯JavaScript。从技术上讲TypeScript就是具有静态类型的 JavaScript 。</p>
</blockquote>
<a id="more"></a>
<h3 id="为什么需要-TypeScript"><a href="#为什么需要-TypeScript" class="headerlink" title="为什么需要 TypeScript?"></a>为什么需要 TypeScript?</h3><ul>
<li>TypeScript 具有类型系统，可以捕获在JavaScript中可能出现的类型错误。</li>
<li>TypeScript 还具有 ECMAScript 6（ES6）的所有功能，如类，模块，迭代器和生成器。</li>
<li>TypeScript 还具有 JavaScript 中没有的许多功能，如接口，类型断言，类型保护，类型别名，命名空间和模块重定向。</li>
</ul>
<h3 id="文档链接"><a href="#文档链接" class="headerlink" title="文档链接"></a>文档链接</h3><p><a href="https://www.tslang.cn/docs/handbook/basic-types.html" target="_blank" rel="noopener">https://www.tslang.cn/docs/handbook/basic-types.html</a></p>
<h3 id="TypeScript-安装"><a href="#TypeScript-安装" class="headerlink" title="TypeScript 安装"></a>TypeScript 安装</h3><p>TypeScript 安装非常简单。</p>
<p>首先，你需要安装 Node.js。Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时。</p>
<p>安装 Node.js 后，你就可以使用 npm 命令安装 TypeScript。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure>
<h4 id="TypeScript-编译"><a href="#TypeScript-编译" class="headerlink" title="TypeScript 编译"></a>TypeScript 编译</h4><p>TypeScript 编译器将 TypeScript 代码转换为 JavaScript 代码。</p>
<p>TypeScript 编译器在命令行上运行，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure>
<h4 id="生成-tsconfig-json-配置文件"><a href="#生成-tsconfig-json-配置文件" class="headerlink" title="生成 tsconfig.json 配置文件"></a>生成 tsconfig.json 配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init ​</span><br></pre></td></tr></table></figure>
<h4 id="开启了监听模式-实时监测app-ts-同步到app-js"><a href="#开启了监听模式-实时监测app-ts-同步到app-js" class="headerlink" title="开启了监听模式 实时监测app.ts 同步到app.js"></a>开启了监听模式 实时监测app.ts 同步到app.js</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc app.ts -w</span><br></pre></td></tr></table></figure>
<p>接着执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure>
<h4 id="TypeScript-编译选项"><a href="#TypeScript-编译选项" class="headerlink" title="TypeScript 编译选项"></a>TypeScript 编译选项</h4><p>TypeScript 编译器有多个编译选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<h4 id="TypeScript-编译选项示例"><a href="#TypeScript-编译选项示例" class="headerlink" title="TypeScript 编译选项示例"></a>TypeScript 编译选项示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --target es5 --module commonjs hello.ts</span><br></pre></td></tr></table></figure>
<h4 id="TypeScript-编译选项-1"><a href="#TypeScript-编译选项-1" class="headerlink" title="TypeScript 编译选项"></a>TypeScript 编译选项</h4><table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>–help</td>
<td>显示帮助消息</td>
</tr>
<tr>
<td>–version</td>
<td>显示版本号</td>
</tr>
<tr>
<td>–declaration</td>
<td>生成相应的 .d.ts 文件</td>
</tr>
<tr>
<td>–watch</td>
<td>监视文件改变</td>
</tr>
<tr>
<td>–removeComments</td>
<td>删除所有注释</td>
</tr>
<tr>
<td>–noImplicitAny</td>
<td>在表达式和声明上有隐含的 any类型时报错</td>
</tr>
<tr>
<td>–noImplicitThis</td>
<td>this 表达式的类型为 any 时报错</td>
</tr>
<tr>
<td>–alwaysStrict</td>
<td>以严格模式检查每个模块，并把“use strict”添加到每个输出文件</td>
</tr>
<tr>
<td>–strictNullChecks</td>
<td>启用严格的 Null 检查</td>
</tr>
<tr>
<td>–strictFunctionTypes</td>
<td>启用严格函数类型检查</td>
</tr>
<tr>
<td>–strictPropertyInitialization</td>
<td>启用严格检查属性初始化</td>
</tr>
<tr>
<td>–strictBindCallApply</td>
<td>启用严格检查 call、bind和apply的参数匹配和返回值</td>
</tr>
<tr>
<td>–strictNullPropertyInitialization</td>
<td>启用严格检查属性初始化</td>
</tr>
<tr>
<td>–strict</td>
<td>启用所有严格检查选项</td>
</tr>
<tr>
<td>–noEmitOnError</td>
<td>在有错误的情况下不生成输出文件</td>
</tr>
<tr>
<td>–noEmit</td>
<td>不生成输出文件</td>
</tr>
<tr>
<td>–preserveConstEnums</td>
<td>保留使用 const 和 enum 声明的枚举</td>
</tr>
<tr>
<td>–allowJs</td>
<td>允许编译 javascript 文件</td>
</tr>
<tr>
<td>–checkJs</td>
<td>报告 javascript 文件中的错误</td>
</tr>
<tr>
<td>–nocheckJs</td>
<td>不检查 javascript 文件</td>
</tr>
<tr>
<td>–allowSyntheticDefaultImports</td>
<td>允许从没有设置默认导出的模块中默认导入</td>
</tr>
<tr>
<td>–noImplicitReturns</td>
<td>函数表达式和函数声明必须有返回值</td>
</tr>
<tr>
<td>–noFallthroughCasesInSwitch</td>
<td>报告 switch 语句的 fallthrough 错误</td>
</tr>
<tr>
<td>–noUnusedLocals</td>
<td>报告未使用的本地变量</td>
</tr>
<tr>
<td>–noUnusedParameters</td>
<td>报告未使用的参数</td>
</tr>
</tbody>
</table>
<h3 id="TypeScript-基础类型"><a href="#TypeScript-基础类型" class="headerlink" title="TypeScript 基础类型"></a>TypeScript 基础类型</h3><p>js的数据类型 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number 、string、 null 、 undefined、 boolean、 object、  <span class="keyword">function</span>、 array</span><br></pre></td></tr></table></figure>
<p>ts新增的数据类型<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">any任意类型 enum 枚举 联合类型 字面量类型 unknown void</span><br></pre></td></tr></table></figure></p>
<h4 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h4><p>声明一个变量flag，同时指定它的类型为boolean<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flag: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h4><p>声明一个变量a，同时指定它的类型为number<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count: <span class="built_in">number</span> = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h4><p>声明一个变量str，同时指定它的类型为string<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">"树哥"</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h4><p>声明一个变量arr，同时指定它的类型为array<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></p>
<h4 id="Enum-枚举类型"><a href="#Enum-枚举类型" class="headerlink" title="Enum 枚举类型"></a>Enum 枚举类型</h4><p>枚举类型用于定义数值集合，使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。，如周一到周日，方位上下左右等</p>
<ul>
<li>普通枚举</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">  Red,</span><br><span class="line">  Green,</span><br><span class="line">  Blue</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c: Color = Color.Red;</span><br><span class="line"><span class="keyword">const</span> c1: Color = Color.Green;</span><br><span class="line"><span class="built_in">console</span>.log(c, c1); <span class="comment">// 0 1</span></span><br></pre></td></tr></table></figure>
<p>以上代码转化后的代码为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Color;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Color</span>) </span>&#123;</span><br><span class="line">    Color[Color[<span class="string">"Red"</span>] = <span class="number">0</span>] = <span class="string">"Red"</span>;</span><br><span class="line">    Color[Color[<span class="string">"Green"</span>] = <span class="number">1</span>] = <span class="string">"Green"</span>;</span><br><span class="line">    Color[Color[<span class="string">"Blue"</span>] = <span class="number">2</span>] = <span class="string">"Blue"</span>;</span><br><span class="line">&#125;)(Color || (Color = &#123;&#125;));</span><br><span class="line"><span class="keyword">var</span> c = Color.Red;</span><br><span class="line"><span class="keyword">var</span> c1 = Color.Green;</span><br><span class="line"><span class="built_in">console</span>.log(c, c1);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>初始值默认为 0 其余的成员会会按顺序自动增长 可以理解为数组下标</p>
</blockquote>
<ul>
<li>设置初始值</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">  RED = <span class="number">2</span>,</span><br><span class="line">  PINK,</span><br><span class="line">  BLUE,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pink: Color = Color.PINK;</span><br><span class="line"><span class="built_in">console</span>.log(pink); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串枚举</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">  Red = <span class="string">"red"</span>,</span><br><span class="line">  Green = <span class="string">"green"</span>,</span><br><span class="line">  Blue = <span class="string">"blue"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Red: Color = Color.Red;</span><br><span class="line"><span class="built_in">console</span>.log(Red) <span class="comment">// "red"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>常量枚举</li>
</ul>
<p>使用 <strong>const 关键字修饰的枚举</strong>，<br>常量枚举与普通枚举的区别是，整个枚举会在编译阶段被删除 我们可以看下编译之后的效果</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">  Red,</span><br><span class="line">  Green,</span><br><span class="line">  Blue,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> color: Color[] = [Color.Red, Color.Green, Color.Blue];</span><br><span class="line"><span class="built_in">console</span>.log(color); <span class="comment">//[0, 1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后、</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">  Red,</span><br><span class="line">  Green,</span><br><span class="line">  Blue,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> color: Color[] = [Color.Red, Color.Green, Color.Blue];</span><br><span class="line"><span class="built_in">console</span>.log(color); <span class="comment">//[0, 1, 2]</span></span><br></pre></td></tr></table></figure>
<h4 id="Array-数组类型"><a href="#Array-数组类型" class="headerlink" title="Array 数组类型"></a>Array 数组类型</h4><p>对数组类型的定义有两种方式:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr1:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h4 id="元组（tuple）类型"><a href="#元组（tuple）类型" class="headerlink" title="元组（tuple）类型"></a>元组（tuple）类型</h4><p>上面数组类型的方式，只能定义出内部全为同种类型的数组。对于内部不同类型的数组可以使用元组类型来定义<br>元组（ Tuple ）表示一个已知数量和类型的数组,可以理解为他是一种特殊的数组</p>
<p>元组，就是固定长度的数组     语法：<code>[类型, 类型, 类型]</code></p>
<p>  <code>const tuple: [number, string] = [1, &quot;zhangmazi&quot;];</code></p>
<blockquote>
<p>需要注意的是，元组类型只能表示一个已知元素数量和类型的数组，长度已指定，越界访问会提示错误。例如，一个数组中可能有多种类型，数量和类型都不确定，那就直接<code>any[]</code>。</p>
</blockquote>
<h4 id="null、undefined-类型"><a href="#null、undefined-类型" class="headerlink" title="null、undefined 类型"></a>null、undefined 类型</h4><p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 也就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给其他类型。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> b: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="string">'zhangmazi'</span>;</span><br><span class="line">str = <span class="literal">null</span>; <span class="comment">// 编译正确</span></span><br><span class="line">str = <span class="literal">undefined</span>; <span class="comment">// 编译正确</span></span><br></pre></td></tr></table></figure></p>
<p>如果你在<code>tsconfig.json</code>指定了”strictNullChecks”:true ，即开启严格模式后， <code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自的类型。 </p>
<blockquote>
<p><code>null</code> 和 <code>undefined</code> 只能给它们自己的类型赋值<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用 --strictNullChecks</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="built_in">number</span>;</span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// 编译正确</span></span><br><span class="line">x = <span class="literal">undefined</span>;    <span class="comment">// 编译错误</span></span><br><span class="line">x = <span class="literal">null</span>;    <span class="comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是 undefined 可以给 void 赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c:<span class="built_in">void</span> = <span class="literal">undefined</span> <span class="comment">// 编译正确</span></span><br><span class="line"><span class="keyword">let</span> d:<span class="built_in">void</span> = <span class="literal">null</span> <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h4><ul>
<li>any会跳过类型检查器对值的检查，任何值都可以赋值给any类型 any类型就是js（建议不要用）</li>
<li>ts会有命名规范，不能命名为any</li>
<li>any 表示的是任意类型，一个变量设置类型为any后相当于对该变量关闭了TS的类型检测</li>
<li>声明变量如果不指定类型，则TS解析器会自动判断变量的类型为any （隐式的any）</li>
<li>any是可以赋值任何类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">any</span> = <span class="number">1</span>;</span><br><span class="line">value = <span class="string">"zhangmazi"</span>; <span class="comment">// 编译正确</span></span><br><span class="line">value = []; <span class="comment">// 编译正确</span></span><br><span class="line">value = &#123;&#125;;<span class="comment">// 编译正确</span></span><br></pre></td></tr></table></figure>
<h4 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h4><p><code>void</code> 意思就是无效的, 一般只用在函数上，告诉别人这个函数没有返回值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hello 啊，树哥！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h4><p>抛出异常</p>
<p>never 类型表示的是那些永不存在的值的类型。<br>例如never 类型是那些总是会<strong>抛出异常</strong>或根本就不会有返回值的<strong>函数表达式</strong>或<strong>箭头函数表达式</strong>的返回值类型</p>
<p>值会永不存在的两种情况：</p>
<ol>
<li>如果一个函数执行时抛出了异常，那么这个函数永远不存在返回值（因为抛出异常会直接中断程序运行，这使得程序运行不到返回值那一步，即具有不可达的终点，也就永不存在返回了）</li>
<li>函数中执行无限循环的代码（死循环），使得程序永远无法运行到函数返回值那一步，永不存在返回。</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异常</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">msg: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123; <span class="comment">// 编译正确</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(msg); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 死循环</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loopForever</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123; <span class="comment">// 编译正确</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Unknown-类型"><a href="#Unknown-类型" class="headerlink" title="Unknown 类型"></a>Unknown 类型</h4><p><code>unknown</code> 与 <code>any</code> 一样，所有类型都可以分配给 <code>unknown</code>:<br><code>unknown</code> 表示未知类型的值<br>只能赋值给<code>unkonwn</code> <code>any</code><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown = <span class="number">1</span>;</span><br><span class="line">value = <span class="string">"zhangmazi"</span>; <span class="comment">// 编译正确</span></span><br><span class="line">value = <span class="literal">false</span>; <span class="comment">// 编译正确</span></span><br></pre></td></tr></table></figure></p>
<p><code>unknown</code>与<code>any</code>的最大区别是：</p>
<blockquote>
<p>任何类型的值可以赋值给<code>any</code>，同时<code>any</code>类型的值也可以赋值给任何类型。<br><code>unknown</code> 任何类型的值都可以赋值给它，但它只能赋值给<code>unknown</code>和<code>any</code></p>
</blockquote>
<h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>这里所说的对象类型，就是我们常说的函数、{}、数组、类</p>
<h4 id="object、-Object-、-类型"><a href="#object、-Object-、-类型" class="headerlink" title="object、 Object 、 {} 类型"></a>object、 Object 、 {} 类型</h4><ul>
<li>object<br><code>object</code> 类型用于表示所有的非原始类型，即我们不能把 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>symbol</code>等 原始类型赋值给<code>object</code>。在严格模式下，<code>null</code> 和 <code>undefined</code> 类型也不能赋给 <code>object</code>。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> object: object;</span><br><span class="line">object = <span class="number">1</span>; <span class="comment">// 报错</span></span><br><span class="line">object = <span class="string">"a"</span>; <span class="comment">// 报错</span></span><br><span class="line">object = <span class="literal">true</span>; <span class="comment">// 报错</span></span><br><span class="line">object = <span class="literal">null</span>; <span class="comment">// 报错</span></span><br><span class="line">object = <span class="literal">undefined</span>; <span class="comment">// 报错</span></span><br><span class="line">object = &#123;&#125;; <span class="comment">// 编译正确</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Object<br>大 <code>Object</code> 代表所有拥有 <code>toString</code>、<code>hasOwnProperty</code> 方法的类型 所以所有原始类型、非原始类型都可以赋给 <code>Object</code>(严格模式下 <code>null</code> 和 <code>undefined</code> 不可以)</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bigObject: <span class="built_in">Object</span>;</span><br><span class="line">bigObject = <span class="number">1</span>; <span class="comment">// 编译正确</span></span><br><span class="line">bigObject = <span class="string">"a"</span>; <span class="comment">// 编译正确</span></span><br><span class="line">bigObject = <span class="literal">true</span>; <span class="comment">// 编译正确</span></span><br><span class="line">bigObject = <span class="literal">null</span>; <span class="comment">// 报错</span></span><br><span class="line">bigObject = <span class="literal">undefined</span>; <span class="comment">// 报错</span></span><br><span class="line">bigObject = &#123;&#125;; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<ul>
<li>{}<br>{} 空对象类型和大 Object 一样 也是表示原始类型和非原始类型的集合</li>
</ul>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>在 TypeScript 中，我们通过 <code>Class</code> 关键字来定义一个类</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  sayHello():<span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi, <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后的代码</span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hi, "</span>.concat(<span class="keyword">this</span>.name));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Person;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr1: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="接口定义函数"><a href="#接口定义函数" class="headerlink" title="接口定义函数"></a>接口定义函数</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Add&#123;</span><br><span class="line">  (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span>, z?: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (z) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + z;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span> = 0</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...numbers: <span class="built_in">number</span>[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    sum += numbers[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p>函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">any</span>, y: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面示例中，我们给同一个函数提供多个函数类型定义，从而实现函数的重载</p>
<blockquote>
<p><strong>函数重载</strong>真正执行的是同名函数<strong><em>最后定义的函数体</em></strong> 在最后一个函数体定义之前全都属于函数类型定义 <strong><em>不能写具体的函数实现方法，只能定义类型</em></strong></p>
</blockquote>
<h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论的规则推断出一个类型。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// 上面的代码等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p>
<p>通过上述示例我们可以看出，我们没有给 x 指定明确类型的时候，typescript 会推断出 x 的类型是 number。<br>而如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// 编译正确</span></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// 编译正确</span></span><br></pre></td></tr></table></figure></p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>某些情况下，我们可能比typescript更加清楚的知道某个变量的类型，所以我们可能希望手动指定一个值的类型<br>类型断言有两种方式:</p>
<ol>
<li><p>尖括号语法</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"my name is zhangsan"</span></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;str).length</span><br><span class="line"><span class="built_in">console</span>.log(strLength)</span><br></pre></td></tr></table></figure>
</li>
<li><p>as语法</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"my name is zhangsan"</span></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (str <span class="keyword">as</span> <span class="built_in">string</span>).length</span><br><span class="line"><span class="built_in">console</span>.log(strLength)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h4><p>在上下文中当类型检查器无法断定类型时，可以使用缀表达式操作符 ! 进行断言操作对象是非 null 和非 undefined 的类型，<strong>即x!的值不会为 null 或 undefined</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user: <span class="built_in">string</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">console</span>.log(user!.toUpperCase()); <span class="comment">// 编译正确</span></span><br><span class="line"><span class="built_in">console</span>.log(user.toUpperCase()); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<h4 id="确定赋值断言"><a href="#确定赋值断言" class="headerlink" title="确定赋值断言"></a>确定赋值断言</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value:<span class="built_in">number</span></span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// Variable 'value' is used before being assigned.</span></span><br></pre></td></tr></table></figure>
<p>我们定义了变量, 没有赋值就使用，则会报错<br>通过 let x!: number; 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value!:<span class="built_in">number</span></span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// undefined 编译正确</span></span><br></pre></td></tr></table></figure>
<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型用<code>|</code>分隔，表示取值可以为多种类型中的一种</p>
<p>可以使用<code>|</code>来连接多个类型（联合类型）<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n:<span class="built_in">string</span>|<span class="built_in">number</span></span><br><span class="line">n = <span class="string">'to be or not to be'</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(n) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名用来给一个类型起个新名字。它只是起了一个新名字，并没有创建新类型。类型别名常用于联合类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> count = <span class="built_in">number</span> | <span class="built_in">number</span>[];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">value: count</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型就是跟联合类型相反，用<code>&amp;</code>操作符表示，交叉类型就是两个类型必须存在<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IpersonA&#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IpersonB &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  gender: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> person: IpersonA &amp; IpersonB = &#123; </span><br><span class="line">    name: <span class="string">"师爷"</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    gender: <span class="string">"男"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>person</code> 即是 <code>IpersonA</code> 类型，又是 <code>IpersonB</code> 类型</p>
<p>注意：交叉类型取的多个类型的并集，但是如果key相同但是类型不同，则该key为 <code>never</code> 类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IpersonA &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> IpersonB &#123;</span><br><span class="line">    name: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAndFn</span>(<span class="params">params: IpersonA &amp; IpersonB</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(params)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">testAndFn(&#123;name: <span class="string">"黄老爷"</span>&#125;) <span class="comment">// error TS2322: Type 'string' is not assignable to type 'never'.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一下代码不会报错，因为取的是并集，没有冲突</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IpersonA &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> IpersonB &#123;</span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAndFn</span>(<span class="params">params: IpersonA &amp; IpersonB</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(params)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">testAndFn(&#123;name: <span class="string">"黄老爷"</span>, age: <span class="number">18</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="类型守卫"><a href="#类型守卫" class="headerlink" title="类型守卫"></a>类型守卫</h3><p><strong>类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内</strong>。 换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数值。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。</p>
<p>换句话说：<strong>类型守卫是运行时检查，确保一个值在所要类型的范围内</strong>。</p>
<p>目前主要有四种的方式来实现类型保护：</p>
<h4 id="·-in-关键字"><a href="#·-in-关键字" class="headerlink" title="· in 关键字"></a>· in 关键字</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> InObj1 &#123;</span><br><span class="line">    a: <span class="built_in">number</span>,</span><br><span class="line">    x: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> InObj2 &#123;</span><br><span class="line">    a: <span class="built_in">number</span>,</span><br><span class="line">    y: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIn</span>(<span class="params">arg: InObj1 | InObj2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// x 在 arg 打印 x</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'x'</span> <span class="keyword">in</span> arg) <span class="built_in">console</span>.log(<span class="string">'x'</span>)</span><br><span class="line">    <span class="comment">// y 在 arg 打印 y</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'y'</span> <span class="keyword">in</span> arg) <span class="built_in">console</span>.log(<span class="string">'y'</span>)</span><br><span class="line">&#125;</span><br><span class="line">isIn(&#123;a:<span class="number">1</span>, x:<span class="string">'xxx'</span>&#125;);</span><br><span class="line">isIn(&#123;a:<span class="number">1</span>, y:<span class="string">'yyy'</span>&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="·-typeof-关键字"><a href="#·-typeof-关键字" class="headerlink" title="· typeof 关键字"></a>· typeof 关键字</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isTypeof</span>(<span class="params"> val: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">string</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">"number"</span>) <span class="keyword">return</span> <span class="string">'number'</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">"string"</span>) <span class="keyword">return</span> <span class="string">'string'</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'啥也不是'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isTypeof(<span class="string">'bool'</span>)) <span class="comment">// string</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>typeof 只支持：typeof ‘x’ === ‘typeName’ 和 typeof ‘x’ !== ‘typeName’，x 必须是 ‘number’, ‘string’, ‘boolean’, ‘symbol’。</p>
</blockquote>
<h4 id="·-instanceof"><a href="#·-instanceof" class="headerlink" title="· instanceof"></a>· instanceof</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatDate</span>(<span class="params">date: <span class="built_in">Date</span> | <span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(date)</span><br><span class="line">    <span class="keyword">if</span>(date <span class="keyword">instanceof</span> <span class="built_in">Date</span>)&#123;</span><br><span class="line">        date.getDate()</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(date)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(creatDate(<span class="string">'2020-01-01'</span>)) <span class="comment">// 2020-01-01T00:00:00.000Z</span></span><br></pre></td></tr></table></figure>
<h4 id="·-自定义类型保护的类型谓词"><a href="#·-自定义类型保护的类型谓词" class="headerlink" title="· 自定义类型保护的类型谓词"></a>· 自定义类型保护的类型谓词</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">num: <span class="built_in">any</span></span>): <span class="title">num</span> <span class="title">is</span> <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> num === <span class="string">'number'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">str: <span class="built_in">any</span></span>): <span class="title">str</span> <span class="title">is</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> str=== <span class="string">'string'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isNumber(<span class="number">1</span>), isString(<span class="number">1</span>)) <span class="comment">// true false</span></span><br><span class="line"><span class="built_in">console</span>.log(isNumber(<span class="string">'1'</span>), isString(<span class="string">'1'</span>)) <span class="comment">// // false true</span></span><br></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>我们使用接口来定义对象的类型。接口是对象的状态(属性)和行为(方法)的抽象(描述)<br>简单理解就是：为我们的代码提供一种约定<br>我们使用关键字 <code>interface</code> 来声明接口</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> song:Person = &#123;</span><br><span class="line">  name: <span class="string">'song'</span>,</span><br><span class="line">  age: <span class="number">32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个接口 Person，接着定义了一个变量 song，它的类型是 Person。这样，我们就约束了 song 的形状必须和接口 Person 一致。</p>
<blockquote>
<p><strong>接口一般首字母大写</strong>。(当然挺多人也习惯 I 大写字母开头，用来表示这是一个接口)</p>
</blockquote>
<h4 id="设置接口可选-只读"><a href="#设置接口可选-只读" class="headerlink" title="设置接口可选|只读"></a>设置接口可选|只读</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> song:Person = &#123;</span><br><span class="line">  name: <span class="string">'song'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// song.name = 'zhang' // 无法为“name”赋值，因为它是只读属性。ts(2540)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>可选属性，我们最常见的使用情况是，不确定这个参数是否会传，或者存在。</p>
</li>
<li><p>只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 ReadonlyArray 类型，它与 Array 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p>
</li>
</ul>
<h4 id="索引签名"><a href="#索引签名" class="headerlink" title="索引签名"></a>索引签名</h4><p>有时候我们希望一个接口中除了包含必选和可选属性之外，还允许有其他的任意属性，这时我们可以使用 索引签名 的形式来满足上述要求。</p>
<p>需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  [prop: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">//  prop字段必须是 string类型 or number类型。 值是any类型，也就是任意的</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> song:Person = &#123;</span><br><span class="line">  name: <span class="string">'song'</span></span><br><span class="line">&#125;</span><br><span class="line">song.sex = <span class="string">'男'</span></span><br><span class="line"><span class="comment">// song[true] = true // 类型“true”不能作为索引类型使用。ts(2538)</span></span><br><span class="line">song[<span class="number">1</span>] = <span class="literal">false</span></span><br><span class="line"><span class="built_in">console</span>.log(song) <span class="comment">// &#123; '1': false, name: 'song', sex: '男', flag: true &#125;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="接口与类型别名的区别"><a href="#接口与类型别名的区别" class="headerlink" title="接口与类型别名的区别"></a>接口与类型别名的区别</h4><p>实际上，在大多数的情况下使用接口类型和类型别名的效果等价，但是在某些特定的场景下这两者还是存在很大区别。</p>
<blockquote>
<p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 而接口的作用就是为这些类型命名和为你的代码或第三方代码定义数据模型。</p>
</blockquote>
<blockquote>
<p>type(类型别名)会给一个类型起个新名字。 type 有时和 interface 很像，但是可以作用于原始值（基本类型），联合类型，元组以及其它任何你需要手写的类型。起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型。给基本类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</p>
</blockquote>
<ul>
<li>接口和类型别名都可以用来描述对象或函数的类型，只是语法不同</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyType = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  say(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> MyInterface &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  say(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMyType</span>(<span class="params">obj: MyType</span>): <span class="title">MyType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMyInterface</span>(<span class="params">obj: MyInterface</span>): <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getMyType(&#123; name: <span class="string">'song'</span>, say: <span class="function"><span class="params">()</span> =&gt;</span> &#123; &#125; &#125;)</span><br><span class="line">getMyInterface(&#123; name: <span class="string">'song'</span>, say: <span class="function"><span class="params">()</span> =&gt;</span> &#123; &#125; &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>都允许扩展</li>
</ul>
<ol>
<li><p>interface 用 extends 来实现扩展</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MyInterface &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  say(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> MyInterface2 <span class="keyword">extends</span> MyInterface &#123;</span><br><span class="line">  sex: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> person:MyInterface2 = &#123;</span><br><span class="line">  name:<span class="string">'树哥'</span>,</span><br><span class="line">  sex:<span class="string">'男'</span>,</span><br><span class="line">  say(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello 啊，树哥！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>type 使用 &amp; 实现扩展</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyType = &#123;</span><br><span class="line">  name:<span class="built_in">string</span>;</span><br><span class="line">  say(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyType2 = MyType &amp; &#123;</span><br><span class="line">  sex:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> value: MyType2 = &#123;</span><br><span class="line">  name:<span class="string">'树哥'</span>,</span><br><span class="line">  sex:<span class="string">'男'</span>,</span><br><span class="line">  say(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello 啊，树哥！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li><p>interface能够合并声明，而type不行</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时Person同时具有name和age属性</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>type可以声明基本数据类型别名/联合类型/元组等，而interface不行</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型别名</span></span><br><span class="line"><span class="keyword">type</span> UserName = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> UserName = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">type</span> Animal = Pig | Dog | Cat;</span><br><span class="line"><span class="keyword">type</span> List = [<span class="built_in">string</span>, <span class="built_in">boolean</span>, <span class="built_in">number</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>
<p>举个例子，比如我们现在有个这样的需求，我们要实现一个这样的函数，函数的参数可以是任何值，返回值就是将参数原样返回，并且参数的类型是 string，函数返回类型就为 string？</p>
<p>你很容易写下：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">arg:<span class="built_in">string</span></span>):<span class="title">string</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在需求有变，需要返回一个 <code>number</code> 类型的值，你会说，联合类型就完事了：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">arg:<span class="built_in">string</span> | <span class="built_in">number</span></span>):<span class="title">string</span> | <span class="title">number</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这样又有一个问题，就是如果我们需要返回一个 boolean 类型，string 数组甚至任意类型呢，难道有多少个就写多少个联合类型？</p>
<p>是的，我们直接用 <code>any</code> 就行了！<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">arg:<span class="built_in">any</span></span>):<span class="title">any</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽管 any 大法好，很多时候 any 也确实能够解决不少问题，但是这样也不符合我们的需求了，传入和返回都是 any 类型，<strong>传入和返回并没有统一</strong>。</p>
<p><strong><em>这个时候就要祭出我们的泛型了</em></strong>。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性</p>
<p>上面的需求，我们如果用泛型来解决的话：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>泛型的语法是尖括号 &lt;&gt; 里面写类型参数，一般用 T 来表示第一个类型变量名称，其实它可以用任何有效名称来代替,比如我们用NIUBI也是编译正常的</p>
<blockquote>
<p>泛型就像一个占位符一个变量，在使用的时候我们可以将定义好的类型像参数一样传入，原封不动的输出。</p>
</blockquote>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>我们有两种方式来使用：</p>
<ul>
<li><p>定义要使用的类型，比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getValue&lt;<span class="built_in">string</span>&gt;(<span class="string">'树哥'</span>); <span class="comment">// 定义 T 为 string 类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 typescript 的类型推断，比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getValue(<span class="string">'树哥'</span>) <span class="comment">// 自动推导类型为 string</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h4><p>其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 U<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">arg:[T,U]</span>):[<span class="title">T</span>,<span class="title">U</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> str = getValue([<span class="string">'树哥'</span>, <span class="number">18</span>]);</span><br></pre></td></tr></table></figure></p>
<p>ts 自动识别以上代码为:</p>
<blockquote>
<p>function getValue&lt;string, number&gt;(arg: [string, number]): [string, number]<br><strong>typescript 给我们自动推断出输入、返回的类型</strong></p>
</blockquote>
<h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><p>因为泛型 T 不一定包含属性 length，那么我想 getLength 这个函数只允许传入包含 length 属性的变量，该怎么做呢</p>
<p>这时，我们可以使用 <code>extends</code> 关键字来对泛型进行约束<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span>  </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length); </span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = getLength(<span class="string">'树哥'</span>)</span><br><span class="line"><span class="keyword">const</span> arr = getLength([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="keyword">const</span> obj = getLength(&#123; length: <span class="number">5</span> &#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里可以看出，不管你是 str，arr 还是obj，只要具有 length 属性，都可以</p>
</blockquote>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> KeyValue&lt;T,U&gt; &#123;</span><br><span class="line">  key: T;</span><br><span class="line">  value: U;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> person1:KeyValue&lt;<span class="built_in">string</span>,<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  key: <span class="string">'树哥'</span>,</span><br><span class="line">  value: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person2:KeyValue&lt;<span class="built_in">number</span>,<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  key: <span class="number">20</span>,</span><br><span class="line">  value: <span class="string">'张麻子'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Test&lt;T&gt; &#123;</span><br><span class="line">  value: T;</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> myTest = <span class="keyword">new</span> Test&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myTest.value = <span class="number">0</span>;</span><br><span class="line">myTest.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="泛型类型别名"><a href="#泛型类型别名" class="headerlink" title="泛型类型别名"></a>泛型类型别名</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cart&lt;T&gt; = &#123; list: T[] &#125; | T[];</span><br><span class="line"><span class="keyword">let</span> c1: Cart&lt;<span class="built_in">string</span>&gt; = &#123; list: [<span class="string">"1"</span>] &#125;;</span><br><span class="line"><span class="keyword">let</span> c2: Cart&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h4 id="泛型参数的默认类型"><a href="#泛型参数的默认类型" class="headerlink" title="泛型参数的默认类型"></a>泛型参数的默认类型</h4><p>我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。有点 js 里函数默认参数的意思。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span> = <span class="title">string</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result: T[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h4><ul>
<li>typeof</li>
</ul>
<p>关键词除了做类型保护，还可以从实现推出类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先定义变量，再定义类型</span></span><br><span class="line"><span class="keyword">let</span> p1 = &#123;</span><br><span class="line">  name: <span class="string">"树哥"</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  gender: <span class="string">"male"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> People = <span class="keyword">typeof</span> p1;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">p: People</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p.name;</span><br><span class="line">&#125;</span><br><span class="line">getName(p1);</span><br></pre></td></tr></table></figure>
<ul>
<li>keyof</li>
</ul>
<p>可以用来获取一个对象接口中的所有 key 值</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender: <span class="string">"male"</span> | <span class="string">"female"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> PersonKey = keyof Person; <span class="comment">//type PersonKey = 'name'|'age'|'gender';</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValueByKey</span>(<span class="params">p: Person, key: PersonKey</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> val = getValueByKey(&#123; name: <span class="string">"树哥"</span>, age: <span class="number">18</span>, gender: <span class="string">"male"</span> &#125;, <span class="string">"name"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(val); <span class="comment">// 树哥</span></span><br></pre></td></tr></table></figure>
<ul>
<li>in</li>
</ul>
<p>用来遍历枚举类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Keys = <span class="string">"a"</span> | <span class="string">"b"</span> | <span class="string">"c"</span></span><br><span class="line"><span class="keyword">type</span> Obj =  &#123;</span><br><span class="line">  [p <span class="keyword">in</span> Keys]: <span class="built_in">any</span></span><br><span class="line">&#125; <span class="comment">// -&gt; &#123; a: any, b: any, c: any &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj: Obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="string">'3'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> keys: Keys[] = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>infer</li>
</ul>
<p>在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...args: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>extends</li>
</ul>
<p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 <code>extends</code> 关键字添加泛型约束。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(<span class="number">3</span>);  <span class="comment">// Error, number doesn't have a .length property</span></span><br></pre></td></tr></table></figure></p>
<p>当我们传入合法的类型的值，即包含 length 属性的值时：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(&#123;length: <span class="number">10</span>, name: <span class="string">'张麻子'</span>&#125;); <span class="comment">// 编译正确</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>索引访问操作符</li>
</ul>
<p>使用 [] 操作符可以进行索引访问：<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> x = Person[<span class="string">"name"</span>]; <span class="comment">// x is string</span></span><br></pre></td></tr></table></figure></p>
<h4 id="内置工具类型"><a href="#内置工具类型" class="headerlink" title="内置工具类型"></a>内置工具类型</h4><ul>
<li>Required</li>
</ul>
<p>将类型的属性变成必选</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name?: <span class="built_in">string</span>,</span><br><span class="line">    age?: <span class="built_in">number</span>,</span><br><span class="line">    hobby?: <span class="built_in">string</span>[]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> user: Required&lt;Person&gt; = &#123;</span><br><span class="line">    name: <span class="string">"树哥"</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    hobby: [<span class="string">"code"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Partial</li>
</ul>
<p>与 Required 相反，将所有属性转换为可选属性<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line">    age: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> shuge:Person = &#123;</span><br><span class="line">  name:<span class="string">'树哥'</span></span><br><span class="line">&#125; <span class="comment">// error  Property 'age' is missing in type '&#123; name: string; &#125;' but required in type 'Person'.</span></span><br></pre></td></tr></table></figure></p>
<p>从上面知道，如果必传而我们少穿传了的话，就会报错</p>
<p>我们使用 <code>Partial</code> 将其变为可选</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User = Partial&lt;Person&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> shuge: User=&#123;</span><br><span class="line">  name:<span class="string">'树哥'</span></span><br><span class="line">&#125; <span class="comment">// 编译正确</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Exclude</li>
</ul>
<p>Exclude&lt;T, U&gt; 的作用是将某个类型中属于另一个的类型移除掉,剩余的属性构成新的类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T0 = Exclude&lt;<span class="string">"a"</span> | <span class="string">"b"</span> | <span class="string">"c"</span>, <span class="string">"a"</span>&gt;; <span class="comment">// "b" | "c"</span></span><br><span class="line"><span class="keyword">type</span> T1 = Exclude&lt;<span class="string">"a"</span> | <span class="string">"b"</span> | <span class="string">"c"</span>, <span class="string">"a"</span> | <span class="string">"b"</span>&gt;; <span class="comment">// "c"</span></span><br><span class="line"><span class="keyword">type</span> T2 = Exclude&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="function">(<span class="params">(<span class="params"></span>) =&gt; <span class="built_in">void</span></span>), <span class="params">Function</span>&gt;; // <span class="params">string</span> | <span class="params">number</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>Extract</li>
</ul>
<p>和 Exclude 相反，Extract&lt;T,U&gt; 从 T 中提取出 U。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T0 = Extract&lt;<span class="string">"a"</span> | <span class="string">"b"</span> | <span class="string">"c"</span>, <span class="string">"a"</span> | <span class="string">"f"</span>&gt;; <span class="comment">// "a"</span></span><br><span class="line"><span class="keyword">type</span> T1 = Extract&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="function">(<span class="params">(<span class="params"></span>) =&gt; <span class="built_in">void</span></span>), <span class="params">Function</span>&gt;; // <span class="params">()</span> =&gt;</span><span class="built_in">void</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Readonly</li>
</ul>
<p>把数组或对象的所有属性值转换为只读的，这就意味着这些属性不能被重新赋值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  gender?: <span class="string">"male"</span> | <span class="string">"female"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> p: Readonly&lt;Person&gt; = &#123;</span><br><span class="line">  name: <span class="string">"hello"</span>,</span><br><span class="line">  age: <span class="number">10</span>,</span><br><span class="line">  gender: <span class="string">"male"</span>,</span><br><span class="line">&#125;;</span><br><span class="line">p.age = <span class="number">11</span>; <span class="comment">// error  Cannot assign to 'age' because it is a read-only property.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Record</li>
</ul>
<p><code>Record&lt;K extends keyof any, T&gt;</code>的作用是将 K 中所有的属性的值转化为 T 类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Property = <span class="string">'key1'</span>|<span class="string">'key2'</span></span><br><span class="line"><span class="keyword">type</span> Person = Record&lt;Property, <span class="built_in">string</span>&gt;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> p: Person = &#123;</span><br><span class="line">  key1: <span class="string">"hello 啊"</span>,</span><br><span class="line">  key2: <span class="string">"树哥"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>Pick</li>
</ul>
<p>从某个类型中挑出一些属性出来</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age:<span class="built_in">number</span>;</span><br><span class="line">  gender:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> P1 = Pick&lt;Person, <span class="string">"name"</span> | <span class="string">"age"</span>&gt;; <span class="comment">// &#123; name: string; age: number; &#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> user:P1=&#123;</span><br><span class="line">  name:<span class="string">'树哥'</span>,</span><br><span class="line">  age:<span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Omit</li>
</ul>
<p>与Pick相反，Omit&lt;T,K&gt; 从T中取出除去K的其他所有属性</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span>,</span><br><span class="line">  gender: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> P1 = Omit&lt;Person, <span class="string">"age"</span> | <span class="string">"gender"</span>&gt;</span><br><span class="line"><span class="keyword">const</span> user:P1  = &#123;</span><br><span class="line">  name: <span class="string">'树哥'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>NonNullable</li>
</ul>
<p>去除类型中的 null 和 undefined</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> P1 = NonNullable&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span>&gt;; <span class="comment">// string | number</span></span><br><span class="line"><span class="keyword">type</span> P2 = NonNullable&lt;<span class="built_in">string</span>[] | <span class="literal">null</span> | <span class="literal">undefined</span>&gt;; <span class="comment">// string[]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ReturnType</li>
</ul>
<p>用来得到一个函数的返回值类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Func = <span class="function">(<span class="params">value: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">const</span> test: ReturnType&lt;Func&gt; = <span class="string">"1"</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>Parameters</li>
</ul>
<p>用于获得函数的参数类型所组成的元组类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> P1 = Parameters&lt;<span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt;; <span class="comment">// [number, string]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>InstanceType</li>
</ul>
<p>返回构造函数类型T的实例类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> D = InstanceType&lt;<span class="keyword">typeof</span> C&gt;;  <span class="comment">// C</span></span><br></pre></td></tr></table></figure>
<h3 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h3><p>在文章开头环境安装部分，记得我们有生成一个 tsconfig.json 文件，那么这个文件究竟有什么用呢</p>
<p>tsconfig.json 是 TypeScript 项目的配置文件。</p>
<p>tsconfig.json 包含 TypeScript 编译的相关配置，通过更改编译配置项，我们可以让 TypeScript 编译出 ES6、ES5、node 的代码。</p>
<h4 id="重要字段"><a href="#重要字段" class="headerlink" title="重要字段"></a>重要字段</h4><ul>
<li>files - 设置要编译的文件的名称；</li>
<li>include - 设置需要进行编译的文件，支持路径模式匹配；</li>
<li>exclude - 设置无需进行编译的文件，支持路径模式匹配；</li>
<li>compilerOptions - 设置与编译流程相关的选项。</li>
</ul>
<h4 id="compilerOptions-选项"><a href="#compilerOptions-选项" class="headerlink" title="compilerOptions 选项"></a>compilerOptions 选项</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 基本选项 */</span></span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"es5"</span>,                       <span class="comment">// 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'</span></span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"commonjs"</span>,                  <span class="comment">// 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'</span></span><br><span class="line">    <span class="string">"lib"</span>: [],                             <span class="comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="string">"allowJs"</span>: <span class="literal">true</span>,                       <span class="comment">// 允许编译 javascript 文件</span></span><br><span class="line">    <span class="string">"checkJs"</span>: <span class="literal">true</span>,                       <span class="comment">// 报告 javascript 文件中的错误</span></span><br><span class="line">    <span class="string">"jsx"</span>: <span class="string">"preserve"</span>,                     <span class="comment">// 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'</span></span><br><span class="line">    <span class="string">"declaration"</span>: <span class="literal">true</span>,                   <span class="comment">// 生成相应的 '.d.ts' 文件</span></span><br><span class="line">    <span class="string">"sourceMap"</span>: <span class="literal">true</span>,                     <span class="comment">// 生成相应的 '.map' 文件</span></span><br><span class="line">    <span class="string">"outFile"</span>: <span class="string">"./"</span>,                       <span class="comment">// 将输出文件合并为一个文件</span></span><br><span class="line">    <span class="string">"outDir"</span>: <span class="string">"./"</span>,                        <span class="comment">// 指定输出目录</span></span><br><span class="line">    <span class="string">"rootDir"</span>: <span class="string">"./"</span>,                       <span class="comment">// 用来控制输出目录结构 --outDir.</span></span><br><span class="line">    <span class="string">"removeComments"</span>: <span class="literal">true</span>,                <span class="comment">// 删除编译后的所有的注释</span></span><br><span class="line">    <span class="string">"noEmit"</span>: <span class="literal">true</span>,                        <span class="comment">// 不生成输出文件</span></span><br><span class="line">    <span class="string">"importHelpers"</span>: <span class="literal">true</span>,                 <span class="comment">// 从 tslib 导入辅助工具函数</span></span><br><span class="line">    <span class="string">"isolatedModules"</span>: <span class="literal">true</span>,               <span class="comment">// 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 严格的类型检查选项 */</span></span><br><span class="line">    <span class="string">"strict"</span>: <span class="literal">true</span>,                        <span class="comment">// 启用所有严格类型检查选项</span></span><br><span class="line">    <span class="string">"noImplicitAny"</span>: <span class="literal">true</span>,                 <span class="comment">// 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class="line">    <span class="string">"strictNullChecks"</span>: <span class="literal">true</span>,              <span class="comment">// 启用严格的 null 检查</span></span><br><span class="line">    <span class="string">"noImplicitThis"</span>: <span class="literal">true</span>,                <span class="comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span></span><br><span class="line">    <span class="string">"alwaysStrict"</span>: <span class="literal">true</span>,                  <span class="comment">// 以严格模式检查每个模块，并在每个文件里加入 'use strict'</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 额外的检查 */</span></span><br><span class="line">    <span class="string">"noUnusedLocals"</span>: <span class="literal">true</span>,                <span class="comment">// 有未使用的变量时，抛出错误</span></span><br><span class="line">    <span class="string">"noUnusedParameters"</span>: <span class="literal">true</span>,            <span class="comment">// 有未使用的参数时，抛出错误</span></span><br><span class="line">    <span class="string">"noImplicitReturns"</span>: <span class="literal">true</span>,             <span class="comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span></span><br><span class="line">    <span class="string">"noFallthroughCasesInSwitch"</span>: <span class="literal">true</span>,    <span class="comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 模块解析选项 */</span></span><br><span class="line">    <span class="string">"moduleResolution"</span>: <span class="string">"node"</span>,            <span class="comment">// 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)</span></span><br><span class="line">    <span class="string">"baseUrl"</span>: <span class="string">"./"</span>,                       <span class="comment">// 用于解析非相对模块名称的基目录</span></span><br><span class="line">    <span class="string">"paths"</span>: &#123;&#125;,                           <span class="comment">// 模块名到基于 baseUrl 的路径映射的列表</span></span><br><span class="line">    <span class="string">"rootDirs"</span>: [],                        <span class="comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span></span><br><span class="line">    <span class="string">"typeRoots"</span>: [],                       <span class="comment">// 包含类型声明的文件列表</span></span><br><span class="line">    <span class="string">"types"</span>: [],                           <span class="comment">// 需要包含的类型声明文件名列表</span></span><br><span class="line">    <span class="string">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span>,  <span class="comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="string">"sourceRoot"</span>: <span class="string">"./"</span>,                    <span class="comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span></span><br><span class="line">    <span class="string">"mapRoot"</span>: <span class="string">"./"</span>,                       <span class="comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span></span><br><span class="line">    <span class="string">"inlineSourceMap"</span>: <span class="literal">true</span>,               <span class="comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span></span><br><span class="line">    <span class="string">"inlineSources"</span>: <span class="literal">true</span>,                 <span class="comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 其他选项 */</span></span><br><span class="line">    <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span>,        <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="string">"emitDecoratorMetadata"</span>: <span class="literal">true</span>          <span class="comment">// 为装饰器提供元数据的支持</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ts构造函数</span></span><br><span class="line"><span class="keyword">class</span> Dog &#123;</span><br><span class="line">    <span class="comment">//ts规范 属性的类型 </span></span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">//构造函数 什么时候调用 创建实例的时候调用</span></span><br><span class="line">    <span class="comment">//可以通过this在新建的对象中添加属性</span></span><br><span class="line">    <span class="comment">//this.name = "旺财"</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name1: <span class="built_in">string</span>, age1: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name1;</span><br><span class="line">        <span class="keyword">this</span>.age = age1;</span><br><span class="line">    &#125;</span><br><span class="line">    bark() &#123;</span><br><span class="line">        alert(<span class="string">"汪汪汪～～～～"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">'小黑'</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"🚀 ~ file: 01-构造函数.ts ~ line 33 ~ dog"</span>, dog)</span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="keyword">new</span> Dog(<span class="string">'小白'</span>, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"🚀 ~ file: 01-构造函数.ts ~ line 35 ~ dog1"</span>, dog1)</span><br><span class="line"> </span><br><span class="line">dog.bark();</span><br><span class="line">dog1.bark();</span><br></pre></td></tr></table></figure>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>设置一个父级class用来继承</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">class</span> Animal &#123;</span><br><span class="line">        <span class="comment">//ts规范 属性的类型 </span></span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        age: <span class="built_in">number</span>;</span><br><span class="line">        <span class="comment">//构造函数 什么时候调用 创建实例的时候调用</span></span><br><span class="line">        <span class="comment">//可以通过this在新建的对象中添加属性</span></span><br><span class="line">        <span class="comment">//this.name = "旺财"</span></span><br><span class="line">        <span class="keyword">constructor</span>(<span class="params">name1: <span class="built_in">string</span>, age1: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name1;</span><br><span class="line">            <span class="keyword">this</span>.age = age1;</span><br><span class="line">        &#125;</span><br><span class="line">        bark() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"汪汪汪～～～～"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Dog extends Animal </span></span><br><span class="line"><span class="comment">      - Animal 父类</span></span><br><span class="line"><span class="comment">      - Dog被称为子类</span></span><br><span class="line"><span class="comment">      - 使用继承后 子类拥有父类所有的属性和方法</span></span><br><span class="line"><span class="comment">      - 如果子类和父类有同名的方法 则会覆盖父类的方法  叫做方法重写</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">        bark() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'喵喵喵～～～～'</span>);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">'大黄'</span>, <span class="number">8</span>)</span><br><span class="line">    dog.bark()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"🚀 ~ file: 02-继承.ts ~ line 24 ~ dog"</span>, dog)</span><br><span class="line">    <span class="keyword">const</span> cat = <span class="keyword">new</span> Cat(<span class="string">'布丁'</span>, <span class="number">1</span>)</span><br><span class="line">    cat.bark()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"🚀 ~ file: 02-继承.ts ~ line 42 ~ cat"</span>, cat)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>当子类需要添加需求时，用super把父组件的数据继承过来，不然容易造成覆盖</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">class</span> Animal &#123;</span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        sayHello() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"动物在叫～～～"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">        age: <span class="built_in">number</span>;</span><br><span class="line">        <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name)<span class="comment">//父类 </span></span><br><span class="line">            <span class="keyword">this</span>.age = age</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1:重写</span></span><br><span class="line">        <span class="comment">// sayHello(): void &#123;</span></span><br><span class="line">        <span class="comment">//     console.log('汪汪汪～～')</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// super调用</span></span><br><span class="line">        sayHello(): <span class="built_in">void</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.sayHello()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">'旺财'</span>, <span class="number">3</span>)</span><br><span class="line">    dog.sayHello();</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>abstract：</p>
<p>以abstract开头的类是抽象类， 抽象类和其他类区别不大，只是不能用来创建对象，抽象类就是专门用来被继承的类， 抽象类中可以添加抽象方法（但有一个坑就是ts他只会提醒你，还是会被浏览器识别的，我们用ts就是为了规范代码，添加这个数据可以提醒你这个类是父类，不能修改使用的）</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">*   以abstract开头的类是抽象类，</span></span><br><span class="line"><span class="comment">*       抽象类和其他类区别不大，只是不能用来创建对象</span></span><br><span class="line"><span class="comment">*       抽象类就是专门用来被继承的类</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*       抽象类中可以添加抽象方法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">        name: <span class="built_in">string</span>;</span><br><span class="line">        <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义一个抽象方法</span></span><br><span class="line">        <span class="comment">// 抽象方法使用 abstract开头，没有方法体</span></span><br><span class="line">        <span class="comment">// 抽象方法只能定义在抽象类中，子类必须对抽象方法进行重写</span></span><br><span class="line">        <span class="keyword">abstract</span> sayHello(): <span class="built_in">void</span></span><br><span class="line">        eat() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"吃小孩～～～～"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">        sayHello(): <span class="built_in">void</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'汪汪汪汪！'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">        sayHello(): <span class="built_in">void</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'喵喵喵喵！'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">'旺财'</span>)</span><br><span class="line">    <span class="keyword">const</span> cat = <span class="keyword">new</span> Cat(<span class="string">'布丁'</span>)</span><br><span class="line">    dog.sayHello();</span><br><span class="line"> </span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

        
    </section>
</article>





<div class="comments">
    <div id="comments"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
    new Gitalk({
        clientID: "7fbe80427f54741e289f",
        clientSecret: "f34ed5fd92e54c9000bd37ba951948cb939deff5",
        repo: "sanonz.github.io",
        owner: "sanonz",
        admin: ["sanonz"],
        id: "2023/10/04/typescript",
        distractionFreeMode: true,
        title: "TypeScript 深入浅出",
        body: "http://www.shuy.cc/2023/10/04/typescript/",
        labels: ["TypeScript js"]
    }).render('comments');
    </script>
</div>


        </div>
        <footer class="footer" style="color: #fff">
    <a href="https://beian.miit.gov.cn/" style="color: #fff" target="_blank">晋ICP备2024043727号-3</a>
</footer>

    </main>

    <script type="text/javascript" src="https://unpkg.com/jquery@1.9.1/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }

            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle('normal', slideDone);
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp('normal', slideDone);
            }, 3000);
        }

        function slideDone() {
            if (nodes.navInner.css('display') !== 'none') {
                nodes.navInner.css('display', '');
            }
        }

        $(window).on('resize', function() {
            console.log($(this).width())
            if ($(this).width() > 960) {
                nodes.navInner.css('display', '');
            }
        });
    });
    </script>
    
        <script src="/js/scrollspy.min.js"></script>
        <script type="text/javascript">
        $(document.body).scrollspy({target: '#aside-inner'});

        $(window).on('resize', function() {
            var hw = $('#header').width();
            var ww = $('#wrapper').width();
            var space = ($(this).width() - hw - ww) / 2 / 2;

            var pageprev = $('#pageprev');
            var pagenext = $('#pagenext');
            var avg = (pageprev.width() + pagenext.width()) / 2

            if(space > avg) {
                var len = space - avg / 2;
                // var styles = {position: 'fixed', top: '50%', marginTop: - (pageprev.width() + pagenext.width()) / 4}
                // pageprev.css($.extend({left: hw + len}, styles));
                // pagenext.css($.extend({right: len}, styles));
            } else {
                pageprev.removeAttr('style');
                // pagenext.removeAttr('style');
            }
        }).trigger('resize');
        </script>
    

</body>
</html>
