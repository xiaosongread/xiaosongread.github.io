<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">

    

    

    <title>vue3 相关存档 | 前端技术博客</title>
    <meta name="author" content="xiaosongread">
    <meta name="keywords" content="小宋 抿圪斗前端 前端 前端博客 框架 工程 css html js node markdown npm webpack">
    <meta name="description" content="你以为的你已经很了解了，每次读官方文档，都会发现有不一样的感悟，让你眼前一亮的感觉。vue3Vue (发音为 /vjuː/，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。提供了 选项式 API 和 组合式 API 两种编程模型响应式基础ref()在组合式 API 中，推荐使...">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="前端技术博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <style type="text/css">
    @font-face {
        font-family: 'icomoon';
        src: url("/fonts/icomoon.eot?q628ml");
        src: url("/fonts/icomoon.eot?q628ml#iefix") format('embedded-opentype'),
             url("/fonts/icomoon.ttf?q628ml") format('truetype'),
             url("/fonts/icomoon.woff?q628ml") format('woff'),
             url("/fonts/icomoon.svg?q628ml#icomoon") format('svg');
        font-weight: normal;
        font-style: normal;
    }
    </style>
    <link rel="stylesheet" href="/css/style.css">

    <!--[if lt IE 9]><style type="text/css">.nav-inner {top:0;}.author-meta {position:static;top:0;}.search-form {height:36px;}</style><script type="text/javascript" src="https://unpkg.com/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
</head>
<body>

    <main class="app">
        <header id="header" class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">前端技术博客</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">列表</span>
            </a>
        
            <a class="nav-item" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/categories/css-end/">
                <span class="nav-text">css</span>
            </a>
        
            <a class="nav-item" href="/categories/js-end/">
                <span class="nav-text">js</span>
            </a>
        
            <a class="nav-item" href="/categories/gc-end/">
                <span class="nav-text">工程</span>
            </a>
        
            <a class="nav-item" href="/categories/sh-end/">
                <span class="nav-text">日常</span>
            </a>
        
            <a class="nav-item" href="/categories/my-end/">
                <span class="nav-text">关于我</span>
            </a>
        
    </nav>
</div>

    
<aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">

        
        
        
        

        
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue3"><span class="toc-number">1.</span> <span class="toc-text">vue3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#响应式基础"><span class="toc-number">1.1.</span> <span class="toc-text">响应式基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ref"><span class="toc-number">1.1.1.</span> <span class="toc-text">ref()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reactive"><span class="toc-number">1.1.2.</span> <span class="toc-text">reactive()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ref-和-reactive-的区别"><span class="toc-number">1.1.3.</span> <span class="toc-text">ref 和 reactive 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计算属性"><span class="toc-number">1.2.</span> <span class="toc-text">计算属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#计算属性缓存-vs-方法"><span class="toc-number">1.2.1.</span> <span class="toc-text">计算属性缓存 vs 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可写计算属性"><span class="toc-number">1.2.2.</span> <span class="toc-text">可写计算属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取上一个值-仅-3-4-支持"><span class="toc-number">1.2.3.</span> <span class="toc-text">获取上一个值(仅 3.4+ 支持)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-与-Style-绑定"><span class="toc-number">1.3.</span> <span class="toc-text">Class 与 Style 绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#class-绑定"><span class="toc-number">1.3.1.</span> <span class="toc-text">class 绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-绑定对象"><span class="toc-number">1.3.2.</span> <span class="toc-text">1. 绑定对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-绑定数组"><span class="toc-number">1.3.3.</span> <span class="toc-text">2. 绑定数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#style-绑定"><span class="toc-number">1.3.4.</span> <span class="toc-text">style 绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-绑定对象-1"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">1. 绑定对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-绑定数组-1"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">2. 绑定数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件渲染"><span class="toc-number">1.4.</span> <span class="toc-text">条件渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#v-if"><span class="toc-number">1.4.1.</span> <span class="toc-text">v-if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-else"><span class="toc-number">1.4.2.</span> <span class="toc-text">v-else</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-else-if"><span class="toc-number">1.4.3.</span> <span class="toc-text">v-else-if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lt-template-gt-上的-v-if"><span class="toc-number">1.4.4.</span> <span class="toc-text">&lt;template&gt; 上的 v-if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-show"><span class="toc-number">1.4.5.</span> <span class="toc-text">v-show</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-if-vs-v-show​"><span class="toc-number">1.4.6.</span> <span class="toc-text">v-if vs v-show​</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-if-和-v-for-优先级和V2-有区别"><span class="toc-number">1.4.7.</span> <span class="toc-text">v-if 和 v-for(优先级和V2 有区别)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#侦听器-watch"><span class="toc-number">1.5.</span> <span class="toc-text">侦听器 - watch()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据源类型"><span class="toc-number">1.5.1.</span> <span class="toc-text">数据源类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#深层侦听器-deep-3-5-及以上版本"><span class="toc-number">1.5.2.</span> <span class="toc-text">深层侦听器 - deep (3.5 及以上版本)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#即时回调的侦听器​-immediate"><span class="toc-number">1.5.3.</span> <span class="toc-text">即时回调的侦听器​ - immediate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一次性侦听器-once-3-4-及以上版本"><span class="toc-number">1.5.4.</span> <span class="toc-text">一次性侦听器 - once (3.4 及以上版本)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#watchEffect"><span class="toc-number">1.5.5.</span> <span class="toc-text">watchEffect()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#watch-vs-watchEffect"><span class="toc-number">1.5.6.</span> <span class="toc-text">watch vs watchEffect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#副作用清理"><span class="toc-number">1.5.7.</span> <span class="toc-text">副作用清理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板引用"><span class="toc-number">1.6.</span> <span class="toc-text">模板引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#访问模板引用"><span class="toc-number">1.6.1.</span> <span class="toc-text">访问模板引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组件上的-ref"><span class="toc-number">1.6.2.</span> <span class="toc-text">组件上的 ref</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生命周期"><span class="toc-number">1.7.</span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#生命周期钩子函数"><span class="toc-number">1.7.1.</span> <span class="toc-text">生命周期钩子函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#props"><span class="toc-number">1.8.</span> <span class="toc-text">props</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#defineProps"><span class="toc-number">1.8.1.</span> <span class="toc-text">defineProps()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件"><span class="toc-number">1.9.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#触发与监听事件"><span class="toc-number">1.9.1.</span> <span class="toc-text">触发与监听事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件参数"><span class="toc-number">1.9.2.</span> <span class="toc-text">事件参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#声明触发的事件-defineEmits"><span class="toc-number">1.9.3.</span> <span class="toc-text">声明触发的事件 - defineEmits()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件校验"><span class="toc-number">1.9.4.</span> <span class="toc-text">事件校验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组件-v-model-defineModel"><span class="toc-number">1.10.</span> <span class="toc-text">组件 v-model - defineModel()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#底层机制"><span class="toc-number">1.10.1.</span> <span class="toc-text">底层机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-model-的参数"><span class="toc-number">1.10.2.</span> <span class="toc-text">v-model 的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多个-v-model-绑定"><span class="toc-number">1.10.3.</span> <span class="toc-text">多个 v-model 绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理-v-model-修饰符"><span class="toc-number">1.10.4.</span> <span class="toc-text">处理 v-model 修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#带参数的-v-model-修饰符​"><span class="toc-number">1.10.5.</span> <span class="toc-text">带参数的 v-model 修饰符​</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#透传-Attributes"><span class="toc-number">1.11.</span> <span class="toc-text">透传 Attributes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#对-class-和-style-的合并"><span class="toc-number">1.11.1.</span> <span class="toc-text">对 class 和 style 的合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#v-on-监听器继承"><span class="toc-number">1.11.2.</span> <span class="toc-text">v-on 监听器继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#深层组件继承"><span class="toc-number">1.11.3.</span> <span class="toc-text">深层组件继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#禁用-Attributes-继承"><span class="toc-number">1.11.4.</span> <span class="toc-text">禁用 Attributes 继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多个根节点的-Attributes-继承"><span class="toc-number">1.11.5.</span> <span class="toc-text">多个根节点的 Attributes 继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在-JavaScript-中访问透传-Attributes-useAttrs"><span class="toc-number">1.11.6.</span> <span class="toc-text">在 JavaScript 中访问透传 Attributes - useAttrs()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插槽-Slots"><span class="toc-number">1.12.</span> <span class="toc-text">插槽 Slots</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#具名插槽"><span class="toc-number">1.12.1.</span> <span class="toc-text">具名插槽</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#条件插槽"><span class="toc-number">1.12.2.</span> <span class="toc-text">条件插槽</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态插槽名"><span class="toc-number">1.12.3.</span> <span class="toc-text">动态插槽名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#作用域插槽"><span class="toc-number">1.12.4.</span> <span class="toc-text">作用域插槽</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#具名作用域插槽"><span class="toc-number">1.12.5.</span> <span class="toc-text">具名作用域插槽</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高级列表组件示例"><span class="toc-number">1.12.6.</span> <span class="toc-text">高级列表组件示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无渲染组件"><span class="toc-number">1.12.7.</span> <span class="toc-text">无渲染组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖注入"><span class="toc-number">1.13.</span> <span class="toc-text">依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Prop-逐级透传问题-provide-inject"><span class="toc-number">1.13.1.</span> <span class="toc-text">Prop 逐级透传问题 - provide / inject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Provide-提供"><span class="toc-number">1.13.2.</span> <span class="toc-text">Provide (提供)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#应用层-Provide"><span class="toc-number">1.13.3.</span> <span class="toc-text">应用层 Provide</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inject-注入"><span class="toc-number">1.13.4.</span> <span class="toc-text">Inject (注入)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注入默认值"><span class="toc-number">1.13.5.</span> <span class="toc-text">注入默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#和响应式数据配合使用"><span class="toc-number">1.13.6.</span> <span class="toc-text">和响应式数据配合使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用-Symbol-作注入名"><span class="toc-number">1.13.7.</span> <span class="toc-text">使用 Symbol 作注入名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步组件-async-components"><span class="toc-number">1.14.</span> <span class="toc-text">异步组件 - async-components</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本用法-basic-usage"><span class="toc-number">1.14.1.</span> <span class="toc-text">基本用法 - basic-usage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加载与错误状态-loading-and-error-states"><span class="toc-number">1.14.2.</span> <span class="toc-text">加载与错误状态 - loading-and-error-states</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#惰性激活"><span class="toc-number">1.14.3.</span> <span class="toc-text">惰性激活</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在空闲时进行激活-hydrate-on-idle"><span class="toc-number">1.14.4.</span> <span class="toc-text">在空闲时进行激活 - hydrate-on-idle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在可见时激活-hydrate-on-visible"><span class="toc-number">1.14.5.</span> <span class="toc-text">在可见时激活 - hydrate-on-visible</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在媒体查询匹配时进行激活-hydrate-on-media-query"><span class="toc-number">1.14.6.</span> <span class="toc-text">在媒体查询匹配时进行激活 - hydrate-on-media-query</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#交互时激活-hydrate-on-interaction"><span class="toc-number">1.14.7.</span> <span class="toc-text">交互时激活 - hydrate-on-interaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义策略-custom-strategy"><span class="toc-number">1.14.8.</span> <span class="toc-text">自定义策略 - custom-strategy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#搭配-Suspense-使用-using-with-suspense"><span class="toc-number">1.14.9.</span> <span class="toc-text">搭配 Suspense 使用 - using-with-suspense</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义指令"><span class="toc-number">1.15.</span> <span class="toc-text">自定义指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义指令的使用时机"><span class="toc-number">1.15.1.</span> <span class="toc-text">自定义指令的使用时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指令钩子"><span class="toc-number">1.15.2.</span> <span class="toc-text">指令钩子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#钩子参数"><span class="toc-number">1.15.3.</span> <span class="toc-text">钩子参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简化形式"><span class="toc-number">1.15.4.</span> <span class="toc-text">简化形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象字面量"><span class="toc-number">1.15.5.</span> <span class="toc-text">对象字面量</span></a></li></ol></li></ol></li></ol>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
            <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            vue3 相关存档
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="http://www.shuy.cc/2025/05/04/存档/index.html">
    
    <i class="icon-calendar vm"></i>
    
    <time class="vm" datetime="2025-05-04T02:30:10.000Z" itemprop="datePublished">2025-05-04</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag vm"></i>
    <a class="article-tag-link" href="/tags/vue3-pina-router/">vue3 pina router</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>你以为的你已经很了解了，每次读官方文档，都会发现有不一样的感悟，让你眼前一亮的感觉。</p>
<h2 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h2><p>Vue (发音为 /vjuː/，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。</p>
<blockquote>
<p>提供了 <code>选项式</code> API 和 <code>组合式</code> API 两种编程模型</p>
</blockquote>
<a id="more"></a>
<h3 id="响应式基础"><a href="#响应式基础" class="headerlink" title="响应式基础"></a>响应式基础</h3><ul>
<li><h4 id="ref"><a href="#ref" class="headerlink" title="ref()"></a><strong><code>ref()</code></strong></h4></li>
</ul>
<hr>
<p>在组合式 API 中，推荐使用 <code>ref()</code> 函数来声明响应式状态：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><code>ref()</code> 接收参数，并将其包裹在一个带有 .value 属性的 ref 对象中返回：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">count.value++</span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>要在组件模板中访问 ref，请从组件的 setup() 函数中声明并返回它们：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// `setup` 是一个特殊的钩子，专门用于组合式 API。</span></span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ref 暴露给模板</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，在模板中使用 ref 时，我们不需要附加 .value。为了方便起见，当在模板中使用时，ref 会自动解包 (有一些注意事项)。</p>
</blockquote>
<p><strong>在模板中解包的注意事项:</strong><br>在模板渲染上下文中，只有顶级的 ref 属性才会被解包。</p>
<p>在下面的例子中，count 和 object 是顶级属性，但 object.id 不是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; count &#125;&#125; &#123;&#123; object &#125;&#125; &#123;&#123; object.id &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> object = ref(&#123;</span><br><span class="line">      id: <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      object</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; count + <span class="number">1</span> &#125;&#125;  ✅</span><br><span class="line">&#123;&#123; object.id &#125;&#125;  ❌</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; object.id + 1 &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>渲染的结果将是 [object Object]1，因为在计算表达式时 object.id 没有被解包，仍然是一个 ref 对象。为了解决这个问题，我们可以将 id 解构为一个顶级属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; id &#125; = object</span><br><span class="line">&#123;&#123; id + <span class="number">1</span> &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>现在渲染的结果将是 2。</p>
<p><strong><code>&lt;script setup&gt;</code></strong></p>
<p>在 <code>setup()</code> 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用单文件组件 <code>(SFC)</code> 来避免这种情况。我们可以使用 <code>&lt;script setup&gt;</code> 来大幅度地简化代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">  count.value++</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"increment"</span>&gt;</span></span><br><span class="line">    &#123;&#123; count &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>为什么要使用 ref？</strong><br>你可能会好奇：为什么我们需要使用带有 .value 的 ref，而不是普通的变量？为了解释这一点，我们需要简单地讨论一下 Vue 的响应式系统是如何工作的。</p>
<p>当你在模板中使用了一个 ref，然后改变了这个 ref 的值时，Vue 会自动检测到这个变化，并且相应地更新 DOM。这是通过一个基于依赖追踪的响应式系统实现的。当一个组件首次渲染时，Vue 会追踪在渲染过程中使用的每一个 ref。然后，当一个 ref 被修改时，它会触发追踪它的组件的一次重新渲染。</p>
<p>在标准的 JavaScript 中，检测普通变量的访问或修改是行不通的。然而，我们可以通过 getter 和 setter 方法来拦截对象属性的 get 和 set 操作。</p>
<p>该 .value 属性给予了 Vue 一个机会来检测 ref 何时被访问或修改。在其内部，Vue 在它的 getter 中执行追踪，在它的 setter 中执行触发。从概念上讲，你可以将 ref 看作是一个像这样的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码，不是真正的实现</span></span><br><span class="line"><span class="keyword">const</span> myRef = &#123;</span><br><span class="line">  _value: <span class="number">0</span>,</span><br><span class="line">  <span class="keyword">get</span> value() &#123;</span><br><span class="line">    track()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> value(newValue) &#123;</span><br><span class="line">    <span class="keyword">this</span>._value = newValue</span><br><span class="line">    trigger()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个 ref 的好处是，与普通变量不同，你可以将 ref 传递给函数，同时保留对最新值和响应式连接的访问。当将复杂的逻辑重构为可重用的代码时，这将非常有用。</p>
<p><strong>深层响应性</strong><br>Ref 可以持有任何类型的值，包括深层嵌套的对象、数组或者 JavaScript 内置的数据结构，比如 Map。</p>
<p>Ref 会使它的值具有深层响应性。这意味着即使改变嵌套对象或数组时，变化也会被检测到：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = ref(&#123;</span><br><span class="line">  nested: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  arr: [<span class="string">'foo'</span>, <span class="string">'bar'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mutateDeeply</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以下都会按照期望工作</span></span><br><span class="line">  obj.value.nested.count++</span><br><span class="line">  obj.value.arr.push(<span class="string">'baz'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>DOM 更新时机</strong><br>当你修改了响应式状态时，DOM 会被自动更新。但是需要注意的是，DOM 更新不是同步的。Vue 会在“next tick”更新周期中缓存所有状态的修改，以确保不管你进行了多少次状态修改，每个组件都只会被更新一次。</p>
<p>要等待 DOM 更新完成后再执行额外的代码，可以使用 <code>nextTick()</code> 全局 API：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count.value++</span><br><span class="line">  <span class="keyword">await</span> nextTick()</span><br><span class="line">  <span class="comment">// 现在 DOM 已经更新了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive()"></a><strong><code>reactive()</code></strong></h4></li>
</ul>
<hr>
<p>还有另一种声明响应式状态的方式，即使用 <code>reactive()</code> API。与将内部值包装在特殊对象中的 ref 不同，reactive() 将使对象本身具有响应性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>在模板中使用：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"state.count++"</span>&gt;</span></span><br><span class="line">  &#123;&#123; state.count &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>reactive()</code> 将 <code>深层地</code> 转换对象：当访问嵌套对象时，它们也会被 <code>reactive()</code> 包装。当 ref 的值是一个对象时，<code>ref()</code> 也会在内部调用它。与浅层 <code>ref</code> 类似，这里也有一个 <code>shallowReactive()</code> API 可以选择退出深层响应性。</p>
<p><strong>reactive() 的局限性:</strong></p>
<p>1.<strong>有限的值类型：</strong>它只能用于对象类型 (对象、数组和如 Map、Set 这样的集合类型)。它不能持有如 string、number 或 boolean 这样的原始类型。<br>2.<strong>不能替换整个对象：</strong>由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。这意味着我们不能轻易地“替换”响应式对象，因为这样的话与第一个引用的响应性连接将丢失：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// 上面的 (&#123; count: 0 &#125;) 引用将不再被追踪</span></span><br><span class="line"><span class="comment">// (响应性连接已丢失！)</span></span><br><span class="line">state = reactive(&#123; <span class="attr">count</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure></p>
<p>3.对解构操作不友好：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// 当解构时，count 已经与 state.count 断开连接</span></span><br><span class="line"><span class="keyword">let</span> &#123; count &#125; = state</span><br><span class="line"><span class="comment">// 不会影响原始的 state</span></span><br><span class="line">count++</span><br><span class="line"><span class="comment">// 该函数接收到的是一个普通的数字</span></span><br><span class="line"><span class="comment">// 并且无法追踪 state.count 的变化</span></span><br><span class="line"><span class="comment">// 我们必须传入整个对象以保持响应性</span></span><br><span class="line">callSomeFunction(state.count)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>由于这些限制，我们建议使用 <code>ref()</code> 作为声明响应式状态的主要 API。</strong></p>
</blockquote>
<h4 id="ref-和-reactive-的区别"><a href="#ref-和-reactive-的区别" class="headerlink" title="ref 和 reactive 的区别"></a>ref 和 reactive 的区别</h4><table>
<thead>
<tr>
<th>api</th>
<th>定义</th>
<th>原理</th>
<th>数据支持</th>
<th>访问方式</th>
<th>设计需求</th>
</tr>
</thead>
<tbody>
<tr>
<td>ref</td>
<td>用于创建<code>任何值</code>类型（基本类型或对象）的响应式引用，返回一个包含<code>.value</code>属性的对象</td>
<td>通过<code>getter/setter</code>劫持实现响应式，对象类型内部<code>自动调用reactive</code>转换。‌‌</td>
<td>ref支持<code>所有类型</code>（如number、string、object）</td>
<td><code>ref</code>需通过<code>.value</code>访问（模板中自动解包）</td>
<td>ref解决<code>单一值</code>的响应式需求</td>
</tr>
<tr>
<td>reactive</td>
<td>仅适用于<code>对象类型</code>（对象、数组、Map/Set等），返回原始对象的<code>Proxy</code>代理</td>
<td>基于<code>Proxy递归劫持</code>对象属性，实现深层<code>响应式</code>。‌</td>
<td>reactive支持<code>对象类型</code></td>
<td>reactive<code>直接访问属性</code></td>
<td><code>reactive</code>处理<code>复杂数据结构</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>1.<code>ref</code>简化基本类型响应式，<code>reactive</code> 优化对象操作（如嵌套属性直接修改）。‌<br>2.ref 包装对象时 内部 <code>依赖</code> reactive，两者<code>协同</code>工作。‌</p>
</blockquote>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。比如说，我们有这样一个包含嵌套数组的对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> author = reactive(&#123;</span><br><span class="line">  name: <span class="string">'John Doe'</span>,</span><br><span class="line">  books: [</span><br><span class="line">    <span class="string">'Vue 2 - Advanced Guide'</span>,</span><br><span class="line">    <span class="string">'Vue 3 - Basic Guide'</span>,</span><br><span class="line">    <span class="string">'Vue 4 - The Mystery'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>我们想根据 author 是否已有一些书籍来展示不同的信息：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Has published books:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; author.books.length &gt; 0 ? 'Yes' : 'No' &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的模板看起来有些复杂。我们必须认真看好一会儿才能明白它的计算依赖于 <code>author.books</code>。更重要的是，如果在模板中需要不止一次这样的计算，我们可不想将这样的代码在模板里重复好多遍。</p>
<p>因此我们推荐使用<code>计算属性</code>来描述依赖响应式状态的复杂逻辑。这是重构后的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; reactive, computed &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> author = reactive(&#123;</span><br><span class="line">  name: <span class="string">'John Doe'</span>,</span><br><span class="line">  books: [</span><br><span class="line">    <span class="string">'Vue 2 - Advanced Guide'</span>,</span><br><span class="line">    <span class="string">'Vue 3 - Basic Guide'</span>,</span><br><span class="line">    <span class="string">'Vue 4 - The Mystery'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个计算属性 ref</span></span><br><span class="line"><span class="keyword">const</span> publishedBooksMessage = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> author.books.length &gt; <span class="number">0</span> ? <span class="string">'Yes'</span> : <span class="string">'No'</span></span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;template&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;Has published books:&lt;/</span>p&gt;</span><br><span class="line">  &lt;span&gt;&#123;&#123; publishedBooksMessage &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure>
<p>我们在这里定义了一个计算属性 <code>publishedBooksMessage</code>。<code>computed()</code> 方法期望接收一个 <code>getter</code> 函数，返回值为一个计算属性 <code>ref</code>。和其他一般的 ref 类似，你可以通过 <code>publishedBooksMessage.value</code> 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 <code>.value</code>。</p>
<p>Vue 的计算属性会自动追踪响应式依赖。它会检测到 <code>publishedBooksMessage</code> 依赖于 <code>author.books</code>，所以当 <code>author.books</code> 改变时，任何依赖于 <code>publishedBooksMessage</code> 的绑定都会同时更新。</p>
<h4 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h4><p>你可能注意到我们在表达式中像这样调用一个函数也会获得和计算属性相同的结果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; calculateBooksMessage() &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateBooksMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> author.books.length &gt; <span class="number">0</span> ? <span class="string">'Yes'</span> : <span class="string">'No'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于<strong>计算属性值会基于其响应式依赖被缓存</strong>。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 <code>author.books</code> 不改变，无论多少次访问 <code>publishedBooksMessage</code> 都会立即返回先前的计算结果，而不用重复执行 <code>getter</code> 函数。</p>
<p>这也解释了为什么下面的计算属性永远不会更新，因为 Date.now() 并不是一个响应式依赖：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> now = computed(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Date</span>.now())</span><br></pre></td></tr></table></figure></p>
<p>相比之下，方法调用<code>总是</code>会在重渲染发生时再次执行函数。</p>
<p>为什么需要缓存呢？想象一下我们有一个非常耗性能的计算属性 <code>list</code>，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 <code>list</code>。没有缓存的话，我们会重复执行非常多次 <code>list</code> 的 <code>getter</code>，然而这实际上没有必要！如果你确定不需要缓存，那么也可以使用方法调用。</p>
<h4 id="可写计算属性"><a href="#可写计算属性" class="headerlink" title="可写计算属性"></a>可写计算属性</h4><p>计算属性默认是<code>只读</code>的。当你尝试修改一个计算属性时，你会收到一个运行时<code>警告</code>。只在某些特殊场景中你可能才需要用到<code>“可写”</code>的属性，你可以通过同时提供 <code>getter</code> 和 <code>setter</code> 来创建：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firstName = ref(<span class="string">'John'</span>)</span><br><span class="line"><span class="keyword">const</span> lastName = ref(<span class="string">'Doe'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fullName = computed(&#123;</span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName.value + <span class="string">' '</span> + lastName.value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// setter</span></span><br><span class="line">  <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">    <span class="comment">// 注意：我们这里使用的是解构赋值语法</span></span><br><span class="line">    [firstName.value, lastName.value] = newValue.split(<span class="string">' '</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在当你再运行 <code>fullName.value = &#39;John Doe&#39;</code> 时，<code>setter</code> 会被调用而 <code>firstName</code> 和 <code>lastName</code> 会随之更新。</p>
<h4 id="获取上一个值-仅-3-4-支持"><a href="#获取上一个值-仅-3-4-支持" class="headerlink" title="获取上一个值(仅 3.4+ 支持)"></a>获取上一个值(仅 3.4+ 支持)</h4><p>如果需要，可以通过访问计算属性的 getter 的第一个参数来获取计算属性返回的上一个值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个计算属性在 count 的值小于或等于 3 时，将返回 count 的值。</span></span><br><span class="line"><span class="comment">// 当 count 的值大于等于 4 时，将会返回满足我们条件的最后一个值</span></span><br><span class="line"><span class="comment">// 直到 count 的值再次小于或等于 3 为止。</span></span><br><span class="line"><span class="keyword">const</span> alwaysSmall = computed(<span class="function">(<span class="params">previous</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (count.value &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> count.value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> previous</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你正在使用可写的计算属性的话：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> alwaysSmall = computed(&#123;</span><br><span class="line">  <span class="keyword">get</span>(previous) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count.value &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> count.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> previous</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">    count.value = newValue * <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>避免直接修改计算属性值​</strong><br>从计算属性返回的值是<code>派生状态</code>。可以把它看作是一个<code>“临时快照”</code>，每当源状态发生变化时，就会创建一个新的快照。更改<code>快照</code>是没有意义的，因此计算属性的返回值应该被视为<code>只读的</code>，并且永远<code>不应该被更改</code>——应该更新它所依赖的源状态以触发新的计算。</p>
</blockquote>
<h3 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h3><h4 id="class-绑定"><a href="#class-绑定" class="headerlink" title="class 绑定"></a>class 绑定</h4><h4 id="1-绑定对象"><a href="#1-绑定对象" class="headerlink" title="1. 绑定对象"></a>1. 绑定对象</h4><hr>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"&#123;'active': isActive&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的语法表示 active 是否存在取决于数据属性 isActive 的真假值。</p>
<hr>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isActive = ref(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">const</span> hasError = ref(<span class="literal">false</span>)</span><br><span class="line">&lt;div</span><br><span class="line">  <span class="class"><span class="keyword">class</span></span>=<span class="string">"static"</span></span><br><span class="line">  :<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span></span><br><span class="line">&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
<p>result:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static active"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> classObject = reactive(&#123;</span><br><span class="line">  active: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'text-danger'</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"classObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这将渲染：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>我们也可以绑定一个返回对象的<code>计算属性</code>。这是一个常见且很有用的技巧：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isActive = ref(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">const</span> error = ref(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> classObject = computed(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  active: isActive.value &amp;&amp; !error.value,</span><br><span class="line">  <span class="string">'text-danger'</span>: error.value &amp;&amp; error.value.type === <span class="string">'fatal'</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"classObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>result:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"active"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="2-绑定数组"><a href="#2-绑定数组" class="headerlink" title="2. 绑定数组"></a>2. 绑定数组</h4><p>我们可以给 :class 绑定一个数组来渲染多个 CSS class：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> activeClass = ref(<span class="string">'active'</span>)</span><br><span class="line"><span class="keyword">const</span> errorClass = ref(<span class="string">'text-danger'</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[activeClass, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>渲染的结果是：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"active text-danger"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>如果你也想在数组中有条件地渲染某个 class，你可以使用<code>三元表达式</code>：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>errorClass</code> 会一直存在，但 <code>activeClass</code> 只会在 <code>isActive</code> 为真时才存在。</p>
<p>然而，这可能在有多个依赖条件的 class 时会有些冗长。因此也可以在数组中嵌套对象：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[&#123; [activeClass]: isActive &#125;, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="style-绑定"><a href="#style-绑定" class="headerlink" title="style 绑定"></a>style 绑定</h4><h5 id="1-绑定对象-1"><a href="#1-绑定对象-1" class="headerlink" title="1. 绑定对象"></a>1. 绑定对象</h5><p><code>:style</code> 支持绑定 JavaScript 对象值，对应的是 <code>HTML 元素的 style 属性</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> activeColor = ref(<span class="string">'red'</span>)</span><br><span class="line"><span class="keyword">const</span> fontSize = ref(<span class="number">30</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>直接绑定一个样式对象通常是一个好主意，这样可以使模板更加简洁：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> styleObject = reactive(&#123;</span><br><span class="line">  color: <span class="string">'red'</span>,</span><br><span class="line">  fontSize: <span class="string">'30px'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"styleObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="2-绑定数组-1"><a href="#2-绑定数组-1" class="headerlink" title="2. 绑定数组"></a>2. 绑定数组</h5><p>我们还可以给 :style 绑定一个包含多个样式对象的数组。这些对象会被合并后渲染到同一元素上：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"[baseStyles, overridingStyles]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><h4 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h4><h4 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h4><h4 id="lt-template-gt-上的-v-if"><a href="#lt-template-gt-上的-v-if" class="headerlink" title="&lt;template&gt; 上的 v-if"></a><code>&lt;template&gt;</code> 上的 v-if</h4><p>因为 v-if 是一个指令，他必须依附于某个元素。但如果我们想要切换不止一个元素呢？在这种情况下我们可以在一个 <template> 元素上使用 v-if，这只是一个不可见的包装器元素，最后渲染的结果并不会包含这个 <template> 元素。</template></template></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>v-else</code> 和 <code>v-else-if</code> 也可以在 <code>&lt;template&gt;</code> 上使用。</p>
<h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><blockquote>
<p>v-show 不支持在 <code>&lt;template&gt;</code> 元素上使用，也不能和 v-else 搭配使用。</p>
</blockquote>
<h4 id="v-if-vs-v-show​"><a href="#v-if-vs-v-show​" class="headerlink" title="v-if vs v-show​"></a>v-if vs v-show​</h4><p>v-if 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。<br>v-if 也是惰性的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。<br>相比之下，v-show 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS display 属性会被切换。<br>总的来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 v-show 较好；如果在运行时绑定条件很少改变，则 v-if 会更合适。</p>
<h4 id="v-if-和-v-for-优先级和V2-有区别"><a href="#v-if-和-v-for-优先级和V2-有区别" class="headerlink" title="v-if 和 v-for(优先级和V2 有区别)"></a>v-if 和 v-for(优先级和V2 有区别)</h4><p>当 v-if 和 v-for 同时存在于一个元素上的时候，v-if 会首先被执行。</p>
<h3 id="侦听器-watch"><a href="#侦听器-watch" class="headerlink" title="侦听器 - watch()"></a>侦听器 - watch()</h3><hr>
<p>计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。</p>
<p>在组合式 API 中，我们可以使用 <code>watch</code> 函数在每次响应式状态发生变化时触发回调函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> question = ref(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">const</span> answer = ref(<span class="string">'Questions usually contain a question mark. ;-)'</span>)</span><br><span class="line"><span class="keyword">const</span> loading = ref(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接侦听一个 ref</span></span><br><span class="line">watch(question, <span class="keyword">async</span> (newQuestion, oldQuestion) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (newQuestion.includes(<span class="string">'?'</span>)) &#123;</span><br><span class="line">    loading.value = <span class="literal">true</span></span><br><span class="line">    answer.value = <span class="string">'Thinking...'</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">'https://yesno.wtf/api'</span>)</span><br><span class="line">      answer.value = (<span class="keyword">await</span> res.json()).answer</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      answer.value = <span class="string">'Error! Could not reach the API. '</span> + error</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      loading.value = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;template&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;</span></span><br><span class="line"><span class="regexp">    Ask a yes/</span>no question:</span><br><span class="line">    &lt;input v-model=<span class="string">"question"</span> :disabled=<span class="string">"loading"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="数据源类型"><a href="#数据源类型" class="headerlink" title="数据源类型"></a>数据源类型</h4><p>watch 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> y = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个 ref</span></span><br><span class="line">watch(x, (newX) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`x is <span class="subst">$&#123;newX&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter 函数</span></span><br><span class="line">watch(</span><br><span class="line">  () =&gt; x.value + y.value,</span><br><span class="line">  (sum) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`sum of x + y is: <span class="subst">$&#123;sum&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个来源组成的数组</span></span><br><span class="line">watch([x, () =&gt; y.value], ([newX, newY]) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`x is <span class="subst">$&#123;newX&#125;</span> and y is <span class="subst">$&#123;newY&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，你不能直接侦听响应式对象的属性值，例如:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，因为 watch() 得到的参数是一个 number</span></span><br><span class="line">watch(obj.count, (count) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Count is: <span class="subst">$&#123;count&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里需要用一个返回该属性的 getter 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供一个 getter 函数</span></span><br><span class="line">watch(</span><br><span class="line">  () =&gt; obj.count,</span><br><span class="line">  (count) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Count is: <span class="subst">$&#123;count&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="深层侦听器-deep-3-5-及以上版本"><a href="#深层侦听器-deep-3-5-及以上版本" class="headerlink" title="深层侦听器 - deep (3.5 及以上版本)"></a>深层侦听器 - deep (3.5 及以上版本)</h4><p>直接给 watch() 传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的变更时都会被触发：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line">watch(obj, (newValue, oldValue) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 在嵌套的属性变更时触发</span></span><br><span class="line">  <span class="comment">// 注意：`newValue` 此处和 `oldValue` 是相等的</span></span><br><span class="line">  <span class="comment">// 因为它们是同一个对象！</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.count++</span><br></pre></td></tr></table></figure></p>
<p>相比之下，一个返回响应式对象的 getter 函数，只有在返回不同的对象时，才会触发回调：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch(</span><br><span class="line">  () =&gt; state.someObject,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 仅当 state.someObject 被替换时触发</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>你也可以给上面这个例子显式地加上 <code>deep</code> 选项，强制转成深层侦听器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch(</span><br><span class="line">  () =&gt; state.someObject,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 仅当 state.someObject 被替换时触发</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>在 <code>Vue 3.5+</code> 中，deep 选项还可以是一个数字，表示最大遍历深度——即 Vue 应该遍历对象嵌套属性的级数。</p>
<h4 id="即时回调的侦听器​-immediate"><a href="#即时回调的侦听器​-immediate" class="headerlink" title="即时回调的侦听器​ - immediate"></a>即时回调的侦听器​ - immediate</h4><p>watch 默认是<code>懒执行</code>的：仅当<code>数据源变化</code>时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，<code>立即执行</code>一遍回调。举例来说，我们想请求一些初始数据，然后在相关状态更改时重新请求数据。</p>
<p>我们可以通过传入 <code>immediate: true</code> 选项来强制侦听器的回调立即执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch(</span><br><span class="line">  source,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 立即执行，且当 `source` 改变时再次执行</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="一次性侦听器-once-3-4-及以上版本"><a href="#一次性侦听器-once-3-4-及以上版本" class="headerlink" title="一次性侦听器 - once (3.4 及以上版本)"></a>一次性侦听器 - once (3.4 及以上版本)</h4><p>每当被侦听源发生变化时，侦听器的回调就会执行。如果希望回调只在源变化时触发一次，请使用 <code>once: true</code> 选项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch(</span><br><span class="line">  source,</span><br><span class="line">  (newValue, oldValue) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 当 `source` 变化时，仅触发一次</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect()"></a>watchEffect()</h4><p>侦听器的回调使用与源完全相同的响应式状态是很常见的。例如下面的代码，在每当 <code>todoId</code> 的引用发生变化时使用侦听器来加载一个远程资源：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoId = ref(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> data = ref(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">watch(</span><br><span class="line">  todoId,</span><br><span class="line">  <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(</span><br><span class="line">      <span class="string">`https://jsonplaceholder.typicode.com/todos/<span class="subst">$&#123;todoId.value&#125;</span>`</span></span><br><span class="line">    )</span><br><span class="line">    data.value = <span class="keyword">await</span> response.json()</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>特别是注意侦听器是如何两次使用 <code>todoId</code> 的，一次是作为<code>源</code>，另一次是在<code>回调中</code>。</p>
<p>我们可以用 <code>watchEffect</code> 函数 来简化上面的代码。<code>watchEffect()</code> 允许我们自动跟踪回调的响应式依赖。上面的侦听器可以重写为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(</span><br><span class="line">    <span class="string">`https://jsonplaceholder.typicode.com/todos/<span class="subst">$&#123;todoId.value&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line">  data.value = <span class="keyword">await</span> response.json()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个例子中，回调会立即执行，不需要指定 <code>immediate: true</code>。在执行期间，它会自动追踪 <code>todoId.value</code> 作为依赖(和计算属性类似)。每当 <code>todoId.value</code> 变化时，回调会再次执行。有了 <code>watchEffect()</code>，我们不再需要明确传递 <code>todoId</code> 作为源值。</p>
<p>对于这种只有一个依赖项的例子来说，<code>watchEffect()</code> 的好处相对较小。但是对于有多个依赖项的侦听器来说，使用 <code>watchEffect()</code> 可以消除手动维护依赖列表的负担。此外，如果你需要侦听一个嵌套数据结构中的几个属性，<code>watchEffect()</code> 可能会比深度侦听器更有效，因为它将只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性。</p>
<h4 id="watch-vs-watchEffect"><a href="#watch-vs-watchEffect" class="headerlink" title="watch vs watchEffect"></a>watch vs watchEffect</h4><p><code>watch</code> 和 <code>watchEffect</code> 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：</p>
<ul>
<li><code>watch</code> 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。<code>watch</code>会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。</li>
<li><code>watchEffect</code>，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。</li>
</ul>
<h4 id="副作用清理"><a href="#副作用清理" class="headerlink" title="副作用清理"></a>副作用清理</h4><p>有时我们可能会在侦听器中执行副作用，例如异步请求：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch(id, (newId) =&gt; &#123;</span><br><span class="line">  fetch(<span class="string">`/api/<span class="subst">$&#123;newId&#125;</span>`</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 回调逻辑</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>但是如果在请求完成之前 id 发生了变化怎么办？当上一个请求完成时，它仍会使用已经过时的 ID 值触发回调。理想情况下，我们希望能够在 id 变为新值时取消过时的请求。</p>
<p>我们可以使用 <code>onWatcherCleanup() (3.5+)</code> API 来注册一个清理函数，当侦听器失效并准备重新运行时会被调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watch, onWatcherCleanup &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">watch(id, (newId) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> controller = <span class="keyword">new</span> AbortController()</span><br><span class="line"></span><br><span class="line">  fetch(<span class="string">`/api/<span class="subst">$&#123;newId&#125;</span>`</span>, &#123; <span class="attr">signal</span>: controller.signal &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 回调逻辑</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  onWatcherCleanup(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 终止过期请求</span></span><br><span class="line">    controller.abort()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>请注意，<code>onWatcherCleanup</code> 仅在 Vue 3.5+ 中支持，并且必须在 <code>watchEffect</code> 效果函数或 <code>watch</code> 回调函数的同步执行期间调用：你不能在异步函数的 <code>await</code> 语句之后调用它。</p>
<p>作为替代，<code>onCleanup</code> 函数还作为第三个参数传递给侦听器回调，以及 <code>watchEffect</code> 作用函数的第一个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">watch(id, (newId, oldId, onCleanup) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> controller = <span class="keyword">new</span> AbortController()</span><br><span class="line"></span><br><span class="line">  fetch(<span class="string">`/api/<span class="subst">$&#123;newId&#125;</span>`</span>, &#123; <span class="attr">signal</span>: controller.signal &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 回调逻辑</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  onCleanup(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 终止过期请求</span></span><br><span class="line">    controller.abort()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>或者，如果你使用的是 <code>watchEffect</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(<span class="function">(<span class="params">onCleanup</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> controller = <span class="keyword">new</span> AbortController()</span><br><span class="line"></span><br><span class="line">  fetch(<span class="string">`/api/<span class="subst">$&#123;id.value&#125;</span>`</span>, &#123; <span class="attr">signal</span>: controller.signal &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 回调逻辑</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  onCleanup(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 终止过期请求</span></span><br><span class="line">    controller.abort()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这在 3.5 之前的版本有效。此外，通过函数参数传递的 <code>onCleanup</code> 与侦听器实例相绑定，因此不受 <code>onWatcherCleanup</code> 的同步限制。</p>
<h3 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h3><hr>
<p>虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素。要实现这一点，我们可以使用特殊的 ref attribute：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">"input"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>ref</code> 是一个特殊的 attribute。它允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。这可能很有用，比如说在组件挂载时将焦点设置到一个 input 元素上，或在一个元素上初始化一个第三方库。</p>
<h4 id="访问模板引用"><a href="#访问模板引用" class="headerlink" title="访问模板引用"></a>访问模板引用</h4><p>要在组合式 API 中获取引用，我们可以使用辅助函数 <code>useTemplateRef() (3.5+)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; useTemplateRef, onMounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数必须与模板中的 ref 值匹配</span></span><br><span class="line"><span class="keyword">const</span> input = useTemplateRef(<span class="string">'my-input'</span>)</span><br><span class="line"></span><br><span class="line">onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  input.value.focus()</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;template&gt;</span></span><br><span class="line"><span class="regexp">  &lt;input ref="my-input" /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>3.5 之前</code>的版本，<br>在 3.5 之前的版本尚未引入 <code>useTemplateRef()</code>，我们需要声明一个与模板里 ref attribute 匹配的引用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 ref 来存放该元素的引用</span></span><br><span class="line"><span class="comment">// 必须和模板里的 ref 同名</span></span><br><span class="line"><span class="keyword">const</span> input = ref(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  input.value.focus()</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;template&gt;</span></span><br><span class="line"><span class="regexp">  &lt;input ref="input" /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果不使用 <code>&lt;script setup&gt;</code>，需确保从 <code>setup()</code> 返回 ref：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> input = ref(<span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      input</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，你只可以在组件挂载后才能访问模板引用。如果你想在模板中的表达式上访问 input，在初次渲染时会是 null。这是因为在初次渲染前这个元素还不存在呢！</p>
<p>如果你需要侦听一个模板引用 ref 的变化，确保考虑到其值为 null 的情况：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (input.value) &#123;</span><br><span class="line">    input.value.focus()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 此时还未挂载，或此元素已经被卸载(例如通过 v-if 控制)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="组件上的-ref"><a href="#组件上的-ref" class="headerlink" title="组件上的 ref"></a>组件上的 ref</h4><p>模板引用也可以被用在一个子组件上。这种情况下引用中获得的值是组件实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; useTemplateRef, onMounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> childRef = useTemplateRef(<span class="string">'child'</span>)</span><br><span class="line"></span><br><span class="line">onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// childRef.value 将持有 &lt;Child /&gt; 的实例</span></span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;template&gt;</span></span><br><span class="line"><span class="regexp">  &lt;Child ref="child" /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.5 之前的版本，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, onMounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = ref(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// child.value 是 &lt;Child /&gt; 组件的实例</span></span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;template&gt;</span></span><br><span class="line"><span class="regexp">  &lt;Child ref="child" /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果一个子组件使用的是选项式 API 或没有使用 <code>&lt;script setup&gt;</code>，被引用的组件实例和该子组件的 <code>this</code> 完全一致，这意味着父组件对子组件的每一个属性和方法都有完全的访问权。这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，当然也因此，应该只在绝对需要时才使用组件引用。大多数情况下，你应该首先使用标准的 props 和 emit 接口来实现父子组件交互。</p>
<p>有一个例外的情况，使用了 <code>&lt;script setup&gt;</code> 的组件是默认私有的：一个父组件无法访问到一个使用了 <code>&lt;script setup&gt;</code> 的子组件中的任何东西，除非子组件在其中通过 <code>defineExpose</code> 宏显式暴露：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = ref(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像 defineExpose 这样的编译器宏不需要导入</span></span><br><span class="line">defineExpose(&#123;</span><br><span class="line">  a,</span><br><span class="line">  b</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>当父组件通过模板引用获取到了该组件的实例时，得到的实例类型为 { a: number, b: number } (ref 都会自动解包，和一般的实例一样)。</p>
<blockquote>
<p>请注意，<code>defineExpose</code> 必须在任何 <code>await</code> 操作之前调用。否则，在 <code>await</code> 操作后暴露的属性和方法将无法访问</p>
</blockquote>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h4><p><img src="/images/img-folder/vue-smzq.png"></p>
<table>
<thead>
<tr>
<th style="text-align:left">生命周期名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">setup</td>
<td style="text-align:left">组件初始化时调用，在 beforeCreate 和 created 之前调用，只能使用 Composition API 相关的函数，不能使用 this。</td>
</tr>
<tr>
<td style="text-align:left">onBeforeMount</td>
<td style="text-align:left">组件挂载之前调用，在 mounted 之前调用，不能使用 this。</td>
</tr>
<tr>
<td style="text-align:left">onMounted</td>
<td style="text-align:left">组件挂载完成后调用，在 mounted 之后调用，不能使用 this。</td>
</tr>
<tr>
<td style="text-align:left">onBeforeUpdate</td>
<td style="text-align:left">组件更新之前调用，在 updated 之前调用，不能使用 this。</td>
</tr>
<tr>
<td style="text-align:left">onUpdated</td>
<td style="text-align:left">组件更新完成后调用，在 updated 之后调用，不能使用 this。</td>
</tr>
<tr>
<td style="text-align:left">onBeforeUnmount</td>
<td style="text-align:left">组件卸载之前调用，在 unmounted 之前调用，不能使用 this。</td>
</tr>
<tr>
<td style="text-align:left">onUnmounted</td>
<td style="text-align:left">组件卸载完成后调用，在 unmounted 之后调用，不能使用 this。</td>
</tr>
<tr>
<td style="text-align:left"><code>onRenderTracked</code> <sup>dev-only</sup></td>
<td style="text-align:left">注册一个调试钩子，当组件渲染过程中追踪到响应式依赖时调用。<strong>这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。</strong></td>
</tr>
<tr>
<td style="text-align:left"><code>onRenderTriggered</code> <sup>dev-only</sup></td>
<td style="text-align:left">注册一个调试钩子，当响应式依赖的变更触发了组件渲染时调用。<strong>这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。</strong></td>
</tr>
<tr>
<td style="text-align:left"><code>onActivated</code></td>
<td style="text-align:left">注册一个回调函数，若组件实例是 <code>&lt;KeepAlive&gt;</code> 缓存树的一部分，当组件被插入到 DOM 中时调用。<strong>这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。</strong></td>
</tr>
<tr>
<td style="text-align:left"><code>onDeactivated</code></td>
<td style="text-align:left">注册一个回调函数，若组件实例是 <code>&lt;KeepAlive&gt;</code> 缓存树的一部分，当组件从 DOM 中被移除时调用。<strong>这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。</strong></td>
</tr>
<tr>
<td style="text-align:left"><code>onServerPrefetch</code> <sup>SSR only</sup></td>
<td style="text-align:left">注册一个异步函数，在组件实例在服务器上被渲染之前调用。</td>
</tr>
</tbody>
</table>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>一个组件需要显式声明它所接受的 props，这样 Vue 才能知道外部传入的哪些是 props。</p>
<h4 id="defineProps"><a href="#defineProps" class="headerlink" title="defineProps()"></a>defineProps()</h4><p>在使用 <code>&lt;script setup&gt;</code> 的单文件组件中，<code>props</code> 可以使用 <code>defineProps()</code> 宏来声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">const</span> props = defineProps([<span class="string">'foo'</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(props.foo)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>在没有使用 <code>&lt;script setup&gt;</code> 的组件中，<code>props</code> 可以使用 <code>props</code> 选项来声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: [<span class="string">'foo'</span>],</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    <span class="comment">// setup() 接收一个上下文对象，其中包含组件的 props</span></span><br><span class="line">    <span class="built_in">console</span>.log(props.foo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意传递给 <code>defineProps()</code> 的参数和提供给 <code>props</code> 选项的值是相同的，两种声明方式背后其实使用的都是 <code>props</code> 选项。</p>
<p>除了使用字符串数组来声明 <code>props</code> 外，还可以使用<code>对象</code>的形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 &lt;script setup&gt;</span></span><br><span class="line"><span class="keyword">const</span> props = defineProps(&#123;</span><br><span class="line">  itemData: &#123;</span><br><span class="line">    type: <span class="built_in">Object</span></span><br><span class="line">  &#125;,</span><br><span class="line">  index: <span class="built_in">Number</span>,</span><br><span class="line">  showRank: &#123;</span><br><span class="line">    type: <span class="built_in">Boolean</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  rank: &#123;</span><br><span class="line">    type: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">defineProps(&#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 非 &lt;script setup&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: <span class="built_in">String</span>,</span><br><span class="line">    likes: <span class="built_in">Number</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;script setup lang=<span class="string">"ts"</span>&gt;</span><br><span class="line">defineProps&lt;&#123;</span><br><span class="line">  title?: string</span><br><span class="line">  likes?: number</span><br><span class="line">&#125;&gt;()</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="触发与监听事件"><a href="#触发与监听事件" class="headerlink" title="触发与监听事件"></a>触发与监听事件</h4><p>在组件的模板表达式中，可以直接使用 <code>$emit</code> 方法触发自定义事件 (例如：在 <code>v-on</code> 的处理函数中)：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyComponent --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"$emit('someEvent')"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在父组件中监听这个事件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> @<span class="attr">some-event</span>=<span class="string">"callback"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在父组件中，可以通过 <code>v-on</code> 或 <code>@</code> 来监听子组件触发的事件。事件名需要和子组件 <code>$emit</code> 的名称完全匹配。</p>
<h4 id="事件参数"><a href="#事件参数" class="headerlink" title="事件参数"></a>事件参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=<span class="string">"$emit('increaseBy', 1)"</span>&gt;</span><br><span class="line">  Increase by <span class="number">1</span></span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyButton</span> @<span class="attr">increase-by</span>=<span class="string">"(n) =&gt; count += n"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者是<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyButton</span> @<span class="attr">increase-by</span>=<span class="string">"increaseCount"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increaseCount</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  count.value += n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：所有传入 $emit() 的额外参数都会被直接传向监听器。举例来说，$emit(‘foo’, 1, 2, 3) 触发后，监听器函数将会收到这三个参数值。</p>
</blockquote>
<h4 id="声明触发的事件-defineEmits"><a href="#声明触发的事件-defineEmits" class="headerlink" title="声明触发的事件 - defineEmits()"></a>声明触发的事件 - defineEmits()</h4><p>组件可以显式地通过 <code>defineEmits()</code> 宏来声明它要触发的事件：</p>
<p><strong>父组件</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tab-r</span> <span class="attr">id</span>=<span class="string">"tab15"</span> @<span class="attr">open</span>=<span class="string">"open"</span>&gt;</span><span class="tag">&lt;/<span class="name">tab-r</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uni-popup</span> <span class="attr">ref</span>=<span class="string">"popup"</span> <span class="attr">type</span>=<span class="string">"bottom"</span> <span class="attr">border-radius</span>=<span class="string">"10px 10px 0 0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">"padding: 40rpx;background: #fff;"</span> <span class="attr">class</span>=<span class="string">"popup-content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>人生若只如初见，何事秋风悲画扇<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">uni-popup</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> open = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 等待DOM更新</span></span><br><span class="line">    <span class="keyword">await</span> nextTick()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (popup.value &amp;&amp; popup.value.open) &#123;</span><br><span class="line">      popup.value.open(<span class="string">'bottom'</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'uni-popup opened successfully'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'uni-popup ref not found'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'Failed to open popup:'</span>, error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>子组件</strong>  <code>tab-r</code>子组件<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"university-info-bottom-item"</span> @<span class="attr">click</span>=<span class="string">"openFn"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"num"</span>&gt;</span>66<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"university-info-bottom-item-text"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span>&gt;</span>开学率<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">up-icon</span> <span class="attr">name</span>=<span class="string">"info-circle"</span> <span class="attr">color</span>=<span class="string">"#333"</span> <span class="attr">size</span>=<span class="string">"12"</span>&gt;</span><span class="tag">&lt;/<span class="name">up-icon</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> emits = defineEmits([<span class="string">'open'</span>])</span><br><span class="line"><span class="keyword">const</span> openFn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  emits(<span class="string">'open'</span>, <span class="number">1111</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="事件校验"><a href="#事件校验" class="headerlink" title="事件校验"></a>事件校验</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">const</span> emit = defineEmits(&#123;</span><br><span class="line">  <span class="comment">// 没有校验</span></span><br><span class="line">  click: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 校验 submit 事件</span></span><br><span class="line">  submit: <span class="function">(<span class="params">&#123; email, password &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (email &amp;&amp; password) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">'Invalid submit event payload!'</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submitForm</span>(<span class="params">email, password</span>) </span>&#123;</span><br><span class="line">  emit(<span class="string">'submit'</span>, &#123; email, password &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="组件-v-model-defineModel"><a href="#组件-v-model-defineModel" class="headerlink" title="组件 v-model - defineModel()"></a>组件 v-model - defineModel()</h3><p><code>v-model</code> 可以在组件上使用以实现双向绑定。<br>从 Vue 3.4 开始，推荐的实现方式是使用 <code>defineModel()</code> 宏：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Child.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> model = defineModel()</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">  model.value++</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Parent bound v-model is: &#123;&#123; model &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"update"</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>父组件可以用 v-model 绑定一个值：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">v-model</span>=<span class="string">"countModel"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>defineModel()</code> 返回的值是一个 ref。它可以像其他 ref 一样被访问以及修改，不过它能起到在父组件和当前变量之间的双向绑定的作用：</p>
<ul>
<li>它的 .value 和父组件的 v-model 的值同步；</li>
<li>当它被子组件变更了，会触发父组件绑定的值一起更新。</li>
</ul>
<p>这意味着你也可以用 <code>v-model</code> 把这个 ref 绑定到一个原生 input 元素上，在提供相同的 <code>v-model</code> 用法的同时轻松包装原生 input 元素：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- app.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child.vue'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> msg = ref(<span class="string">'Hello World!'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Child</span> <span class="attr">v-model</span>=<span class="string">"msg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Child.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> model = defineModel()</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>My input<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"model"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h4><p><code>defineModel</code> 是一个便利宏。编译器将其展开为以下内容：</p>
<ul>
<li>一个名为 modelValue 的 prop，本地 ref 的值与其同步；</li>
<li>一个名为 update:modelValue 的事件，当本地 ref 的值发生变更时触发。</li>
</ul>
<p>在 3.4 版本之前，你一般会按照如下的方式来实现上述相同的子组件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Child.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> props = defineProps([<span class="string">'modelValue'</span>])</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> emit = defineEmits([<span class="string">'update:modelValue'</span>])</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:value</span>=<span class="string">"props.modelValue"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">input</span>=<span class="string">"emit('update:modelValue', $event.target.value)"</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后，父组件中的 <code>v-model=&quot;foo&quot;</code> 将被编译为：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Child</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:modelValue</span>=<span class="string">"foo"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">update:modelValue</span>=<span class="string">"$event =&gt; (foo = $event)"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="v-model-的参数"><a href="#v-model-的参数" class="headerlink" title="v-model 的参数"></a>v-model 的参数</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./MyComponent.vue'</span></span></span><br><span class="line">  </span><br><span class="line"><span class="javascript"><span class="keyword">const</span> bookTitle = ref(<span class="string">'v-model argument example'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; bookTitle &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-model:title</span>=<span class="string">"bookTitle"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> title = defineModel(<span class="string">'title'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"title"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="多个-v-model-绑定"><a href="#多个-v-model-绑定" class="headerlink" title="多个 v-model 绑定"></a>多个 v-model 绑定</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- parent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">UserName</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model:first-name</span>=<span class="string">"first"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model:last-name</span>=<span class="string">"last"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- UserName.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> firstName = defineModel(<span class="string">'firstName'</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> lastName = defineModel(<span class="string">'lastName'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"firstName"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"lastName"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="处理-v-model-修饰符"><a href="#处理-v-model-修饰符" class="headerlink" title="处理 v-model 修饰符"></a>处理 v-model 修饰符</h4><p>我们来创建一个自定义的修饰符 <code>capitalize</code>，它会自动将 <code>v-model</code> 绑定输入的字符串值第一个字母转为大写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./MyComponent.vue'</span></span></span><br><span class="line">  </span><br><span class="line"><span class="javascript"><span class="keyword">const</span> myText = ref(<span class="string">''</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  This input capitalizes the first letter you enter:</span><br><span class="line">  <span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-model.capitalize</span>=<span class="string">"myText"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyComponent.vue</span></span><br><span class="line"><span class="keyword">const</span> [model, modifiers] = defineModel(&#123;</span><br><span class="line">  <span class="keyword">set</span>(value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (modifiers.capitalize) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;template&gt;</span></span><br><span class="line"><span class="regexp">  &lt;input type="text" v-model="model" /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="带参数的-v-model-修饰符​"><a href="#带参数的-v-model-修饰符​" class="headerlink" title="带参数的 v-model 修饰符​"></a>带参数的 v-model 修饰符​</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">UserName</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model:first-name.capitalize</span>=<span class="string">"first"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model:last-name.uppercase</span>=<span class="string">"last"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">const</span> [firstName, firstNameModifiers] = defineModel(<span class="string">'firstName'</span>)</span><br><span class="line"><span class="keyword">const</span> [lastName, lastNameModifiers] = defineModel(<span class="string">'lastName'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstNameModifiers) <span class="comment">// &#123; capitalize: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(lastNameModifiers) <span class="comment">// &#123; uppercase: true &#125;</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="透传-Attributes"><a href="#透传-Attributes" class="headerlink" title="透传 Attributes"></a>透传 Attributes</h3><p>“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 <code>props</code> 或 <code>emits</code> 的 <code>attribute</code> 或者 <code>v-on</code> 事件监听器。最常见的例子就是 <code>class`</code>、style<code>和</code>id`。</p>
<p>当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到根元素上。举例来说，假如我们有一个 <code>&lt;MyButton&gt;</code> 组件，它的模板长这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;MyButton&gt; 的模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个父组件使用了这个组件，并且传入了 <code>class</code>：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyButton</span> <span class="attr">class</span>=<span class="string">"large"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>最后渲染出的 DOM 结果是：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"large"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里，<code>&lt;MyButton&gt;</code> 并没有将 <code>class</code> 声明为一个它所接受的 prop，所以 <code>class</code> 被视作透传 attribute，自动透传到了 <code>&lt;MyButton&gt;</code> 的根元素上。</p>
<h4 id="对-class-和-style-的合并"><a href="#对-class-和-style-的合并" class="headerlink" title="对 class 和 style 的合并"></a>对 class 和 style 的合并</h4><p>如果一个子组件的根元素已经有了 class 或 style attribute，它会和从父组件上继承的值合并。如果我们将之前的 <code>&lt;MyButton&gt;</code> 组件的模板改成这样：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;MyButton&gt; 的模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>则最后渲染出的 DOM 结果会变成：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn large"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="v-on-监听器继承"><a href="#v-on-监听器继承" class="headerlink" title="v-on 监听器继承"></a>v-on 监听器继承</h4><p>同样的规则也适用于 <code>v-on</code> 事件监听器：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyButton</span> @<span class="attr">click</span>=<span class="string">"onClick"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>click</code> 监听器会被添加到 <code>&lt;MyButton&gt;</code> 的根元素，即那个原生的 <code>&lt;button&gt;</code> 元素之上。当原生的 <code>&lt;button&gt;</code> 被点击，会触发父组件的 <code>onClick</code> 方法。同样的，如果原生 <code>button</code> 元素自身也通过 <code>v-on</code> 绑定了一个事件监听器，则这个监听器和从父组件继承的监听器都会被触发。</p>
<h4 id="深层组件继承"><a href="#深层组件继承" class="headerlink" title="深层组件继承"></a>深层组件继承</h4><p>有些情况下一个组件会在根节点上渲染另一个组件。例如，我们重构一下 <code>&lt;MyButton&gt;</code>，让它在根节点上渲染 <code>&lt;BaseButton&gt;</code>：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;MyButton/&gt; 的模板，只是渲染另一个组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BaseButton</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>此时 <code>&lt;MyButton&gt;</code> 接收的透传 attribute 会直接继续传给<code>&lt;BaseButton&gt;</code>。</p>
<blockquote>
<p>请注意：</p>
<ul>
<li>透传的 <code>attribute</code> 不会包含 <code>&lt;MyButton&gt;</code> 上声明过的 <code>props</code> 或是针对 <code>emits</code> 声明事件的 <code>v-on</code> 侦听函数，换句话说，声明过的 <code>props</code> 和侦听函数被 <code>&lt;MyButton&gt;</code>“消费”了。</li>
<li>透传的 <code>attribute</code> 若符合声明，也可以作为 <code>props</code> 传入 <code>&lt;BaseButton&gt;</code>。</li>
</ul>
</blockquote>
<hr>
<h4 id="禁用-Attributes-继承"><a href="#禁用-Attributes-继承" class="headerlink" title="禁用 Attributes 继承"></a>禁用 Attributes 继承</h4><p>如果你<strong>不想要</strong>一个组件自动地继承 attribute，你可以在组件选项中设置 <code>inheritAttrs: false</code>。<br>从 <code>3.3</code> 开始你也可以直接在 <code>&lt;script setup&gt;</code> 中使用 <code>defineOptions</code>：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line">defineOptions(&#123;</span><br><span class="line"><span class="javascript">  inheritAttrs: <span class="literal">false</span></span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="javascript"><span class="comment">// ...setup 逻辑</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>最常见的需要禁用 attribute 继承的场景就是 attribute 需要应用在根节点以外的其他元素上。通过设置 <code>inheritAttrs</code> 选项为 <code>false</code>，你可以完全控制透传进来的 attribute 被如何使用。</p>
<p>这些透传进来的 attribute 可以在模板的表达式中直接用 <code>$attrs</code> 访问到。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Fallthrough attribute: &#123;&#123; $attrs &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个 <code>$attrs</code> 对象包含了除组件所声明的 <code>props</code> 和 <code>emits</code> 之外的所有其他 attribute，例如 <code>class</code>，<code>style</code>，<code>v-on</code> 监听器等等。</p>
<blockquote>
<p>有几点需要注意：</p>
<ul>
<li>和 props 有所不同，透传 attributes 在 JavaScript 中保留了它们原始的大小写，所以像 <code>foo-bar</code> 这样的一个 attribute 需要通过 <code>$attrs[&#39;foo-bar&#39;]</code> 来访问。</li>
<li>像 <code>@click</code> 这样的一个 <code>v-on</code> 事件监听器将在此对象下被暴露为一个函数 <code>$attrs.onClick</code>。</li>
</ul>
</blockquote>
<p>现在我们要再次使用一下之前小节中的 <code>&lt;MyButton&gt;</code> 组件例子。有时候我们可能为了样式，需要在 <code>&lt;button&gt;</code> 元素外包装一层 <code>&lt;div&gt;</code>：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"btn-wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们想要所有像 <code>class</code> 和 <code>v-on</code> 监听器这样的透传 attribute 都应用在内部的 <code>&lt;button&gt;</code> 上而不是外层的 &lt;<code>div&gt;</code> 上。我们可以通过设定 <code>inheritAttrs: false</code> 和使用 <code>v-bind=&quot;$attrs&quot;</code> 来实现：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"btn-wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">v-bind</span>=<span class="string">"$attrs"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>小提示：没有参数的 <code>v-bind</code> 会将一个对象的所有属性都作为 attribute 应用到目标元素上。如一下例子：</p>
</blockquote>
<p>如果你有像这样的一个包含多个 attribute 的 JavaScript 对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> objectOfAttrs = &#123;</span><br><span class="line">  id: <span class="string">'container'</span>,</span><br><span class="line">  class: 'wrapper',</span><br><span class="line">  style: <span class="string">'background-color:green'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过不带参数的 <code>v-bind</code>，你可以将它们绑定到单个元素上：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">"objectOfAttrs"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="多个根节点的-Attributes-继承"><a href="#多个根节点的-Attributes-继承" class="headerlink" title="多个根节点的 Attributes 继承"></a>多个根节点的 Attributes 继承</h4><p>和单根节点组件有所不同，有着多个根节点的组件没有自动 attribute 透传行为。如果 <code>$attrs</code> 没有被显式绑定，将会抛出一个运行时警告。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">CustomLayout</span> <span class="attr">id</span>=<span class="string">"custom-layout"</span> @<span class="attr">click</span>=<span class="string">"changeValue"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果 <code>&lt;CustomLayout&gt;</code> 有下面这样的多根节点模板，由于 Vue 不知道要将 attribute 透传到哪里，所以会抛出一个警告。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果 <code>$attrs</code> 被显式绑定，则不会有警告：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">v-bind</span>=<span class="string">"$attrs"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="在-JavaScript-中访问透传-Attributes-useAttrs"><a href="#在-JavaScript-中访问透传-Attributes-useAttrs" class="headerlink" title="在 JavaScript 中访问透传 Attributes - useAttrs()"></a>在 JavaScript 中访问透传 Attributes - useAttrs()</h4><p>如果需要，你可以在 <code>&lt;script setup&gt;</code> 中使用 <code>useAttrs()</code> API 来访问一个组件的所有透传 attribute：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; useAttrs &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> attrs = useAttrs()</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果没有使用 <code>&lt;script setup&gt;</code>，<code>attrs</code> 会作为 <code>setup()</code> 上下文对象的一个属性暴露：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup(props, ctx) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.attrs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>需要注意的是，虽然这里的 <code>attrs</code> 对象总是反映为最新的透传 attribute，但它并不是响应式的 (考虑到性能因素)。你不能通过侦听器去监听它的变化。如果你需要响应性，可以使用 prop。或者你也可以使用 <code>onUpdated()</code> 使得在每次更新时结合最新的 <code>attrs</code> 执行副作用。</p>
</blockquote>
<h3 id="插槽-Slots"><a href="#插槽-Slots" class="headerlink" title="插槽 Slots"></a>插槽 Slots</h3><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>有时在一个组件中包含多个插槽出口是很有用的。举例来说，在一个 <code>&lt;BaseLayout&gt;</code> 组件中，有如下模板：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标题内容放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 主要内容放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 底部内容放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>对于这种场景，<code>&lt;slot&gt;</code> 元素可以有一个特殊的 attribute <code>name</code>，用来给各个插槽分配唯一的 ID，以确定每一处要渲染的内容：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这类带 <code>name</code> 的插槽被称为具名插槽 (named slots)。没有提供 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会隐式地命名为“default”。</p>
<p>在父组件中使用 <code>&lt;BaseLayout&gt;</code> 时，我们需要一种方式将多个插槽内容传入到各自目标插槽的出口。此时就需要用到<strong>具名插槽</strong>了：</p>
<p>要为具名插槽传入内容，我们需要使用一个含 <code>v-slot</code> 指令的 <code>&lt;template&gt;</code> 元素，并将目标插槽的名字传给该指令：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">BaseLayout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- header 插槽的内容放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BaseLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>v-slot</code> 有对应的简写 <code>#</code>，因此 <code>&lt;template v-slot:header&gt;</code> 可以简写为 <code>&lt;template #header&gt;</code>。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。</p>
<p>下面我们给出完整的、向 <code>&lt;BaseLayout&gt;</code> 传递插槽内容的代码，指令均使用的是缩写形式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">BaseLayout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BaseLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当一个组件同时接收默认插槽和具名插槽时，所有位于顶级的非 <code>&lt;template&gt;</code> 节点都被隐式地视为默认插槽的内容。所以上面也可以写成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">BaseLayout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 隐式的默认插槽 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BaseLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在 <code>&lt;template&gt;</code> 元素中的所有内容都将被传递到相应的插槽。最终渲染出的 HTML 如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="条件插槽"><a href="#条件插槽" class="headerlink" title="条件插槽"></a>条件插槽</h4><p>有时你需要根据内容是否被传入了插槽来渲染某些内容。</p>
<p>你可以结合使用 <code>$slots</code> 属性与 <code>v-if</code> 来实现。</p>
<p>在下面的示例中，我们定义了一个卡片组件，它拥有三个条件插槽：<code>header</code>、<code>footer</code> 和 <code>default</code>。 当 header、footer 或 default 的内容存在时，我们希望包装它以提供额外的样式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"$slots.header"</span> <span class="attr">class</span>=<span class="string">"card-header"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"$slots.default"</span> <span class="attr">class</span>=<span class="string">"card-content"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"$slots.footer"</span> <span class="attr">class</span>=<span class="string">"card-footer"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Card</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is the header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is the content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">em</span>&gt;</span>This is the footer<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h4><p><strong>动态指令参数</strong>在 <code>v-slot</code> 上也是有效的，即可以定义下面这样的动态插槽名：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:</span>[<span class="attr">dynamicSlotName</span>]&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 缩写为 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #[<span class="attr">dynamicSlotName</span>]&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>在上面的渲染作用域中我们讨论到，插槽的内容无法访问到子组件的状态。</p>
<p>然而在某些场景下插槽的内容可能想要同时使用父组件域内和子组件域内的数据。要做到这一点，我们需要一种方法来让<code>子组件在渲染时将一部分数据提供给插槽</code>。</p>
<p>我们也确实有办法这么做！可以像对组件传递 props 那样，向一个插槽的出口上传递 attributes：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;MyComponent&gt; 的模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> greetingMessage = <span class="string">'hello'</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:text</span>=<span class="string">"greetingMessage"</span> <span class="attr">:count</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当需要接收插槽 props 时，默认插槽和具名插槽的使用方式有一些小区别。下面我们将先展示默认插槽如何接受 props，通过子组件标签上的 <code>v-slot</code> 指令，直接接收到了一个插槽 props 对象：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- app.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-slot</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.text &#125;&#125; &#123;&#123; slotProps.count &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/img-folder/v3-2.png"></p>
<h4 id="具名作用域插槽"><a href="#具名作用域插槽" class="headerlink" title="具名作用域插槽"></a>具名作用域插槽</h4><p>具名作用域插槽的工作方式也是类似的，插槽 props 可以作为 <code>v-slot</code> 指令的值被访问到：<code>v-slot:name=&quot;slotProps&quot;</code>。当使用缩写时是这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>=<span class="string">"headerProps"</span>&gt;</span></span><br><span class="line">    &#123;&#123; headerProps &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">"defaultProps"</span>&gt;</span></span><br><span class="line">    &#123;&#123; defaultProps &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>=<span class="string">"footerProps"</span>&gt;</span></span><br><span class="line">    &#123;&#123; footerProps &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>向具名插槽中传入 props：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span> <span class="attr">message</span>=<span class="string">"hello"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意插槽上的 <code>name</code> 是一个 Vue 特别保留的 attribute，不会作为 props 传递给插槽。因此最终 <code>headerProps</code> 的结果是 <code>{ message: &#39;hello&#39; }</code>。</p>
<p>如果你同时使用了具名插槽与默认插槽，则需要为默认插槽使用显式的 <code>&lt;template&gt;</code> 标签。尝试直接为组件添加 <code>v-slot</code> 指令将导致编译错误。这是为了避免因默认插槽的 props 的作用域而困惑。举例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;MyComponent&gt; template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:message</span>=<span class="string">"hello"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 该模板无法编译 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-slot</span>=<span class="string">"&#123; message &#125;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- message 属于默认插槽，此处不可用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为默认插槽使用显式的 <code>&lt;template&gt;</code> 标签有助于更清晰地指出 <code>message</code> 属性在其他插槽中不可用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用显式的默认插槽 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">default</span>=<span class="string">"&#123; message &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="高级列表组件示例"><a href="#高级列表组件示例" class="headerlink" title="高级列表组件示例"></a>高级列表组件示例</h4><p>你可能想问什么样的场景才适合用到作用域插槽，这里我们来看一个 <code>&lt;FancyList&gt;</code> 组件的例子。它会渲染一个列表，并同时会封装一些加载远端数据的逻辑、使用数据进行列表渲染、或者是像分页或无限滚动这样更进阶的功能。然而我们希望它能够保留足够的灵活性，将对单个列表元素内容和样式的控制权留给使用它的父组件。我们期望的用法可能是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- app.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FancyList</span> <span class="attr">:api-url</span>=<span class="string">"url"</span> <span class="attr">:per-page</span>=<span class="string">"10"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">item</span>=<span class="string">"&#123; body, username, likes &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; body &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>by &#123;&#123; username &#125;&#125; | &#123;&#123; likes &#125;&#125; likes<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FancyList</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>&lt;FancyList&gt;</code> 之中，我们可以多次渲染 <code>&lt;slot&gt;</code> 并每次都提供不同的数据 (注意我们这里使用了 <code>v-bind</code> 来传递插槽的 props)：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- FancyList.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> props = defineProps([<span class="string">'api-url'</span>, <span class="string">'per-page'</span>])</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> items = ref([])</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// mock remote data fetching</span></span></span><br><span class="line"><span class="javascript">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line">  items.value = [</span><br><span class="line"><span class="javascript">    &#123; <span class="attr">body</span>: <span class="string">'Scoped Slots Guide'</span>, <span class="attr">username</span>: <span class="string">'Evan You'</span>, <span class="attr">likes</span>: <span class="number">20</span> &#125;,</span></span><br><span class="line"><span class="javascript">	  &#123; <span class="attr">body</span>: <span class="string">'Vue Tutorial'</span>, <span class="attr">username</span>: <span class="string">'Natalia Tepluhina'</span>, <span class="attr">likes</span>: <span class="number">10</span> &#125;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;, 1000)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-if</span>=<span class="string">"!items.length"</span>&gt;</span></span><br><span class="line">      Loading...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"item"</span> <span class="attr">v-bind</span>=<span class="string">"item"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="无渲染组件"><a href="#无渲染组件" class="headerlink" title="无渲染组件"></a>无渲染组件</h4><p>上面的 <code>&lt;FancyList&gt;</code> 案例同时封装了可重用的逻辑 (数据获取、分页等) 和视图输出，但也将部分视图输出通过作用域插槽交给了消费者组件来管理。</p>
<p>如果我们将这个概念拓展一下，可以想象的是，一些组件可能只包括了逻辑而不需要自己渲染内容，视图输出通过作用域插槽全权交给了消费者组件。我们将这种类型的组件称为<strong>无渲染组件</strong>。</p>
<p>这里有一个无渲染组件的例子，一个封装了追踪当前鼠标位置逻辑的组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- app.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> MouseTracker <span class="keyword">from</span> <span class="string">'./MouseTracker.vue'</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">MouseTracker</span> <span class="attr">v-slot</span>=<span class="string">"&#123; x, y &#125;"</span>&gt;</span></span><br><span class="line">  	Mouse is at: &#123;&#123; x &#125;&#125;, &#123;&#123; y &#125;&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">MouseTracker</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MouseTracker.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref, onMounted, onUnmounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line">  </span><br><span class="line"><span class="javascript"><span class="keyword">const</span> x = ref(<span class="number">0</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> y = ref(<span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> update = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line">  x.value = e.pageX</span><br><span class="line">  y.value = e.pageY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">onMounted(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, update))</span></span><br><span class="line"><span class="javascript">onUnmounted(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">window</span>.removeEventListener(<span class="string">'mousemove'</span>, update))</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:x</span>=<span class="string">"x"</span> <span class="attr">:y</span>=<span class="string">"y"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><h4 id="Prop-逐级透传问题-provide-inject"><a href="#Prop-逐级透传问题-provide-inject" class="headerlink" title="Prop 逐级透传问题 - provide / inject"></a>Prop 逐级透传问题 - provide / inject</h4><p>通常情况下，当我们需要从父组件向子组件传递数据时，会使用 <code>props</code>。想象一下这样的结构：有一些多层级嵌套的组件，形成了一棵巨大的组件树，而某个深层的子组件需要一个较远的祖先组件中的部分数据。在这种情况下，如果仅使用 props 则必须将其沿着组件链逐级传递下去，这会非常麻烦：</p>
<p><img src="/images/img-folder/prop-drilling.XJXa8UE-.png"></p>
<p>注意，虽然这里的 <code>&lt;Footer&gt;</code> 组件可能根本不关心这些 props，但为了使 <code>&lt;DeepChild&gt;</code> 能访问到它们，仍然需要定义并向下传递。如果组件链路非常长，可能会影响到更多这条路上的组件。这一问题被称为“prop 逐级透传”，显然是我们希望尽量避免的情况。</p>
<p><code>provide</code> 和 <code>inject</code> 可以帮助我们解决这一问题 [1]。一个父组件相对于其所有的后代组件，会作为<strong>依赖提供者</strong>。任何后代的组件树，无论层级有多深，都可以<strong>注入</strong>由父组件提供给整条链路的依赖。</p>
<p><img src="/images/img-folder/provide-inject.C0gAIfVn.png"></p>
<hr>
<h4 id="Provide-提供"><a href="#Provide-提供" class="headerlink" title="Provide (提供)"></a><strong>Provide (提供)</strong></h4><p>要为组件后代提供数据，需要使用到 <code>provide()</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; provide &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">provide(<span class="comment">/* 注入名 */</span> <span class="string">'message'</span>, <span class="comment">/* 值 */</span> <span class="string">'hello!'</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不使用 <code>&lt;script setup&gt;</code>，请确保 <code>provide()</code> 是在 <code>setup()</code> 同步调用的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; provide &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    provide(<span class="comment">/* 注入名 */</span> <span class="string">'message'</span>, <span class="comment">/* 值 */</span> <span class="string">'hello!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>provide()</code> 函数接收两个参数。第一个参数被称为注入名，可以是一个字符串或是一个 <code>Symbol</code>。后代组件会用注入名来查找期望注入的值。一个组件可以多次调用 <code>provide()</code>，使用不同的注入名，注入不同的依赖值。</p>
<p>第二个参数是提供的值，值可以是任意类型，包括响应式的状态，比如一个 ref：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, provide &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">provide(<span class="string">'key'</span>, count)</span><br></pre></td></tr></table></figure>
<p>提供的响应式状态使后代组件可以由此和提供者建立响应式的联系。</p>
<hr>
<h4 id="应用层-Provide"><a href="#应用层-Provide" class="headerlink" title="应用层 Provide"></a><strong>应用层 Provide</strong></h4><p>除了在一个组件中提供依赖，我们还可以在整个应用层面提供依赖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line"></span><br><span class="line">app.provide(<span class="comment">/* 注入名 */</span> <span class="string">'message'</span>, <span class="comment">/* 值 */</span> <span class="string">'hello!'</span>)</span><br></pre></td></tr></table></figure>
<p>在应用级别提供的数据在该应用内的所有组件中都可以注入。这在你编写插件时会特别有用，因为插件一般都不会使用组件形式来提供值。</p>
<hr>
<h4 id="Inject-注入"><a href="#Inject-注入" class="headerlink" title="Inject (注入)"></a><strong>Inject (注入)</strong></h4><p>要注入上层组件提供的数据，需使用 <code>inject()</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> message = inject(<span class="string">'message'</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果有多个父组件提供了相同键的数据，注入将解析为组件链上最近的父组件所注入的值。</p>
<p>如果提供的值是一个 ref，注入进来的会是该 ref 对象，而<strong>不会</strong>自动解包为其内部的值。这使得注入方组件能够通过 ref 对象保持了和供给方的响应性链接。</p>
<hr>
<p><strong>以下是完整的一个示例：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- app.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; ref, provide &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./Child.vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> message = ref(<span class="string">'hello'</span>)</span></span><br><span class="line"><span class="javascript">provide(<span class="string">'message'</span>, message)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- child.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> GrandChild <span class="keyword">from</span> <span class="string">'./GrandChild.vue'</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">GrandChild</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- GrandChild.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> message = inject(<span class="string">'message'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Message to grand child: &#123;&#123; message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以下是效果图：</p>
<p><img src="/images/img-folder/微信图片_20250913160520_120_77.png"></p>
<hr>
<h4 id="注入默认值"><a href="#注入默认值" class="headerlink" title="注入默认值"></a>注入默认值</h4><p>默认情况下，<code>inject</code> 假设传入的注入名会被某个祖先链上的组件提供。如果该注入名的确没有任何组件提供，则会抛出一个运行时警告。</p>
<p>如果在注入一个值时不要求必须有提供者，那么我们应该声明一个默认值，和 props 类似：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果没有祖先组件提供 "message"</span></span><br><span class="line"><span class="comment">// `value` 会是 "这是默认值"</span></span><br><span class="line"><span class="keyword">const</span> value = inject(<span class="string">'message'</span>, <span class="string">'这是默认值'</span>)</span><br></pre></td></tr></table></figure>
<p>在一些场景中，默认值可能需要通过调用一个函数或初始化一个类来取得。为了避免在用不到默认值的情况下进行不必要的计算或产生副作用，我们可以使用工厂函数来创建默认值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = inject(<span class="string">'message'</span>, () =&gt; <span class="keyword">new</span> ExpensiveClass(), <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>第三个参数表示默认值应该被当作一个工厂函数。</p>
<hr>
<h4 id="和响应式数据配合使用"><a href="#和响应式数据配合使用" class="headerlink" title="和响应式数据配合使用"></a>和响应式数据配合使用</h4><p>当提供 / 注入响应式的数据时，<strong>建议尽可能将任何对响应式状态的变更都保持在供给方组件中</strong>。这样可以确保所提供状态的声明和变更操作都内聚在同一个组件内，使其更容易维护。</p>
<p>有的时候，我们可能需要在注入方组件中更改数据。在这种情况下，我们推荐在供给方组件内声明并提供一个更改数据的方法函数：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在供给方组件内 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; provide, ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> location = ref(<span class="string">'North Pole'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">updateLocation</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  location.value = <span class="string">'South Pole'</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">provide(<span class="string">'location'</span>, &#123;</span></span><br><span class="line">  location,</span><br><span class="line">  updateLocation</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line"><span class="comment">&lt;!-- 在注入方组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> &#123; location, updateLocation &#125; = inject(<span class="string">'location'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"updateLocation"</span>&gt;</span>&#123;&#123; location &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后，如果你想确保提供的数据不能被注入方的组件更改，你可以使用 <code>readonly()</code> 来包装提供的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, provide, readonly &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">provide(<span class="string">'read-only-count'</span>, readonly(count))</span><br></pre></td></tr></table></figure>
<h4 id="使用-Symbol-作注入名"><a href="#使用-Symbol-作注入名" class="headerlink" title="使用 Symbol 作注入名"></a>使用 Symbol 作注入名</h4><p>至此，我们已经了解了如何使用字符串作为注入名。但如果你正在构建大型的应用，包含非常多的依赖提供，或者你正在编写提供给其他开发者使用的组件库，建议最好使用 Symbol 来作为注入名以避免潜在的冲突。</p>
<p>我们通常推荐在一个单独的文件中导出这些注入名 Symbol：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keys.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myInjectionKey = <span class="built_in">Symbol</span>()</span><br></pre></td></tr></table></figure>
<p>然后，在供给方组件中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; provide &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; myInjectionKey &#125; <span class="keyword">from</span> <span class="string">'./keys.js'</span></span><br><span class="line"></span><br><span class="line">provide(myInjectionKey, <span class="string">'hello!'</span>)</span><br></pre></td></tr></table></figure>
<p>最后，在注入方组件中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; myInjectionKey &#125; <span class="keyword">from</span> <span class="string">'./keys.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> message = inject(myInjectionKey)</span><br></pre></td></tr></table></figure>
<h3 id="异步组件-async-components"><a href="#异步组件-async-components" class="headerlink" title="异步组件 - async-components"></a>异步组件 - async-components</h3><h4 id="基本用法-basic-usage"><a href="#基本用法-basic-usage" class="headerlink" title="基本用法 - basic-usage"></a>基本用法 - basic-usage</h4><p>在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 <a href="/api/general#defineasynccomponent"><code>defineAsyncComponent</code></a> 方法来实现此功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AsyncComp = defineAsyncComponent(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...从服务器获取组件</span></span><br><span class="line">    resolve(<span class="comment">/* 获取到的组件 */</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ... 像使用其他一般组件一样使用 `AsyncComp`</span></span><br></pre></td></tr></table></figure>
<p>如你所见，<code>defineAsyncComponent</code> 方法接收一个返回 Promise 的加载函数。这个 Promise 的 <code>resolve</code> 回调方法应该在从服务器获得组件定义时调用。你也可以调用 <code>reject(reason)</code> 表明加载失败。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import" target="_blank" rel="noopener">ES 模块动态导入</a>也会返回一个 Promise，所以多数情况下我们会将它和 <code>defineAsyncComponent</code> 搭配使用。类似 Vite 和 Webpack 这样的构建工具也支持此语法 (并且会将它们作为打包时的代码分割点)，因此我们也可以用它来导入 Vue 单文件组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AsyncComp = defineAsyncComponent(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./components/MyComponent.vue'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>最后得到的 <code>AsyncComp</code> 是一个外层包装过的组件，仅在页面需要它渲染时才会调用加载内部实际组件的函数。它会将接收到的 props 和插槽传给内部组件，所以你可以使用这个异步的包装组件无缝地替换原始组件，同时实现延迟加载。</p>
<p>与普通组件一样，异步组件可以使用 <code>app.component()</code> <a href="/guide/components/registration#global-registration">全局注册</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.component(<span class="string">'MyComponent'</span>, defineAsyncComponent(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'./components/MyComponent.vue'</span>)</span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p>你也可以在<a href="/guide/components/registration#local-registration">局部注册组件</a>时使用 <code>defineAsyncComponent</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  components: &#123;</span><br><span class="line"><span class="javascript">    AdminPage: defineAsyncComponent(<span class="function"><span class="params">()</span> =&gt;</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">import</span>(<span class="string">'./components/AdminPageComponent.vue'</span>)</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">AdminPage</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p></p>
<p>也可以直接在父组件中直接定义它们：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> AdminPage = defineAsyncComponent(<span class="function"><span class="params">()</span> =&gt;</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span>(<span class="string">'./components/AdminPageComponent.vue'</span>)</span></span><br><span class="line">)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">AdminPage</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="加载与错误状态-loading-and-error-states"><a href="#加载与错误状态-loading-and-error-states" class="headerlink" title="加载与错误状态 - loading-and-error-states"></a>加载与错误状态 - loading-and-error-states</h4><p>异步操作不可避免地会涉及到加载和错误状态，因此 <code>defineAsyncComponent()</code> 也支持在高级选项中处理这些状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComp = defineAsyncComponent(&#123;</span><br><span class="line">  <span class="comment">// 加载函数</span></span><br><span class="line">  loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./Foo.vue'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载异步组件时使用的组件</span></span><br><span class="line">  loadingComponent: LoadingComponent,</span><br><span class="line">  <span class="comment">// 展示加载组件前的延迟时间，默认为 200ms</span></span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载失败后展示的组件</span></span><br><span class="line">  errorComponent: ErrorComponent,</span><br><span class="line">  <span class="comment">// 如果提供了一个 timeout 时间限制，并超时了</span></span><br><span class="line">  <span class="comment">// 也会显示这里配置的报错组件，默认值是：Infinity</span></span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果提供了一个加载组件，它将在内部组件加载时先行显示。在加载组件显示之前有一个默认的 200ms 延迟——这是因为在网络状况较好时，加载完成得很快，加载组件和最终组件之间的替换太快可能产生闪烁，反而影响用户感受。</p>
<p>如果提供了一个报错组件，则它会在加载器函数返回的 Promise 抛错时被渲染。你还可以指定一个超时时间，在请求耗时超过指定时间时也会渲染报错组件。</p>
<h4 id="惰性激活"><a href="#惰性激活" class="headerlink" title="惰性激活"></a>惰性激活</h4><blockquote>
<p>如果你正在使用<a href="/guide/scaling-up/ssr">服务器端渲染</a>，这一部分才会适用。</p>
</blockquote>
<p>在 Vue 3.5+ 中，异步组件可以通过提供激活策略来控制何时进行激活。</p>
<ul>
<li><p>Vue 提供了一些内置的激活策略。这些内置策略需要分别导入，以便在未使用时进行 tree-shake。</p>
</li>
<li><p>该设计有意保持在底层，以确保灵活性。将来可以在此基础上构建编译器语法糖，无论是在核心还是更上层的解决方案 (如 Nuxt) 中实现。</p>
</li>
</ul>
<h4 id="在空闲时进行激活-hydrate-on-idle"><a href="#在空闲时进行激活-hydrate-on-idle" class="headerlink" title="在空闲时进行激活 - hydrate-on-idle"></a>在空闲时进行激活 - hydrate-on-idle</h4><p>通过 <code>requestIdleCallback</code> 进行激活：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent, hydrateOnIdle &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AsyncComp = defineAsyncComponent(&#123;</span><br><span class="line">  loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./Comp.vue'</span>),</span><br><span class="line">  hydrate: hydrateOnIdle(<span class="comment">/* 传递可选的最大超时 */</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="在可见时激活-hydrate-on-visible"><a href="#在可见时激活-hydrate-on-visible" class="headerlink" title="在可见时激活 - hydrate-on-visible"></a>在可见时激活 - hydrate-on-visible</h4><p>通过 <code>IntersectionObserver</code> 在元素变为可见时进行激活。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent, hydrateOnVisible &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AsyncComp = defineAsyncComponent(&#123;</span><br><span class="line">  loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./Comp.vue'</span>),</span><br><span class="line">  hydrate: hydrateOnVisible()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可以选择传递一个侦听器的选项对象值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydrateOnVisible(&#123; <span class="attr">rootMargin</span>: <span class="string">'100px'</span> &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="在媒体查询匹配时进行激活-hydrate-on-media-query"><a href="#在媒体查询匹配时进行激活-hydrate-on-media-query" class="headerlink" title="在媒体查询匹配时进行激活 - hydrate-on-media-query"></a>在媒体查询匹配时进行激活 - hydrate-on-media-query</h4><p>当指定的媒体查询匹配时进行激活。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent, hydrateOnMediaQuery &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AsyncComp = defineAsyncComponent(&#123;</span><br><span class="line">  loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./Comp.vue'</span>),</span><br><span class="line">  hydrate: hydrateOnMediaQuery(<span class="string">'(max-width:500px)'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="交互时激活-hydrate-on-interaction"><a href="#交互时激活-hydrate-on-interaction" class="headerlink" title="交互时激活 - hydrate-on-interaction"></a>交互时激活 - hydrate-on-interaction</h4><p>当组件元素上触发指定事件时进行激活。完成激活后，触发激活的事件也将被重放。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent, hydrateOnInteraction &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AsyncComp = defineAsyncComponent(&#123;</span><br><span class="line">  loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./Comp.vue'</span>),</span><br><span class="line">  hydrate: hydrateOnInteraction(<span class="string">'click'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>也可以是多个事件类型的列表：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydrateOnInteraction([<span class="string">'wheel'</span>, <span class="string">'mouseover'</span>])</span><br></pre></td></tr></table></figure>
<h4 id="自定义策略-custom-strategy"><a href="#自定义策略-custom-strategy" class="headerlink" title="自定义策略 - custom-strategy"></a>自定义策略 - custom-strategy</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent, type HydrationStrategy &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myStrategy: HydrationStrategy = <span class="function">(<span class="params">hydrate, forEachElement</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// forEachElement 是一个遍历组件未激活的 DOM 中所有根元素的辅助函数，</span></span><br><span class="line">  <span class="comment">// 因为根元素可能是一个片段而非单个元素</span></span><br><span class="line">  forEachElement(<span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 准备好时调用 `hydrate`</span></span><br><span class="line">  hydrate()</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如必要，返回一个销毁函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AsyncComp = defineAsyncComponent(&#123;</span><br><span class="line">  loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./Comp.vue'</span>),</span><br><span class="line">  hydrate: myStrategy</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="搭配-Suspense-使用-using-with-suspense"><a href="#搭配-Suspense-使用-using-with-suspense" class="headerlink" title="搭配 Suspense 使用 - using-with-suspense"></a>搭配 Suspense 使用 - using-with-suspense</h4><p>异步组件可以搭配内置的 <code>&lt;Suspense&gt;</code> 组件一起使用，若想了解 <code>&lt;Suspense&gt;</code> 和异步组件之间交互，请参阅 <a href="/guide/built-ins/suspense"><code>&lt;Suspense&gt;</code></a> 章节。</p>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>除了 Vue 内置的一系列指令 (比如 <code>v-model</code> 或 <code>v-show</code>) 之外，Vue 还允许你注册自定义的指令 (Custom Directives)。</p>
<p>我们已经介绍了两种在 Vue 中重用代码的方式：<strong>组件</strong>和<strong>组合式函数</strong>。组件是主要的构建模块，而组合式函数则侧重于有状态的逻辑。另一方面，自定义指令主要是为了重用涉及普通元素的底层 DOM 访问的逻辑。</p>
<p>一个自定义指令由一个包含类似组件生命周期钩子的对象来定义。钩子函数会接收到指令所绑定元素作为其参数。下面是一个自定义指令的例子，当 Vue 将元素插入到 DOM 中后，该指令会将一个 class 添加到元素中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在模板中启用 v-highlight</span></span><br><span class="line"><span class="keyword">const</span> vHighlight = &#123;</span><br><span class="line">  mounted: <span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">    el.classList.add(<span class="string">'is-highlight'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p v-highlight&gt;This sentence is important!&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure>
<p>在 <code>&lt;script setup&gt;</code> 中，任何以 v 开头的驼峰式命名的变量都可以当作自定义指令使用。在上述例子中，<code>vHighlight</code> 可以在模板中以 <code>v-highlight</code> 的形式使用。</p>
<p>在不使用 <code>&lt;script setup&gt;</code> 的情况下，自定义指令需要通过 <code>directives</code> 选项注册：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;,</span><br><span class="line">  directives: &#123;</span><br><span class="line">    <span class="comment">// 在模板中启用 v-highlight</span></span><br><span class="line">    highlight: &#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将一个自定义指令全局注册到应用层级也是一种常见的做法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = createApp(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使 v-highlight 在所有组件中都可用</span></span><br><span class="line">app.directive(<span class="string">'highlight'</span>, &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="自定义指令的使用时机"><a href="#自定义指令的使用时机" class="headerlink" title="自定义指令的使用时机"></a>自定义指令的使用时机</h4><p>只有当所需功能只能通过直接的 DOM 操作来实现时，才应该使用自定义指令。</p>
<p>一个常见例子是使元素获取焦点的 <code>v-focus</code> 指令。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 在模板中启用 v-focus</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> vFocus = &#123;</span></span><br><span class="line"><span class="javascript">  mounted: <span class="function">(<span class="params">el</span>) =&gt;</span> el.focus()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-focus</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该指令比 <code>autofocus</code> 属性更有用，因为它不仅在页面加载时有效，而且在 Vue 动态插入元素时也有效！</p>
<p>建议尽可能使用 <code>v-bind</code> 等内置指令声明模板，因为它们更高效，对服务端渲染也更友好。</p>
<h4 id="指令钩子"><a href="#指令钩子" class="headerlink" title="指令钩子"></a>指令钩子</h4><p>一个指令的定义对象可以提供几种钩子函数 (都是可选的)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myDirective = &#123;</span><br><span class="line">  <span class="comment">// 在绑定元素的 attribute 前</span></span><br><span class="line">  <span class="comment">// 或事件监听器应用前调用</span></span><br><span class="line">  created(el, binding, vnode) &#123;</span><br><span class="line">    <span class="comment">// 下面会介绍各个参数的细节</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 在元素被插入到 DOM 前调用</span></span><br><span class="line">  beforeMount(el, binding, vnode) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line">  <span class="comment">// 及他自己的所有子节点都挂载完成后调用</span></span><br><span class="line">  mounted(el, binding, vnode) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件更新前调用</span></span><br><span class="line">  beforeUpdate(el, binding, vnode, prevVnode) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line">  <span class="comment">// 及他自己的所有子节点都更新后调用</span></span><br><span class="line">  updated(el, binding, vnode, prevVnode) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载前调用</span></span><br><span class="line">  beforeUnmount(el, binding, vnode) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定元素的父组件卸载后调用</span></span><br><span class="line">  unmounted(el, binding, vnode) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="钩子参数"><a href="#钩子参数" class="headerlink" title="钩子参数"></a>钩子参数</h4><p>指令钩子函数会被传入以下参数：</p>
<ul>
<li><code>el</code>：指令绑定到的元素。这可以用来直接操作 DOM。</li>
<li><code>binding</code>：一个对象，包含以下属性：<ul>
<li><code>value</code>：传递给指令的值。例如，在 <code>v-my-directive=&quot;1 + 1&quot;</code> 的情况下，值是 <code>2</code>。</li>
<li><code>oldValue</code>：之前的值，仅在 <code>beforeUpdate</code> 和 <code>updated</code> 中可用。无论值是否有改变都可用。</li>
<li><code>arg</code>：传递给指令的参数 (如果有的话)。例如，在 <code>v-my-directive:foo</code> 中，参数是 <code>&quot;foo&quot;</code>。</li>
<li><code>modifiers</code>：一个包含修饰符的对象 (如果有的话)。例如，在 <code>v-my-directive.foo.bar</code> 中，修饰符对象是 <code>{ foo: true, bar: true }</code>。</li>
<li><code>instance</code>：使用该指令的组件实例。</li>
<li><code>dir</code>：指令的定义对象。</li>
</ul>
</li>
<li><code>vnode</code>：代表绑定元素的底层 VNode。</li>
<li><code>prevNode</code>：之前的渲染中代表指令所绑定元素的 VNode。仅在 <code>beforeUpdate</code> 和 <code>updated</code> 钩子中可用。</li>
</ul>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-example:foo.bar</span>=<span class="string">"baz"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>binding</code> 参数会是一个这样的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  arg: <span class="string">'foo'</span>,</span><br><span class="line">  modifiers: &#123; <span class="attr">bar</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  value: <span class="comment">/* `baz` 的值 */</span>,</span><br><span class="line">  oldValue: <span class="comment">/* 上一次更新时 `baz` 的值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和内置指令类似，自定义指令的参数也可以是动态的。举例来说：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-example:</span>[<span class="attr">arg</span>]=<span class="string">"value"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里指令的参数会基于组件的 arg 数据属性响应式地更新。</p>
<blockquote>
<p>除了 el 外，其他参数都是只读的，不要更改它们。若你需要在不同的钩子间共享信息，推荐通过元素的 dataset attribute 实现。</p>
</blockquote>
<h4 id="简化形式"><a href="#简化形式" class="headerlink" title="简化形式"></a>简化形式</h4><p>对于自定义指令来说，一个很常见的情况是仅仅需要在 <code>mounted</code> 和 <code>updated</code> 上实现相同的行为，除此之外并不需要其他钩子。这种情况下我们可以直接用一个函数来定义指令，如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-color</span>=<span class="string">"color"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.directive(<span class="string">'color'</span>, (el, binding) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 这会在 `mounted` 和 `updated` 时都调用</span></span><br><span class="line">  el.style.color = binding.value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h4><p>如果你的指令需要多个值，你可以向它传递一个 JavaScript 对象字面量。别忘了，指令也可以接收任何合法的 JavaScript 表达式。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-demo</span>=<span class="string">"&#123; color: 'white', text: 'hello!' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.directive(<span class="string">'demo'</span>, (el, binding) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(binding.value.color) <span class="comment">// =&gt; "white"</span></span><br><span class="line">  <span class="built_in">console</span>.log(binding.value.text) <span class="comment">// =&gt; "hello!"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

        
    </section>
</article>





<div class="comments">
    <div id="comments"></div>
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
    new Gitalk({
        clientID: "7fbe80427f54741e289f",
        clientSecret: "f34ed5fd92e54c9000bd37ba951948cb939deff5",
        repo: "sanonz.github.io",
        owner: "sanonz",
        admin: ["sanonz"],
        id: "2025/05/04/存档",
        distractionFreeMode: true,
        title: "vue3 相关存档",
        body: "http://www.shuy.cc/2025/05/04/存档/",
        labels: ["vue3 pina router"]
    }).render('comments');
    </script>
</div>


        </div>
        <footer class="footer" style="color: #fff">
    <a href="https://beian.miit.gov.cn/" style="color: #fff" target="_blank">晋ICP备2024043727号-3</a>
</footer>

    </main>

    <script type="text/javascript" src="https://unpkg.com/jquery@1.9.1/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }

            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle('normal', slideDone);
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp('normal', slideDone);
            }, 3000);
        }

        function slideDone() {
            if (nodes.navInner.css('display') !== 'none') {
                nodes.navInner.css('display', '');
            }
        }

        $(window).on('resize', function() {
            console.log($(this).width())
            if ($(this).width() > 960) {
                nodes.navInner.css('display', '');
            }
        });
    });
    </script>
    
        <script src="/js/scrollspy.min.js"></script>
        <script type="text/javascript">
        $(document.body).scrollspy({target: '#aside-inner'});

        $(window).on('resize', function() {
            var hw = $('#header').width();
            var ww = $('#wrapper').width();
            var space = ($(this).width() - hw - ww) / 2 / 2;

            var pageprev = $('#pageprev');
            var pagenext = $('#pagenext');
            var avg = (pageprev.width() + pagenext.width()) / 2

            if(space > avg) {
                var len = space - avg / 2;
                // var styles = {position: 'fixed', top: '50%', marginTop: - (pageprev.width() + pagenext.width()) / 4}
                // pageprev.css($.extend({left: hw + len}, styles));
                // pagenext.css($.extend({right: len}, styles));
            } else {
                pageprev.removeAttr('style');
                // pagenext.removeAttr('style');
            }
        }).trigger('resize');
        </script>
    

</body>
</html>
